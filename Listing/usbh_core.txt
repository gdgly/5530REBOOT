; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\usbh_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\usbh_core.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\Libraries\STM32_USB_OTG_Driver\inc -I..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\User\usbh_mass_storage -I..\User\fatfs\src -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY -DSTM32F40XX --omf_browse=..\output\usbh_core.crf --no_multibyte_chars ..\Libraries\STM32_USB_HOST_Library\Core\src\usbh_core.c]
                          THUMB

                          AREA ||i.USBH_Connected||, CODE, READONLY, ALIGN=1

                  USBH_Connected PROC
;;;126    */
;;;127    uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev)
000000  2101              MOVS     r1,#1
;;;128    {
;;;129      pdev->host.ConnSts = 1;
000002  f8c017f4          STR      r1,[r0,#0x7f4]
;;;130      return 0;
000006  2000              MOVS     r0,#0
;;;131    }
000008  4770              BX       lr
;;;132    
                          ENDP


                          AREA ||i.USBH_DeInit||, CODE, READONLY, ALIGN=1

                  USBH_DeInit PROC
;;;232      */
;;;233    USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;234    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;235      /* Software Init */
;;;236      
;;;237      phost->gState = HOST_IDLE;
000006  2100              MOVS     r1,#0
000008  7021              STRB     r1,[r4,#0]
;;;238      phost->gStateBkp = HOST_IDLE; 
00000a  7061              STRB     r1,[r4,#1]
;;;239      phost->EnumState = ENUM_IDLE;
00000c  70a1              STRB     r1,[r4,#2]
;;;240      phost->RequestState = CMD_SEND;  
00000e  2201              MOVS     r2,#1
000010  70e2              STRB     r2,[r4,#3]
;;;241      
;;;242      phost->Control.state = CTRL_SETUP;
000012  7722              STRB     r2,[r4,#0x1c]
;;;243      phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
000014  2040              MOVS     r0,#0x40
000016  71a0              STRB     r0,[r4,#6]
;;;244      
;;;245      phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
000018  f8841020          STRB     r1,[r4,#0x20]
;;;246      phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
00001c  f8842021          STRB     r2,[r4,#0x21]
;;;247      
;;;248      USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
000020  7921              LDRB     r1,[r4,#4]
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USBH_Free_Channel
;;;249      USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
000028  7961              LDRB     r1,[r4,#5]
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       USBH_Free_Channel
;;;250      return USBH_OK;
000030  2000              MOVS     r0,#0
;;;251    }
000032  bd70              POP      {r4-r6,pc}
;;;252    
                          ENDP


                          AREA ||i.USBH_Disconnected||, CODE, READONLY, ALIGN=1

                  USBH_Disconnected PROC
;;;163    
;;;164    uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166      USB_OTG_BSP_DriveVBUS(pdev,0);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USB_OTG_BSP_DriveVBUS
;;;167      /* Disable all interrupts. */
;;;168      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  2500              MOVS     r5,#0
000010  6185              STR      r5,[r0,#0x18]
;;;169      
;;;170      /* Clear any pending interrupts. */
;;;171      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
000012  68e1              LDR      r1,[r4,#0xc]
000014  1e68              SUBS     r0,r5,#1
000016  6148              STR      r0,[r1,#0x14]
;;;172      USB_OTG_DisableGlobalInt(pdev);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       USB_OTG_DisableGlobalInt
;;;173      pdev->host.ConnSts = 0;
00001e  f8c457f4          STR      r5,[r4,#0x7f4]
;;;174      return 0;  
000022  2000              MOVS     r0,#0
;;;175    }
000024  bd70              POP      {r4-r6,pc}
;;;176    
                          ENDP


                          AREA ||i.USBH_ErrorHandle||, CODE, READONLY, ALIGN=1

                  USBH_ErrorHandle PROC
;;;454      */
;;;455    void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
000000  b570              PUSH     {r4-r6,lr}
;;;456    {
000002  4604              MOV      r4,r0
;;;457      /* Error unrecovered or not supported device speed */
;;;458      if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
;;;459           (errType == USBH_UNRECOVERED_ERROR) )
;;;460      {
;;;461        phost->usr_cb->UnrecoveredError(); 
;;;462        phost->gState = HOST_ERROR_STATE;   
000004  250c              MOVS     r5,#0xc
000006  2905              CMP      r1,#5                 ;458
000008  d00a              BEQ      |L4.32|
00000a  2904              CMP      r1,#4                 ;459
00000c  d008              BEQ      |L4.32|
;;;463      }  
;;;464      /* USB host restart requested from application layer */
;;;465      else if(errType == USBH_APPLY_DEINIT)
00000e  2906              CMP      r1,#6
000010  d10b              BNE      |L4.42|
;;;466      {
;;;467        phost->gState = HOST_ERROR_STATE;  
000012  7025              STRB     r5,[r4,#0]
;;;468        /* user callback for initialization */
;;;469        phost->usr_cb->Init();
000014  f8d40090          LDR      r0,[r4,#0x90]
000018  6800              LDR      r0,[r0,#0]
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  4700              BX       r0
                  |L4.32|
000020  f8d40090          LDR      r0,[r4,#0x90]         ;461
000024  6c40              LDR      r0,[r0,#0x44]         ;461
000026  4780              BLX      r0                    ;461
000028  7025              STRB     r5,[r4,#0]            ;462
                  |L4.42|
;;;470      } 
;;;471    }
00002a  bd70              POP      {r4-r6,pc}
;;;472    
                          ENDP


                          AREA ||i.USBH_HandleControl||, CODE, READONLY, ALIGN=2

                  USBH_HandleControl PROC
;;;674      */
;;;675    USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;676    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
;;;677      uint8_t direction;  
;;;678      static uint16_t timeout = 0;
;;;679      USBH_Status status = USBH_OK;
000008  2700              MOVS     r7,#0
;;;680      URB_STATE URB_Status = URB_IDLE;
;;;681      
;;;682      phost->Control.status = CTRL_START;
00000a  2000              MOVS     r0,#0
00000c  74a0              STRB     r0,[r4,#0x12]
;;;683    
;;;684      
;;;685      switch (phost->Control.state)
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  250b              MOVS     r5,#0xb
000012  2605              MOVS     r6,#5
000014  2101              MOVS     r1,#1
;;;686      {
;;;687      case CTRL_SETUP:
;;;688        /* send a SETUP packet */
;;;689        USBH_CtlSendSetup     (pdev, 
;;;690    	                   phost->Control.setup.d8 , 
;;;691    	                   phost->Control.hc_num_out);  
;;;692        phost->Control.state = CTRL_SETUP_WAIT;  
;;;693        break; 
;;;694        
;;;695      case CTRL_SETUP_WAIT:
;;;696        
;;;697        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
;;;698        /* case SETUP packet sent successfully */
;;;699        if(URB_Status == URB_DONE)
;;;700        { 
;;;701          direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
;;;702          
;;;703          /* check if there is a data stage */
;;;704          if (phost->Control.setup.b.wLength.w != 0 )
;;;705          {        
;;;706            timeout = DATA_STAGE_TIMEOUT;
000016  f8df91e8          LDR      r9,|L5.512|
00001a  f04f0b09          MOV      r11,#9                ;685
;;;707            if (direction == USB_D2H)
;;;708            {
;;;709              /* Data Direction is IN */
;;;710              phost->Control.state = CTRL_DATA_IN;
;;;711            }
;;;712            else
;;;713            {
;;;714              /* Data Direction is OUT */
;;;715              phost->Control.state = CTRL_DATA_OUT;
;;;716            } 
;;;717          }
;;;718          /* No DATA stage */
;;;719          else
;;;720          {
;;;721            timeout = NODATA_STAGE_TIMEOUT;
;;;722            
;;;723            /* If there is No Data Transfer Stage */
;;;724            if (direction == USB_D2H)
;;;725            {
;;;726              /* Data Direction is IN */
;;;727              phost->Control.state = CTRL_STATUS_OUT;
;;;728            }
;;;729            else
;;;730            {
;;;731              /* Data Direction is OUT */
;;;732              phost->Control.state = CTRL_STATUS_IN;
;;;733            } 
;;;734          }          
;;;735          /* Set the delay timer to enable timeout for data stage completion */
;;;736          phost->Control.timer = HCD_GetCurrentFrame(pdev);
;;;737        }
;;;738        else if(URB_Status == URB_ERROR)
;;;739        {
;;;740          phost->Control.state = CTRL_ERROR;     
;;;741          phost->Control.status = CTRL_XACTERR;
;;;742        }    
;;;743        break;
;;;744        
;;;745      case CTRL_DATA_IN:  
;;;746        /* Issue an IN token */ 
;;;747        USBH_CtlReceiveData(pdev,
;;;748                            phost->Control.buff, 
;;;749                            phost->Control.length,
;;;750                            phost->Control.hc_num_in);
;;;751     
;;;752        phost->Control.state = CTRL_DATA_IN_WAIT;
;;;753        break;    
;;;754        
;;;755      case CTRL_DATA_IN_WAIT:
;;;756        
;;;757        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
;;;758        
;;;759        /* check is DATA packet transferred successfully */
;;;760        if  (URB_Status == URB_DONE)
;;;761        { 
;;;762          phost->Control.state = CTRL_STATUS_OUT;
;;;763        }
;;;764       
;;;765        /* manage error cases*/
;;;766        if  (URB_Status == URB_STALL) 
;;;767        { 
;;;768          /* In stall case, return to previous machine state*/
;;;769          phost->gState =   phost->gStateBkp;
;;;770          phost->Control.state = CTRL_STALLED;  
00001e  f04f0a0c          MOV      r10,#0xc
000022  280c              CMP      r0,#0xc               ;685
000024  d20f              BCS      |L5.70|
000026  e8dff000          TBB      [pc,r0]               ;685
00002a  e806              DCB      0xe8,0x06
00002c  0f3a4361          DCB      0x0f,0x3a,0x43,0x61
000030  6f8891b4          DCB      0x6f,0x88,0x91,0xb4
000034  c6db              DCB      0xc6,0xdb
000036  7962              LDRB     r2,[r4,#5]            ;689
000038  f1040114          ADD      r1,r4,#0x14           ;689
00003c  4640              MOV      r0,r8                 ;689
00003e  f7fffffe          BL       USBH_CtlSendSetup
000042  2002              MOVS     r0,#2                 ;692
000044  7720              STRB     r0,[r4,#0x1c]         ;692
                  |L5.70|
000046  e0d8              B        |L5.506|
000048  7961              LDRB     r1,[r4,#5]            ;697
00004a  4640              MOV      r0,r8                 ;697
00004c  f7fffffe          BL       HCD_GetURB_State
000050  2801              CMP      r0,#1                 ;699
000052  d002              BEQ      |L5.90|
000054  2803              CMP      r0,#3                 ;738
000056  d01f              BEQ      |L5.152|
000058  e0cf              B        |L5.506|
                  |L5.90|
00005a  7d20              LDRB     r0,[r4,#0x14]         ;701
00005c  f0000080          AND      r0,r0,#0x80           ;701
000060  8b61              LDRH     r1,[r4,#0x1a]         ;704
000062  b151              CBZ      r1,|L5.122|
000064  f2413188          MOV      r1,#0x1388            ;706
000068  f8a91000          STRH     r1,[r9,#0]            ;706
00006c  2880              CMP      r0,#0x80              ;707
00006e  d001              BEQ      |L5.116|
000070  7726              STRB     r6,[r4,#0x1c]         ;715
000072  e009              B        |L5.136|
                  |L5.116|
000074  2003              MOVS     r0,#3                 ;710
000076  7720              STRB     r0,[r4,#0x1c]         ;710
000078  e006              B        |L5.136|
                  |L5.122|
00007a  2132              MOVS     r1,#0x32              ;721
00007c  f8a91000          STRH     r1,[r9,#0]            ;721
000080  2880              CMP      r0,#0x80              ;724
000082  d006              BEQ      |L5.146|
000084  2007              MOVS     r0,#7                 ;732
000086  7720              STRB     r0,[r4,#0x1c]         ;732
                  |L5.136|
000088  4640              MOV      r0,r8                 ;736
00008a  f7fffffe          BL       HCD_GetCurrentFrame
00008e  8220              STRH     r0,[r4,#0x10]         ;736
000090  e0b3              B        |L5.506|
                  |L5.146|
000092  f884b01c          STRB     r11,[r4,#0x1c]        ;727
000096  e7f7              B        |L5.136|
                  |L5.152|
000098  7725              STRB     r5,[r4,#0x1c]         ;740
00009a  74a6              STRB     r6,[r4,#0x12]         ;741
00009c  e0ad              B        |L5.506|
00009e  7923              LDRB     r3,[r4,#4]            ;747
0000a0  89a2              LDRH     r2,[r4,#0xc]          ;747
0000a2  4640              MOV      r0,r8                 ;747
0000a4  68a1              LDR      r1,[r4,#8]            ;747
0000a6  f7fffffe          BL       USBH_CtlReceiveData
0000aa  2004              MOVS     r0,#4                 ;752
0000ac  7720              STRB     r0,[r4,#0x1c]         ;752
0000ae  e0a4              B        |L5.506|
0000b0  7921              LDRB     r1,[r4,#4]            ;757
0000b2  4640              MOV      r0,r8                 ;757
0000b4  f7fffffe          BL       HCD_GetURB_State
0000b8  2801              CMP      r0,#1                 ;760
0000ba  d101              BNE      |L5.192|
0000bc  f884b01c          STRB     r11,[r4,#0x1c]        ;762
                  |L5.192|
0000c0  2804              CMP      r0,#4                 ;766
0000c2  d00c              BEQ      |L5.222|
;;;771        }   
;;;772        else if (URB_Status == URB_ERROR)
0000c4  2803              CMP      r0,#3
0000c6  d00f              BEQ      |L5.232|
;;;773        {
;;;774          /* Device error */
;;;775          phost->Control.state = CTRL_ERROR;    
;;;776        }
;;;777        else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
0000c8  4640              MOV      r0,r8
0000ca  f7fffffe          BL       HCD_GetCurrentFrame
0000ce  8a21              LDRH     r1,[r4,#0x10]
0000d0  1a40              SUBS     r0,r0,r1
0000d2  f8b91000          LDRH     r1,[r9,#0]  ; timeout
0000d6  4288              CMP      r0,r1
0000d8  d900              BLS      |L5.220|
;;;778        {
;;;779          /* timeout for IN transfer */
;;;780          phost->Control.state = CTRL_ERROR; 
0000da  7725              STRB     r5,[r4,#0x1c]
                  |L5.220|
0000dc  e08d              B        |L5.506|
                  |L5.222|
0000de  7860              LDRB     r0,[r4,#1]            ;769
0000e0  7020              STRB     r0,[r4,#0]            ;769
0000e2  f884a01c          STRB     r10,[r4,#0x1c]        ;770
0000e6  e088              B        |L5.506|
                  |L5.232|
0000e8  7725              STRB     r5,[r4,#0x1c]         ;775
0000ea  e086              B        |L5.506|
;;;781        }   
;;;782        break;
;;;783        
;;;784      case CTRL_DATA_OUT:
;;;785        /* Start DATA out transfer (only one DATA packet)*/
;;;786        pdev->host.hc[phost->Control.hc_num_out].toggle_out = 1; 
0000ec  7960              LDRB     r0,[r4,#5]
0000ee  eb081040          ADD      r0,r8,r0,LSL #5
0000f2  f88018ad          STRB     r1,[r0,#0x8ad]
;;;787            
;;;788        USBH_CtlSendData (pdev,
0000f6  7963              LDRB     r3,[r4,#5]
0000f8  89a2              LDRH     r2,[r4,#0xc]
0000fa  4640              MOV      r0,r8
0000fc  68a1              LDR      r1,[r4,#8]
0000fe  f7fffffe          BL       USBH_CtlSendData
;;;789                          phost->Control.buff, 
;;;790                          phost->Control.length , 
;;;791                          phost->Control.hc_num_out);
;;;792        
;;;793        phost->Control.state = CTRL_DATA_OUT_WAIT;
000102  2006              MOVS     r0,#6
000104  7720              STRB     r0,[r4,#0x1c]
;;;794        break;
000106  e078              B        |L5.506|
;;;795        
;;;796      case CTRL_DATA_OUT_WAIT:
;;;797        
;;;798        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
000108  7961              LDRB     r1,[r4,#5]
00010a  4640              MOV      r0,r8
00010c  f7fffffe          BL       HCD_GetURB_State
;;;799        if  (URB_Status == URB_DONE)
000110  2801              CMP      r0,#1
000112  d006              BEQ      |L5.290|
;;;800        { /* If the Setup Pkt is sent successful, then change the state */
;;;801          phost->Control.state = CTRL_STATUS_IN;
;;;802        }
;;;803        
;;;804        /* handle error cases */
;;;805        else if  (URB_Status == URB_STALL) 
000114  2804              CMP      r0,#4
000116  d007              BEQ      |L5.296|
;;;806        { 
;;;807          /* In stall case, return to previous machine state*/
;;;808          phost->gState =   phost->gStateBkp;
;;;809          phost->Control.state = CTRL_STALLED;  
;;;810        } 
;;;811        else if  (URB_Status == URB_NOTREADY)
000118  2802              CMP      r0,#2
00011a  d00a              BEQ      |L5.306|
;;;812        { 
;;;813          /* Nack received from device */
;;;814          phost->Control.state = CTRL_DATA_OUT;
;;;815        }    
;;;816        else if (URB_Status == URB_ERROR)
00011c  2803              CMP      r0,#3
00011e  d00a              BEQ      |L5.310|
000120  e06b              B        |L5.506|
                  |L5.290|
000122  2007              MOVS     r0,#7                 ;801
000124  7720              STRB     r0,[r4,#0x1c]         ;801
000126  e068              B        |L5.506|
                  |L5.296|
000128  7860              LDRB     r0,[r4,#1]            ;808
00012a  7020              STRB     r0,[r4,#0]            ;808
00012c  f884a01c          STRB     r10,[r4,#0x1c]        ;809
000130  e063              B        |L5.506|
                  |L5.306|
000132  7726              STRB     r6,[r4,#0x1c]         ;814
000134  e061              B        |L5.506|
                  |L5.310|
;;;817        {
;;;818          /* device error */
;;;819          phost->Control.state = CTRL_ERROR;      
000136  7725              STRB     r5,[r4,#0x1c]
000138  e05f              B        |L5.506|
;;;820        } 
;;;821        break;
;;;822        
;;;823        
;;;824      case CTRL_STATUS_IN:
;;;825        /* Send 0 bytes out packet */
;;;826        USBH_CtlReceiveData (pdev,
00013a  2200              MOVS     r2,#0
00013c  7923              LDRB     r3,[r4,#4]
00013e  4611              MOV      r1,r2
000140  4640              MOV      r0,r8
000142  f7fffffe          BL       USBH_CtlReceiveData
;;;827                             0,
;;;828                             0,
;;;829                             phost->Control.hc_num_in);
;;;830        
;;;831        phost->Control.state = CTRL_STATUS_IN_WAIT;
000146  2008              MOVS     r0,#8
000148  7720              STRB     r0,[r4,#0x1c]
;;;832        
;;;833        break;
00014a  e056              B        |L5.506|
;;;834        
;;;835      case CTRL_STATUS_IN_WAIT:
;;;836        
;;;837        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
00014c  7921              LDRB     r1,[r4,#4]
00014e  4640              MOV      r0,r8
000150  f7fffffe          BL       HCD_GetURB_State
000154  4606              MOV      r6,r0
;;;838        
;;;839        if  ( URB_Status == URB_DONE)
000156  2e01              CMP      r6,#1
000158  d00c              BEQ      |L5.372|
;;;840        { /* Control transfers completed, Exit the State Machine */
;;;841          phost->gState =   phost->gStateBkp;
;;;842          phost->Control.state = CTRL_COMPLETE;
;;;843        }
;;;844        
;;;845        else if (URB_Status == URB_ERROR)
00015a  2e03              CMP      r6,#3
00015c  d00f              BEQ      |L5.382|
;;;846        {
;;;847          phost->Control.state = CTRL_ERROR;  
;;;848        }
;;;849        
;;;850        else if((HCD_GetCurrentFrame(pdev)\
00015e  4640              MOV      r0,r8
000160  f7fffffe          BL       HCD_GetCurrentFrame
000164  8a21              LDRH     r1,[r4,#0x10]
000166  1a40              SUBS     r0,r0,r1
000168  f8b91000          LDRH     r1,[r9,#0]  ; timeout
00016c  4288              CMP      r0,r1
00016e  d908              BLS      |L5.386|
;;;851          - phost->Control.timer) > timeout)
;;;852        {
;;;853          phost->Control.state = CTRL_ERROR; 
000170  7725              STRB     r5,[r4,#0x1c]
000172  e042              B        |L5.506|
                  |L5.372|
000174  7860              LDRB     r0,[r4,#1]            ;841
000176  7020              STRB     r0,[r4,#0]            ;841
000178  200d              MOVS     r0,#0xd               ;842
00017a  7720              STRB     r0,[r4,#0x1c]         ;842
00017c  e03d              B        |L5.506|
                  |L5.382|
00017e  7725              STRB     r5,[r4,#0x1c]         ;847
000180  e03b              B        |L5.506|
                  |L5.386|
;;;854        }
;;;855         else if(URB_Status == URB_STALL)
000182  2e04              CMP      r6,#4
000184  d139              BNE      |L5.506|
;;;856        {
;;;857          /* Control transfers completed, Exit the State Machine */
;;;858          phost->gState =   phost->gStateBkp;
000186  7860              LDRB     r0,[r4,#1]
000188  7020              STRB     r0,[r4,#0]
;;;859          phost->Control.state = CTRL_STALLED;
00018a  f884a01c          STRB     r10,[r4,#0x1c]
;;;860          status = USBH_NOT_SUPPORTED;
00018e  2703              MOVS     r7,#3
000190  e033              B        |L5.506|
;;;861        }
;;;862        break;
;;;863        
;;;864      case CTRL_STATUS_OUT:
;;;865        pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
000192  7960              LDRB     r0,[r4,#5]
000194  eb081040          ADD      r0,r8,r0,LSL #5
000198  f89018ad          LDRB     r1,[r0,#0x8ad]
00019c  f0810101          EOR      r1,r1,#1
0001a0  f88018ad          STRB     r1,[r0,#0x8ad]
;;;866        USBH_CtlSendData (pdev,
0001a4  2200              MOVS     r2,#0
0001a6  7963              LDRB     r3,[r4,#5]
0001a8  4611              MOV      r1,r2
0001aa  4640              MOV      r0,r8
0001ac  f7fffffe          BL       USBH_CtlSendData
;;;867                          0,
;;;868                          0,
;;;869                          phost->Control.hc_num_out);
;;;870        
;;;871        phost->Control.state = CTRL_STATUS_OUT_WAIT;
0001b0  200a              MOVS     r0,#0xa
0001b2  7720              STRB     r0,[r4,#0x1c]
;;;872        break;
0001b4  e021              B        |L5.506|
;;;873        
;;;874      case CTRL_STATUS_OUT_WAIT: 
;;;875        
;;;876        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
0001b6  7961              LDRB     r1,[r4,#5]
0001b8  4640              MOV      r0,r8
0001ba  f7fffffe          BL       HCD_GetURB_State
;;;877        if  (URB_Status == URB_DONE)
0001be  2801              CMP      r0,#1
0001c0  d004              BEQ      |L5.460|
;;;878        { 
;;;879          phost->gState =   phost->gStateBkp; 
;;;880          phost->Control.state = CTRL_COMPLETE; 
;;;881        }
;;;882        else if  (URB_Status == URB_NOTREADY)
0001c2  2802              CMP      r0,#2
0001c4  d007              BEQ      |L5.470|
;;;883        { 
;;;884          phost->Control.state = CTRL_STATUS_OUT;
;;;885        }      
;;;886        else if (URB_Status == URB_ERROR)
0001c6  2803              CMP      r0,#3
0001c8  d008              BEQ      |L5.476|
0001ca  e016              B        |L5.506|
                  |L5.460|
0001cc  7860              LDRB     r0,[r4,#1]            ;879
0001ce  7020              STRB     r0,[r4,#0]            ;879
0001d0  200d              MOVS     r0,#0xd               ;880
0001d2  7720              STRB     r0,[r4,#0x1c]         ;880
0001d4  e011              B        |L5.506|
                  |L5.470|
0001d6  f884b01c          STRB     r11,[r4,#0x1c]        ;884
0001da  e00e              B        |L5.506|
                  |L5.476|
;;;887        {
;;;888          phost->Control.state = CTRL_ERROR;      
0001dc  7725              STRB     r5,[r4,#0x1c]
0001de  e00c              B        |L5.506|
;;;889        }
;;;890        break;
;;;891        
;;;892      case CTRL_ERROR:
;;;893        /* 
;;;894        After a halt condition is encountered or an error is detected by the 
;;;895        host, a control endpoint is allowed to recover by accepting the next Setup 
;;;896        PID; i.e., recovery actions via some other pipe are not required for control
;;;897        endpoints. For the Default Control Pipe, a device reset will ultimately be 
;;;898        required to clear the halt or error condition if the next Setup PID is not 
;;;899        accepted.
;;;900        */
;;;901        if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
0001e0  7ba0              LDRB     r0,[r4,#0xe]
0001e2  1c40              ADDS     r0,r0,#1
0001e4  b2c0              UXTB     r0,r0
0001e6  73a0              STRB     r0,[r4,#0xe]
0001e8  2802              CMP      r0,#2
0001ea  d801              BHI      |L5.496|
;;;902        {
;;;903          /* Do the transmission again, starting from SETUP Packet */
;;;904          phost->Control.state = CTRL_SETUP; 
0001ec  7721              STRB     r1,[r4,#0x1c]
0001ee  e004              B        |L5.506|
                  |L5.496|
;;;905        }
;;;906        else
;;;907        {
;;;908          phost->Control.status = CTRL_FAIL;
0001f0  2008              MOVS     r0,#8
0001f2  74a0              STRB     r0,[r4,#0x12]
;;;909          phost->gState =   phost->gStateBkp;
0001f4  7860              LDRB     r0,[r4,#1]
0001f6  7020              STRB     r0,[r4,#0]
;;;910          
;;;911          status = USBH_FAIL;
0001f8  2702              MOVS     r7,#2
                  |L5.506|
;;;912        }
;;;913        break;
;;;914        
;;;915      default:
;;;916        break;
;;;917      }
;;;918      return status;
0001fa  4638              MOV      r0,r7
;;;919    }
0001fc  e8bd9ff0          POP      {r4-r12,pc}
;;;920    
                          ENDP

                  |L5.512|
                          DCD      ||area_number.19||

                          AREA ||i.USBH_HandleEnum||, CODE, READONLY, ALIGN=2

                  USBH_HandleEnum PROC
;;;479      */
;;;480    static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;481    {
000004  b092              SUB      sp,sp,#0x48
000006  4607              MOV      r7,r0
000008  460c              MOV      r4,r1
;;;482      USBH_Status Status = USBH_BUSY;  
00000a  2601              MOVS     r6,#1
;;;483      uint8_t Local_Buffer[64];
;;;484      
;;;485      switch (phost->EnumState)
00000c  78a1              LDRB     r1,[r4,#2]
00000e  2500              MOVS     r5,#0
;;;486      {
;;;487      case ENUM_IDLE:  
;;;488        /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
;;;489        if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
;;;490        {
;;;491          phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
;;;492          
;;;493          phost->EnumState = ENUM_GET_FULL_DEV_DESC;
;;;494          
;;;495          /* modify control channels configuration for MaxPacket size */
;;;496          USBH_Modify_Channel (pdev,
;;;497                               phost->Control.hc_num_out,
;;;498                               0,
;;;499                               0,
;;;500                               0,
;;;501                               phost->Control.ep0size);
;;;502          
;;;503          USBH_Modify_Channel (pdev,
;;;504                               phost->Control.hc_num_in,
;;;505                               0,
;;;506                               0,
;;;507                               0,
;;;508                               phost->Control.ep0size);      
;;;509        }
;;;510        break;
;;;511        
;;;512      case ENUM_GET_FULL_DEV_DESC:  
;;;513        /* Get FULL Device Desc  */
;;;514        if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
;;;515          == USBH_OK)
;;;516        {
;;;517          /* user callback for device descriptor available */
;;;518          phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
;;;519          phost->EnumState = ENUM_SET_ADDR;
;;;520        }
;;;521        break;
;;;522       
;;;523      case ENUM_SET_ADDR: 
;;;524        /* set address */
;;;525        if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
;;;526        {
;;;527          USB_OTG_BSP_mDelay(2);
;;;528          phost->device_prop.address = USBH_DEVICE_ADDRESS;
;;;529          
;;;530          /* user callback for device address assigned */
;;;531          phost->usr_cb->DeviceAddressAssigned();
;;;532          phost->EnumState = ENUM_GET_CFG_DESC;
;;;533          
;;;534          /* modify control channels to update device address */
;;;535          USBH_Modify_Channel (pdev,
;;;536                               phost->Control.hc_num_in,
;;;537                               phost->device_prop.address,
;;;538                               0,
;;;539                               0,
;;;540                               0);
;;;541          
;;;542          USBH_Modify_Channel (pdev,
;;;543                               phost->Control.hc_num_out,
;;;544                               phost->device_prop.address,
;;;545                               0,
;;;546                               0,
;;;547                               0);         
;;;548        }
;;;549        break;
;;;550        
;;;551      case ENUM_GET_CFG_DESC:  
;;;552        /* get standard configuration descriptor */
;;;553        if ( USBH_Get_CfgDesc(pdev, 
;;;554                              phost,
;;;555                              USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
;;;556        {
;;;557          /* before getting full config descriptor, check if it does not exceed 
;;;558          buffer size allocated to config descriptor USBH_MAX_DATA_BUFFER
;;;559          in the usbh_conf.h*/
;;;560          if (phost->device_prop.Cfg_Desc.wTotalLength <= USBH_MAX_DATA_BUFFER)
;;;561          {
;;;562            phost->EnumState = ENUM_GET_FULL_CFG_DESC;
;;;563          }
;;;564        }
;;;565        break;
;;;566        
;;;567      case ENUM_GET_FULL_CFG_DESC:  
;;;568        /* get FULL config descriptor (config, interface, endpoints) */
;;;569        if (USBH_Get_CfgDesc(pdev, 
;;;570                             phost,
;;;571                             phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
;;;572        {
;;;573          /* User callback for configuration descriptors available */
;;;574          phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
;;;575                                                          phost->device_prop.Itf_Desc,
;;;576                                                          phost->device_prop.Ep_Desc[0]);
;;;577          
;;;578          phost->EnumState = ENUM_GET_MFC_STRING_DESC;
;;;579        }
;;;580        break;
;;;581        
;;;582      case ENUM_GET_MFC_STRING_DESC:  
;;;583        if (phost->device_prop.Dev_Desc.iManufacturer != 0)
;;;584        { /* Check that Manufacturer String is available */
;;;585          
;;;586          if ( USBH_Get_StringDesc(pdev,
000010  20ff              MOVS     r0,#0xff
000012  f04f0801          MOV      r8,#1                 ;482
000016  290a              CMP      r1,#0xa               ;485
000018  d223              BCS      |L6.98|
00001a  e8dff001          TBB      [pc,r1]               ;485
00001e  0523              DCB      0x05,0x23
000020  33576579          DCB      0x33,0x57,0x65,0x79
000024  92abc4ce          DCB      0x92,0xab,0xc4,0xce
000028  2208              MOVS     r2,#8                 ;489
00002a  4621              MOV      r1,r4                 ;489
00002c  4638              MOV      r0,r7                 ;489
00002e  f7fffffe          BL       USBH_Get_DevDesc
000032  2800              CMP      r0,#0                 ;489
000034  d115              BNE      |L6.98|
000036  f8940029          LDRB     r0,[r4,#0x29]         ;491
00003a  71a0              STRB     r0,[r4,#6]            ;491
00003c  f8848002          STRB     r8,[r4,#2]            ;493
000040  e9cd5000          STRD     r5,r0,[sp,#0]         ;496
000044  2300              MOVS     r3,#0                 ;496
000046  7961              LDRB     r1,[r4,#5]            ;496
000048  461a              MOV      r2,r3                 ;496
00004a  4638              MOV      r0,r7                 ;496
00004c  f7fffffe          BL       USBH_Modify_Channel
000050  79a0              LDRB     r0,[r4,#6]            ;503
000052  2300              MOVS     r3,#0                 ;503
000054  e9cd5000          STRD     r5,r0,[sp,#0]         ;503
000058  7921              LDRB     r1,[r4,#4]            ;503
00005a  461a              MOV      r2,r3                 ;503
00005c  4638              MOV      r0,r7                 ;503
00005e  f7fffffe          BL       USBH_Modify_Channel
                  |L6.98|
000062  e0ab              B        |L6.444|
000064  2212              MOVS     r2,#0x12              ;514
000066  4621              MOV      r1,r4                 ;514
000068  4638              MOV      r0,r7                 ;514
00006a  f7fffffe          BL       USBH_Get_DevDesc
00006e  2800              CMP      r0,#0                 ;514
000070  d1f7              BNE      |L6.98|
000072  f8d40090          LDR      r0,[r4,#0x90]         ;518
000076  69c1              LDR      r1,[r0,#0x1c]         ;518
000078  f1040022          ADD      r0,r4,#0x22           ;518
00007c  4788              BLX      r1                    ;518
00007e  2002              MOVS     r0,#2                 ;519
000080  70a0              STRB     r0,[r4,#2]            ;519
000082  e09b              B        |L6.444|
000084  2201              MOVS     r2,#1                 ;525
000086  4621              MOV      r1,r4                 ;525
000088  4638              MOV      r0,r7                 ;525
00008a  f7fffffe          BL       USBH_SetAddress
00008e  2800              CMP      r0,#0                 ;525
000090  d11b              BNE      |L6.202|
000092  2002              MOVS     r0,#2                 ;527
000094  f7fffffe          BL       USB_OTG_BSP_mDelay
000098  1ca4              ADDS     r4,r4,#2              ;528
00009a  f884801e          STRB     r8,[r4,#0x1e]         ;528
00009e  f8d4008e          LDR      r0,[r4,#0x8e]         ;531
0000a2  6a00              LDR      r0,[r0,#0x20]         ;531
0000a4  4780              BLX      r0                    ;531
0000a6  2003              MOVS     r0,#3                 ;532
0000a8  7020              STRB     r0,[r4,#0]            ;532
0000aa  9500              STR      r5,[sp,#0]            ;535
0000ac  9501              STR      r5,[sp,#4]            ;535
0000ae  7fa2              LDRB     r2,[r4,#0x1e]         ;535
0000b0  78a1              LDRB     r1,[r4,#2]            ;535
0000b2  2300              MOVS     r3,#0                 ;535
0000b4  4638              MOV      r0,r7                 ;535
0000b6  f7fffffe          BL       USBH_Modify_Channel
0000ba  9500              STR      r5,[sp,#0]            ;542
0000bc  9501              STR      r5,[sp,#4]            ;542
0000be  7fa2              LDRB     r2,[r4,#0x1e]         ;542
0000c0  78e1              LDRB     r1,[r4,#3]            ;542
0000c2  2300              MOVS     r3,#0                 ;542
0000c4  4638              MOV      r0,r7                 ;542
0000c6  f7fffffe          BL       USBH_Modify_Channel
                  |L6.202|
0000ca  e077              B        |L6.444|
0000cc  2209              MOVS     r2,#9                 ;553
0000ce  4621              MOV      r1,r4                 ;553
0000d0  4638              MOV      r0,r7                 ;553
0000d2  f7fffffe          BL       USBH_Get_CfgDesc
0000d6  2800              CMP      r0,#0                 ;553
0000d8  d170              BNE      |L6.444|
0000da  8ee0              LDRH     r0,[r4,#0x36]         ;560
0000dc  f5b06f80          CMP      r0,#0x400             ;560
0000e0  d86c              BHI      |L6.444|
0000e2  2004              MOVS     r0,#4                 ;562
0000e4  70a0              STRB     r0,[r4,#2]            ;562
0000e6  e069              B        |L6.444|
0000e8  8ee2              LDRH     r2,[r4,#0x36]         ;569
0000ea  4621              MOV      r1,r4                 ;569
0000ec  4638              MOV      r0,r7                 ;569
0000ee  f7fffffe          BL       USBH_Get_CfgDesc
0000f2  2800              CMP      r0,#0                 ;569
0000f4  d162              BNE      |L6.444|
0000f6  f8d40090          LDR      r0,[r4,#0x90]         ;574
0000fa  f1040250          ADD      r2,r4,#0x50           ;574
0000fe  f104013e          ADD      r1,r4,#0x3e           ;574
000102  6a43              LDR      r3,[r0,#0x24]         ;574
000104  f1040034          ADD      r0,r4,#0x34           ;574
000108  4798              BLX      r3                    ;574
00010a  2005              MOVS     r0,#5                 ;578
00010c  70a0              STRB     r0,[r4,#2]            ;578
00010e  e055              B        |L6.444|
000110  f8942030          LDRB     r2,[r4,#0x30]         ;583
000114  2506              MOVS     r5,#6                 ;485
000116  b16a              CBZ      r2,|L6.308|
000118  9000              STR      r0,[sp,#0]
00011a  ab02              ADD      r3,sp,#8
00011c  4621              MOV      r1,r4
00011e  4638              MOV      r0,r7
000120  f7fffffe          BL       USBH_Get_StringDesc
000124  bb28              CBNZ     r0,|L6.370|
;;;587                                   phost,
;;;588                                   phost->device_prop.Dev_Desc.iManufacturer, 
;;;589                                   Local_Buffer , 
;;;590                                   0xff) == USBH_OK)
;;;591          {
;;;592            /* User callback for Manufacturing string */
;;;593            phost->usr_cb->ManufacturerString(Local_Buffer);
000126  f8d40090          LDR      r0,[r4,#0x90]
00012a  6a81              LDR      r1,[r0,#0x28]
00012c  a802              ADD      r0,sp,#8
00012e  4788              BLX      r1
;;;594            phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000130  70a5              STRB     r5,[r4,#2]
000132  e043              B        |L6.444|
                  |L6.308|
;;;595          }
;;;596        }
;;;597        else
;;;598        {
;;;599          phost->usr_cb->ManufacturerString("N/A");      
000134  f8d40090          LDR      r0,[r4,#0x90]
000138  6a81              LDR      r1,[r0,#0x28]
00013a  a022              ADR      r0,|L6.452|
00013c  4788              BLX      r1
;;;600          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
00013e  70a5              STRB     r5,[r4,#2]
000140  e03c              B        |L6.444|
;;;601        }
;;;602        break;
;;;603        
;;;604      case ENUM_GET_PRODUCT_STRING_DESC:   
;;;605        if (phost->device_prop.Dev_Desc.iProduct != 0)
000142  f8942031          LDRB     r2,[r4,#0x31]
000146  2507              MOVS     r5,#7                 ;485
000148  b16a              CBZ      r2,|L6.358|
;;;606        { /* Check that Product string is available */
;;;607          if ( USBH_Get_StringDesc(pdev,
00014a  9000              STR      r0,[sp,#0]
00014c  ab02              ADD      r3,sp,#8
00014e  4621              MOV      r1,r4
000150  4638              MOV      r0,r7
000152  f7fffffe          BL       USBH_Get_StringDesc
000156  b960              CBNZ     r0,|L6.370|
;;;608                                   phost,
;;;609                                   phost->device_prop.Dev_Desc.iProduct, 
;;;610                                   Local_Buffer, 
;;;611                                   0xff) == USBH_OK)
;;;612          {
;;;613            /* User callback for Product string */
;;;614            phost->usr_cb->ProductString(Local_Buffer);
000158  f8d40090          LDR      r0,[r4,#0x90]
00015c  6ac1              LDR      r1,[r0,#0x2c]
00015e  a802              ADD      r0,sp,#8
000160  4788              BLX      r1
;;;615            phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000162  70a5              STRB     r5,[r4,#2]
000164  e02a              B        |L6.444|
                  |L6.358|
;;;616          }
;;;617        }
;;;618        else
;;;619        {
;;;620          phost->usr_cb->ProductString("N/A");
000166  f8d40090          LDR      r0,[r4,#0x90]
00016a  6ac1              LDR      r1,[r0,#0x2c]
00016c  a015              ADR      r0,|L6.452|
00016e  4788              BLX      r1
;;;621          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000170  70a5              STRB     r5,[r4,#2]
                  |L6.370|
000172  e023              B        |L6.444|
;;;622        } 
;;;623        break;
;;;624        
;;;625      case ENUM_GET_SERIALNUM_STRING_DESC:   
;;;626        if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
000174  f8942032          LDRB     r2,[r4,#0x32]
000178  2508              MOVS     r5,#8                 ;485
00017a  b16a              CBZ      r2,|L6.408|
;;;627        { /* Check that Serial number string is available */    
;;;628          if ( USBH_Get_StringDesc(pdev, 
00017c  9000              STR      r0,[sp,#0]
00017e  ab02              ADD      r3,sp,#8
000180  4621              MOV      r1,r4
000182  4638              MOV      r0,r7
000184  f7fffffe          BL       USBH_Get_StringDesc
000188  b9c0              CBNZ     r0,|L6.444|
;;;629                                   phost,
;;;630                                   phost->device_prop.Dev_Desc.iSerialNumber, 
;;;631                                   Local_Buffer, 
;;;632                                   0xff) == USBH_OK)
;;;633          {
;;;634            /* User callback for Serial number string */
;;;635            phost->usr_cb->SerialNumString(Local_Buffer);
00018a  f8d40090          LDR      r0,[r4,#0x90]
00018e  6b01              LDR      r1,[r0,#0x30]
000190  a802              ADD      r0,sp,#8
000192  4788              BLX      r1
;;;636            phost->EnumState = ENUM_SET_CONFIGURATION;
000194  70a5              STRB     r5,[r4,#2]
000196  e011              B        |L6.444|
                  |L6.408|
;;;637          }
;;;638        }
;;;639        else
;;;640        {
;;;641          phost->usr_cb->SerialNumString("N/A");      
000198  f8d40090          LDR      r0,[r4,#0x90]
00019c  6b01              LDR      r1,[r0,#0x30]
00019e  a009              ADR      r0,|L6.452|
0001a0  4788              BLX      r1
;;;642          phost->EnumState = ENUM_SET_CONFIGURATION;
0001a2  70a5              STRB     r5,[r4,#2]
0001a4  e00a              B        |L6.444|
;;;643        }  
;;;644        break;
;;;645          
;;;646      case ENUM_SET_CONFIGURATION:
;;;647        /* set configuration  (default config) */
;;;648        if (USBH_SetCfg(pdev, 
0001a6  f8942039          LDRB     r2,[r4,#0x39]
0001aa  4621              MOV      r1,r4
0001ac  4638              MOV      r0,r7
0001ae  f7fffffe          BL       USBH_SetCfg
0001b2  b918              CBNZ     r0,|L6.444|
;;;649                        phost,
;;;650                        phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
;;;651        {
;;;652          phost->EnumState = ENUM_DEV_CONFIGURED;
0001b4  2009              MOVS     r0,#9
0001b6  70a0              STRB     r0,[r4,#2]
0001b8  e000              B        |L6.444|
;;;653        }
;;;654        break;
;;;655    
;;;656        
;;;657      case ENUM_DEV_CONFIGURED:
;;;658        /* user callback for enumeration done */
;;;659        Status = USBH_OK;
0001ba  2600              MOVS     r6,#0
                  |L6.444|
;;;660        break;
;;;661        
;;;662      default:
;;;663        break;
;;;664      }  
;;;665      return Status;
;;;666    }
0001bc  b012              ADD      sp,sp,#0x48
0001be  4630              MOV      r0,r6                 ;665
0001c0  e8bd81f0          POP      {r4-r8,pc}
;;;667    
                          ENDP

                  |L6.452|
0001c4  4e2f4100          DCB      "N/A",0

                          AREA ||i.USBH_Init||, CODE, READONLY, ALIGN=1

                  USBH_Init PROC
;;;195      */
;;;196    void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;197                   USB_OTG_CORE_ID_TypeDef coreID,
;;;198                   USBH_HOST *phost,               
;;;199                   USBH_Class_cb_TypeDef *class_cb, 
;;;200                   USBH_Usr_cb_TypeDef *usr_cb)
;;;201    {
000004  4607              MOV      r7,r0
000006  9e06              LDR      r6,[sp,#0x18]
000008  4688              MOV      r8,r1
00000a  4614              MOV      r4,r2
00000c  461d              MOV      r5,r3
;;;202         
;;;203      /* Hardware Init */
;;;204      USB_OTG_BSP_Init(pdev);  
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       USB_OTG_BSP_Init
;;;205      
;;;206      /* configure GPIO pin used for switching VBUS power */
;;;207      USB_OTG_BSP_ConfigVBUS(0);  
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;208      
;;;209      
;;;210      /* Host de-initializations */
;;;211      USBH_DeInit(pdev, phost);
00001a  4621              MOV      r1,r4
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       USBH_DeInit
;;;212      
;;;213      /*Register class and user callbacks */
;;;214      phost->class_cb = class_cb;
000022  f8445f8c          STR      r5,[r4,#0x8c]!
;;;215      phost->usr_cb = usr_cb;  
000026  6066              STR      r6,[r4,#4]
;;;216        
;;;217      /* Start the USB OTG core */     
;;;218       HCD_Init(pdev , coreID);
000028  4641              MOV      r1,r8
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       HCD_Init
;;;219       
;;;220      /* Upon Init call usr call back */
;;;221      phost->usr_cb->Init();
000030  6860              LDR      r0,[r4,#4]
000032  6801              LDR      r1,[r0,#0]
000034  4788              BLX      r1
;;;222      
;;;223      /* Enable Interrupts */
;;;224      USB_OTG_BSP_EnableInterrupt(pdev);
000036  4638              MOV      r0,r7
000038  e8bd41f0          POP      {r4-r8,lr}
00003c  f7ffbffe          B.W      USB_OTG_BSP_EnableInterrupt
;;;225    }
;;;226    
                          ENDP


                          AREA ||i.USBH_PortDisabled||, CODE, READONLY, ALIGN=1

                  USBH_PortDisabled PROC
;;;150    */
;;;151    uint8_t USBH_PortDisabled (USB_OTG_CORE_HANDLE *pdev)
000000  2100              MOVS     r1,#0
;;;152    {
;;;153      pdev->host.PortEnabled = 0;
000002  f8c017f8          STR      r1,[r0,#0x7f8]
;;;154      return 0;
000006  2000              MOVS     r0,#0
;;;155    }
000008  4770              BX       lr
;;;156    
                          ENDP


                          AREA ||i.USBH_PortEnabled||, CODE, READONLY, ALIGN=1

                  USBH_PortEnabled PROC
;;;138    */
;;;139    uint8_t USBH_PortEnabled (USB_OTG_CORE_HANDLE *pdev)
000000  2101              MOVS     r1,#1
;;;140    {
;;;141      pdev->host.PortEnabled = 1;
000002  f8c017f8          STR      r1,[r0,#0x7f8]
;;;142      return 0;
000006  2000              MOVS     r0,#0
;;;143    }
000008  4770              BX       lr
;;;144    
                          ENDP


                          AREA ||i.USBH_Process||, CODE, READONLY, ALIGN=1

                  USBH_Process PROC
;;;258    */
;;;259    void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;260    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;261      volatile USBH_Status status = USBH_FAIL;
000008  f04f0802          MOV      r8,#2
00000c  f8cd8008          STR      r8,[sp,#8]
;;;262    
;;;263      /* check for Host port events */
;;;264      if (((HCD_IsDeviceConnected(pdev) == 0)|| (HCD_IsPortEnabled(pdev) == 0))&& (phost->gState != HOST_IDLE)) 
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       HCD_IsDeviceConnected
000016  b118              CBZ      r0,|L10.32|
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       HCD_IsPortEnabled
00001e  b928              CBNZ     r0,|L10.44|
                  |L10.32|
000020  7820              LDRB     r0,[r4,#0]
000022  b118              CBZ      r0,|L10.44|
;;;265      {
;;;266        if(phost->gState != HOST_DEV_DISCONNECTED) 
000024  2803              CMP      r0,#3
000026  d001              BEQ      |L10.44|
;;;267        {
;;;268          phost->gState = HOST_DEV_DISCONNECTED;
000028  2003              MOVS     r0,#3
00002a  7020              STRB     r0,[r4,#0]
                  |L10.44|
;;;269        }
;;;270      }
;;;271        
;;;272      switch (phost->gState)
00002c  7820              LDRB     r0,[r4,#0]
00002e  2700              MOVS     r7,#0
;;;273      {
;;;274      
;;;275      case HOST_IDLE :
;;;276        
;;;277        if (HCD_IsDeviceConnected(pdev))  
;;;278        {
;;;279          phost->gState = HOST_WAIT_PRT_ENABLED; 
;;;280          
;;;281          /*wait denounce delay */
;;;282          USB_OTG_BSP_mDelay(100);
;;;283          
;;;284          /* Apply a port RESET */
;;;285          HCD_ResetPort(pdev);
;;;286          
;;;287          /* User RESET callback*/
;;;288          phost->usr_cb->ResetDevice();
;;;289        }
;;;290        break;
;;;291        
;;;292      case HOST_WAIT_PRT_ENABLED:
;;;293        if (pdev->host.PortEnabled == 1)
;;;294        { 
;;;295          phost->gState = HOST_DEV_ATTACHED; 
;;;296          USB_OTG_BSP_mDelay(50);
;;;297        }
;;;298        break;
;;;299          
;;;300      case HOST_DEV_ATTACHED :
;;;301        
;;;302        phost->usr_cb->DeviceAttached();
;;;303        phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
;;;304        phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
;;;305      
;;;306        /* Reset USB Device */
;;;307        if ( HCD_ResetPort(pdev) == 0)
;;;308        {
;;;309          phost->usr_cb->ResetDevice();
;;;310         
;;;311          /* Host is Now ready to start the Enumeration */
;;;312          phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
;;;313          
;;;314          phost->gState = HOST_ENUMERATION;
;;;315          phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
;;;316          
;;;317          /* Open Control pipes */
;;;318          USBH_Open_Channel (pdev,
;;;319                             phost->Control.hc_num_in,
;;;320                             phost->device_prop.address,
;;;321                             phost->device_prop.speed,
;;;322                             EP_TYPE_CTRL,
;;;323                             phost->Control.ep0size); 
;;;324          
;;;325          /* Open Control pipes */
;;;326          USBH_Open_Channel (pdev,
;;;327                             phost->Control.hc_num_out,
;;;328                             phost->device_prop.address,
;;;329                             phost->device_prop.speed,
;;;330                             EP_TYPE_CTRL,
;;;331                             phost->Control.ep0size);          
;;;332        }
;;;333        break;
;;;334        
;;;335      case HOST_ENUMERATION:     
;;;336        /* Check for enumeration status */  
;;;337        if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
;;;338        { 
;;;339    
;;;340          /* The function shall return USBH_OK when full enumeration is complete */
;;;341          
;;;342          /* user callback for end of device basic enumeration */
;;;343          phost->usr_cb->EnumerationDone();
;;;344    		
;;;345    #if defined (USB_OTG_FS_LOW_PWR_MGMT_SUPPORT) || defined (USB_OTG_HS_LOW_PWR_MGMT_SUPPORT)
;;;346          phost->gState  = HOST_SUSPENDED;
;;;347    #else
;;;348          phost->gState  = HOST_USR_INPUT;
;;;349    #endif /* LOW_PWR_MGMT_SUPPORT*/
;;;350        }
;;;351        break;
;;;352        
;;;353      case HOST_USR_INPUT:    
;;;354        /*The function should return user response true to move to class state */
;;;355        if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
;;;356        {
;;;357          if((phost->class_cb->Init(pdev, phost))\
;;;358            == USBH_OK)
;;;359          {
;;;360            phost->gState  = HOST_CLASS_REQUEST;     
;;;361          }     
;;;362        }   
;;;363        break;
;;;364        
;;;365      case HOST_CLASS_REQUEST:  
;;;366        /* process class standard control requests state machine */ 
;;;367        status = phost->class_cb->Requests(pdev, phost);
;;;368        
;;;369         if(status == USBH_OK)
;;;370         {
;;;371           phost->gState  = HOST_CLASS;
;;;372         }  
;;;373         
;;;374         else
;;;375         {
;;;376           USBH_ErrorHandle(phost, status);
;;;377         }
;;;378     
;;;379        
;;;380        break;    
;;;381      case HOST_CLASS:   
;;;382        /* process class state machine */
;;;383        status = phost->class_cb->Machine(pdev, phost);
;;;384        USBH_ErrorHandle(phost, status);
;;;385        break;       
;;;386        
;;;387      case HOST_CTRL_XFER:
;;;388        /* process control transfer state machine */
;;;389        USBH_HandleControl(pdev, phost);    
;;;390        break;
;;;391    #if defined (USB_OTG_FS_LOW_PWR_MGMT_SUPPORT) || defined (USB_OTG_HS_LOW_PWR_MGMT_SUPPORT)
;;;392      case HOST_SUSPENDED:
;;;393        if (USBH_SetDeviceFeature(pdev, phost, FEATURE_SELECTOR_DEVICE, 0)==USBH_OK)
;;;394        {
;;;395          suspend_flag = 1;
;;;396          USB_OTG_BSP_Suspend(pdev);
;;;397          phost->usr_cb->UserInput();
;;;398          PWR_EnterSTOPMode(PWR_Regulator_LowPower, PWR_STOPEntry_WFI);
;;;399          /* After wakeup got to HOST_WAKEUP state */
;;;400          phost->gState  = HOST_WAKEUP;
;;;401        }
;;;402        break;
;;;403          
;;;404      case HOST_WAKEUP:
;;;405        /* issue  a ClearDeviceFeature request */
;;;406        if (USBH_ClearDeviceFeature(pdev, phost, FEATURE_SELECTOR_DEVICE, 0)==USBH_OK)
;;;407        {
;;;408          phost->gState  = HOST_USR_INPUT;
;;;409        }
;;;410        break;
;;;411    #endif /* USE_HOST_MODE */
;;;412      case HOST_ERROR_STATE:
;;;413        /* Re-Initialize Host for new Enumeration */
;;;414        USBH_DeInit(pdev, phost);
;;;415        phost->usr_cb->DeInit();
;;;416        phost->class_cb->DeInit(pdev, &phost->device_prop);
000030  f1040520          ADD      r5,r4,#0x20
000034  280d              CMP      r0,#0xd               ;272
000036  d25d              BCS      |L10.244|
000038  e8dff000          TBB      [pc,r0]               ;272
00003c  071b26b7          DCB      0x07,0x1b,0x26,0xb7
000040  5c5e7c91          DCB      0x5c,0x5e,0x7c,0x91
000044  a06b5c5c          DCB      0xa0,0x6b,0x5c,0x5c
000048  a700              DCB      0xa7,0x00
00004a  4630              MOV      r0,r6                 ;277
00004c  f7fffffe          BL       HCD_IsDeviceConnected
000050  2800              CMP      r0,#0                 ;277
000052  d04f              BEQ      |L10.244|
000054  2001              MOVS     r0,#1                 ;279
000056  7020              STRB     r0,[r4,#0]            ;279
000058  2064              MOVS     r0,#0x64              ;282
00005a  f7fffffe          BL       USB_OTG_BSP_mDelay
00005e  4630              MOV      r0,r6                 ;285
000060  f7fffffe          BL       HCD_ResetPort
000064  f8d40090          LDR      r0,[r4,#0x90]         ;288
000068  68c0              LDR      r0,[r0,#0xc]          ;288
00006a  b003              ADD      sp,sp,#0xc            ;288
00006c  e8bd43f0          POP      {r4-r9,lr}            ;288
000070  4700              BX       r0                    ;288
000072  f8d607f8          LDR      r0,[r6,#0x7f8]        ;293
000076  2801              CMP      r0,#1                 ;293
000078  d13c              BNE      |L10.244|
00007a  f8848000          STRB     r8,[r4,#0]            ;295
00007e  e8bd43fe          POP      {r1-r9,lr}            ;296
000082  2032              MOVS     r0,#0x32              ;296
000084  f7ffbffe          B.W      USB_OTG_BSP_mDelay
000088  f8d40090          LDR      r0,[r4,#0x90]         ;302
00008c  6880              LDR      r0,[r0,#8]            ;302
00008e  4780              BLX      r0                    ;302
000090  2100              MOVS     r1,#0                 ;303
000092  4630              MOV      r0,r6                 ;303
000094  f7fffffe          BL       USBH_Alloc_Channel
000098  7160              STRB     r0,[r4,#5]            ;303
00009a  2180              MOVS     r1,#0x80              ;304
00009c  4630              MOV      r0,r6                 ;304
00009e  f7fffffe          BL       USBH_Alloc_Channel
0000a2  7120              STRB     r0,[r4,#4]            ;304
0000a4  4630              MOV      r0,r6                 ;307
0000a6  f7fffffe          BL       HCD_ResetPort
0000aa  2800              CMP      r0,#0                 ;307
0000ac  d122              BNE      |L10.244|
0000ae  1ca4              ADDS     r4,r4,#2              ;309
0000b0  f8d4008e          LDR      r0,[r4,#0x8e]         ;309
0000b4  68c0              LDR      r0,[r0,#0xc]          ;309
0000b6  4780              BLX      r0                    ;309
0000b8  4630              MOV      r0,r6                 ;312
0000ba  f7fffffe          BL       HCD_GetCurrentSpeed
0000be  b2c0              UXTB     r0,r0                 ;312
0000c0  77e0              STRB     r0,[r4,#0x1f]         ;312
0000c2  2105              MOVS     r1,#5                 ;314
0000c4  f8041c02          STRB     r1,[r4,#-2]           ;314
0000c8  f8d4108e          LDR      r1,[r4,#0x8e]         ;315
0000cc  6989              LDR      r1,[r1,#0x18]         ;315
0000ce  4788              BLX      r1                    ;315
0000d0  7920              LDRB     r0,[r4,#4]            ;318
0000d2  e9cd7000          STRD     r7,r0,[sp,#0]         ;318
0000d6  7fe3              LDRB     r3,[r4,#0x1f]         ;318
0000d8  7fa2              LDRB     r2,[r4,#0x1e]         ;318
0000da  78a1              LDRB     r1,[r4,#2]            ;318
0000dc  4630              MOV      r0,r6                 ;318
0000de  f7fffffe          BL       USBH_Open_Channel
0000e2  7920              LDRB     r0,[r4,#4]            ;326
0000e4  e9cd7000          STRD     r7,r0,[sp,#0]         ;326
0000e8  7fe3              LDRB     r3,[r4,#0x1f]         ;326
0000ea  7fa2              LDRB     r2,[r4,#0x1e]         ;326
0000ec  78e1              LDRB     r1,[r4,#3]            ;326
0000ee  4630              MOV      r0,r6                 ;326
0000f0  f7fffffe          BL       USBH_Open_Channel
                  |L10.244|
;;;417        break;
;;;418        
;;;419      case HOST_DEV_DISCONNECTED :
;;;420        
;;;421        /* Manage User disconnect operations*/
;;;422        phost->usr_cb->DeviceDisconnected();
;;;423        
;;;424        /* Re-Initialize Host for new Enumeration */
;;;425        USBH_DeInit(pdev, phost);
;;;426        phost->usr_cb->DeInit();
;;;427        phost->class_cb->DeInit(pdev, &phost->device_prop); 
;;;428        USBH_DeAllocate_AllChannel(pdev);  
;;;429        phost->gState = HOST_IDLE;
;;;430       
;;;431        /* Re-Initialize Host for new Enumeration */
;;;432        HCD_Init(pdev, 
;;;433    #ifdef USE_USB_OTG_FS
;;;434                USB_OTG_FS_CORE_ID
;;;435    #else
;;;436                USB_OTG_HS_CORE_ID
;;;437    #endif
;;;438    );
;;;439        
;;;440        break;
;;;441        
;;;442      default :
;;;443        break;
;;;444      }
;;;445    
;;;446    }
0000f4  e8bd83fe          POP      {r1-r9,pc}
0000f8  4621              MOV      r1,r4                 ;337
0000fa  4630              MOV      r0,r6                 ;337
0000fc  f7fffffe          BL       USBH_HandleEnum
000100  2800              CMP      r0,#0                 ;337
000102  d1f7              BNE      |L10.244|
000104  f8d40090          LDR      r0,[r4,#0x90]         ;343
000108  6b40              LDR      r0,[r0,#0x34]         ;343
00010a  4780              BLX      r0                    ;343
00010c  2009              MOVS     r0,#9                 ;348
00010e  7020              STRB     r0,[r4,#0]            ;348
000110  e7f0              B        |L10.244|
000112  f8d40090          LDR      r0,[r4,#0x90]         ;355
000116  6b80              LDR      r0,[r0,#0x38]         ;355
000118  4780              BLX      r0                    ;355
00011a  2801              CMP      r0,#1                 ;355
00011c  d1ea              BNE      |L10.244|
00011e  f8d4008c          LDR      r0,[r4,#0x8c]         ;357
000122  4621              MOV      r1,r4                 ;357
000124  6802              LDR      r2,[r0,#0]            ;357
000126  4630              MOV      r0,r6                 ;357
000128  4790              BLX      r2                    ;357
00012a  2800              CMP      r0,#0                 ;357
00012c  d1e2              BNE      |L10.244|
00012e  2006              MOVS     r0,#6                 ;360
000130  7020              STRB     r0,[r4,#0]            ;360
000132  e7df              B        |L10.244|
000134  f8d4008c          LDR      r0,[r4,#0x8c]         ;367
000138  4621              MOV      r1,r4                 ;367
00013a  6882              LDR      r2,[r0,#8]            ;367
00013c  4630              MOV      r0,r6                 ;367
00013e  4790              BLX      r2                    ;367
000140  9002              STR      r0,[sp,#8]            ;367
000142  f89d0008          LDRB     r0,[sp,#8]            ;369
000146  b138              CBZ      r0,|L10.344|
000148  f89d1008          LDRB     r1,[sp,#8]            ;376
00014c  b003              ADD      sp,sp,#0xc            ;376
00014e  4620              MOV      r0,r4                 ;376
000150  e8bd43f0          POP      {r4-r9,lr}            ;376
000154  f7ffbffe          B.W      USBH_ErrorHandle
                  |L10.344|
000158  2007              MOVS     r0,#7                 ;371
00015a  7020              STRB     r0,[r4,#0]            ;371
00015c  e7ca              B        |L10.244|
00015e  f8d4008c          LDR      r0,[r4,#0x8c]         ;383
000162  4621              MOV      r1,r4                 ;383
000164  68c2              LDR      r2,[r0,#0xc]          ;383
000166  4630              MOV      r0,r6                 ;383
000168  4790              BLX      r2                    ;383
00016a  9002              STR      r0,[sp,#8]            ;383
00016c  f89d1008          LDRB     r1,[sp,#8]            ;384
000170  b003              ADD      sp,sp,#0xc            ;384
000172  4620              MOV      r0,r4                 ;384
000174  e8bd43f0          POP      {r4-r9,lr}            ;384
000178  f7ffbffe          B.W      USBH_ErrorHandle
00017c  b003              ADD      sp,sp,#0xc            ;389
00017e  4621              MOV      r1,r4                 ;389
000180  4630              MOV      r0,r6                 ;389
000182  e8bd43f0          POP      {r4-r9,lr}            ;389
000186  f7ffbffe          B.W      USBH_HandleControl
00018a  4621              MOV      r1,r4                 ;414
00018c  4630              MOV      r0,r6                 ;414
00018e  f7fffffe          BL       USBH_DeInit
000192  348c              ADDS     r4,r4,#0x8c           ;415
000194  6860              LDR      r0,[r4,#4]            ;415
000196  6840              LDR      r0,[r0,#4]            ;415
000198  4780              BLX      r0                    ;415
00019a  6820              LDR      r0,[r4,#0]            ;416
00019c  4629              MOV      r1,r5                 ;416
00019e  6842              LDR      r2,[r0,#4]            ;416
0001a0  b003              ADD      sp,sp,#0xc            ;416
0001a2  4630              MOV      r0,r6                 ;416
0001a4  e8bd43f0          POP      {r4-r9,lr}            ;416
0001a8  4710              BX       r2                    ;416
0001aa  f8d40090          LDR      r0,[r4,#0x90]         ;422
0001ae  6900              LDR      r0,[r0,#0x10]         ;422
0001b0  4780              BLX      r0                    ;422
0001b2  4621              MOV      r1,r4                 ;425
0001b4  4630              MOV      r0,r6                 ;425
0001b6  f7fffffe          BL       USBH_DeInit
0001ba  f8d40090          LDR      r0,[r4,#0x90]         ;426
0001be  6840              LDR      r0,[r0,#4]            ;426
0001c0  4780              BLX      r0                    ;426
0001c2  f8d4008c          LDR      r0,[r4,#0x8c]         ;427
0001c6  4629              MOV      r1,r5                 ;427
0001c8  6842              LDR      r2,[r0,#4]            ;427
0001ca  4630              MOV      r0,r6                 ;427
0001cc  4790              BLX      r2                    ;427
0001ce  4630              MOV      r0,r6                 ;428
0001d0  f7fffffe          BL       USBH_DeAllocate_AllChannel
0001d4  7027              STRB     r7,[r4,#0]            ;429
0001d6  b003              ADD      sp,sp,#0xc            ;432
0001d8  4630              MOV      r0,r6                 ;432
0001da  e8bd43f0          POP      {r4-r9,lr}            ;432
0001de  2100              MOVS     r1,#0                 ;432
0001e0  f7ffbffe          B.W      HCD_Init
;;;447    
                          ENDP


                          AREA ||i.USBH_SOF||, CODE, READONLY, ALIGN=1

                  USBH_SOF PROC
;;;183    
;;;184    uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev)
000000  2000              MOVS     r0,#0
;;;185    {
;;;186      /* This callback could be used to implement a scheduler process */
;;;187      return 0;  
;;;188    }
000002  4770              BX       lr
;;;189    /**
                          ENDP


                          AREA ||i.USB_OTG_BSP_Resume||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_Resume PROC
;;;926      */
;;;927    void USB_OTG_BSP_Resume(USB_OTG_CORE_HANDLE *pdev)                                                                 
000000  b570              PUSH     {r4-r6,lr}
;;;928    {
000002  4604              MOV      r4,r0
;;;929      USB_OTG_HPRT0_TypeDef    hprt0;
;;;930      USB_OTG_PCGCCTL_TypeDef  power;
;;;931      hprt0.d32  = 0;
;;;932      /*  switch-off the clocks */
;;;933      power.d32 = 0;
;;;934      power.b.stoppclk = 1;
;;;935      USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL,power.d32, 0 );  
000004  f8d4010c          LDR      r0,[r4,#0x10c]
000008  6801              LDR      r1,[r0,#0]
00000a  f0210101          BIC      r1,r1,#1
00000e  6001              STR      r1,[r0,#0]
;;;936      
;;;937      power.b.gatehclk = 1;
;;;938      USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL,power.d32, 0);
000010  f8d4010c          LDR      r0,[r4,#0x10c]
000014  6801              LDR      r1,[r0,#0]
000016  f0210103          BIC      r1,r1,#3
00001a  6001              STR      r1,[r0,#0]
;;;939      
;;;940      hprt0.d32  = 0;   
;;;941      hprt0.d32  = USB_OTG_ReadHPRT0(pdev);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       USB_OTG_ReadHPRT0
;;;942      hprt0.b.prtsusp = 0;
000022  f0200080          BIC      r0,r0,#0x80
;;;943      hprt0.b.prtres = 1;
000026  f0400540          ORR      r5,r0,#0x40
;;;944      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00002a  f8540fcc          LDR      r0,[r4,#0xcc]!
00002e  6005              STR      r5,[r0,#0]
;;;945      USB_OTG_BSP_mDelay (20);
000030  2014              MOVS     r0,#0x14
000032  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;946      hprt0.b.prtres = 0;
000036  f0250040          BIC      r0,r5,#0x40
;;;947      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32); 
00003a  6821              LDR      r1,[r4,#0]
00003c  6008              STR      r0,[r1,#0]
;;;948    }
00003e  bd70              POP      {r4-r6,pc}
;;;949    
                          ENDP


                          AREA ||i.USB_OTG_BSP_Suspend||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_Suspend PROC
;;;955      */
;;;956    void USB_OTG_BSP_Suspend(USB_OTG_CORE_HANDLE *pdev)
000000  b510              PUSH     {r4,lr}
;;;957    {
000002  4604              MOV      r4,r0
;;;958      USB_OTG_HPRT0_TypeDef    hprt0;
;;;959      USB_OTG_PCGCCTL_TypeDef  power;
;;;960      hprt0.d32  = 0;
;;;961      hprt0.d32  = USB_OTG_ReadHPRT0(pdev);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USB_OTG_ReadHPRT0
;;;962      hprt0.b.prtsusp = 1; 
00000a  f0400080          ORR      r0,r0,#0x80
;;;963      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00000e  f8541fcc          LDR      r1,[r4,#0xcc]!
000012  6008              STR      r0,[r1,#0]
;;;964      
;;;965      /*  switch-off the clocks */
;;;966      power.d32 = 0;
;;;967      power.b.stoppclk = 1;
;;;968      USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
000014  6c20              LDR      r0,[r4,#0x40]
000016  6801              LDR      r1,[r0,#0]
000018  f0410101          ORR      r1,r1,#1
00001c  6001              STR      r1,[r0,#0]
;;;969      
;;;970      power.b.gatehclk = 1;
;;;971      USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
00001e  6c20              LDR      r0,[r4,#0x40]
000020  6801              LDR      r1,[r0,#0]
000022  f0410103          ORR      r1,r1,#3
000026  6001              STR      r1,[r0,#0]
;;;972    }
000028  bd10              POP      {r4,pc}
;;;973    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  USBH_HCD_INT_cb
                          DCD      USBH_SOF
                          DCD      USBH_Connected
                          DCD      USBH_Disconnected
                          DCD      USBH_PortEnabled
                          DCD      USBH_PortDisabled

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  USBH_HCD_INT_fops
                          DCD      USBH_HCD_INT_cb

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  suspend_flag
                          DCD      0x00000000

                          AREA ||area_number.19||, DATA, ALIGN=1

                          EXPORTAS ||area_number.19||, ||.data||
                  timeout
000000  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32_USB_HOST_Library\\Core\\src\\usbh_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_usbh_core_c_2210222f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REVSH|
#line 144
|__asm___11_usbh_core_c_2210222f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
