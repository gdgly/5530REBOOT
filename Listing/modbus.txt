; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\modbus.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\modbus.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\Libraries\STM32_USB_OTG_Driver\inc -I..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\User\usbh_mass_storage -I..\User\fatfs\src -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY -DSTM32F40XX --omf_browse=..\output\modbus.crf --no_multibyte_chars ..\drive\modbus.c]
                          THUMB

                          AREA ||i.Hardware_CRC||, CODE, READONLY, ALIGN=1

                  Hardware_CRC PROC
;;;298    //-----------------------------CRC检测--------------------------------------------//
;;;299    vu16 Hardware_CRC(vu8 *p_buffer,vu8 count)    //CRC16
000000  b503              PUSH     {r0,r1,lr}
;;;300    {
000002  b082              SUB      sp,sp,#8
;;;301    	vu16 CRC_Result=0xffff;
000004  f64f71ff          MOV      r1,#0xffff
000008  9101              STR      r1,[sp,#4]
;;;302    	vu8 i;
;;;303    	if(count==0)
00000a  f89d100c          LDRB     r1,[sp,#0xc]
00000e  2900              CMP      r1,#0
000010  d126              BNE      |L1.96|
;;;304    	{
;;;305    		count=1;
000012  2101              MOVS     r1,#1
000014  9103              STR      r1,[sp,#0xc]
000016  e023              B        |L1.96|
                  |L1.24|
;;;306    	}
;;;307    	while(count--)
;;;308    	{
;;;309    		CRC_Result^=*p_buffer;
000018  7801              LDRB     r1,[r0,#0]
00001a  f8bd2004          LDRH     r2,[sp,#4]
00001e  4051              EORS     r1,r1,r2
000020  9101              STR      r1,[sp,#4]
;;;310    		for(i=0;i<8;i++)
000022  2100              MOVS     r1,#0
000024  9100              STR      r1,[sp,#0]
;;;311    		{
;;;312    			if(CRC_Result&1)
;;;313    			{
;;;314    				CRC_Result>>=1;
;;;315    				CRC_Result^=0xA001;
000026  f24a0201          MOV      r2,#0xa001
00002a  e014              B        |L1.86|
                  |L1.44|
00002c  f8bd1004          LDRH     r1,[sp,#4]            ;312
000030  07c9              LSLS     r1,r1,#31             ;312
000032  d008              BEQ      |L1.70|
000034  f8bd1004          LDRH     r1,[sp,#4]            ;314
000038  0849              LSRS     r1,r1,#1              ;314
00003a  9101              STR      r1,[sp,#4]            ;314
00003c  f8bd1004          LDRH     r1,[sp,#4]
000040  4051              EORS     r1,r1,r2
000042  9101              STR      r1,[sp,#4]
000044  e003              B        |L1.78|
                  |L1.70|
;;;316    			}
;;;317    			else 
;;;318    			{
;;;319    				CRC_Result>>=1;
000046  f8bd1004          LDRH     r1,[sp,#4]
00004a  0849              LSRS     r1,r1,#1
00004c  9101              STR      r1,[sp,#4]
                  |L1.78|
00004e  f89d1000          LDRB     r1,[sp,#0]            ;310
000052  1c49              ADDS     r1,r1,#1              ;310
000054  9100              STR      r1,[sp,#0]            ;310
                  |L1.86|
000056  f89d1000          LDRB     r1,[sp,#0]            ;310
00005a  2908              CMP      r1,#8                 ;310
00005c  d3e6              BCC      |L1.44|
;;;320    			}
;;;321    		}
;;;322    		p_buffer++;
00005e  1c40              ADDS     r0,r0,#1
                  |L1.96|
000060  f89d100c          LDRB     r1,[sp,#0xc]          ;307
000064  1e4a              SUBS     r2,r1,#1              ;307
000066  9203              STR      r2,[sp,#0xc]          ;307
000068  d2d6              BCS      |L1.24|
;;;323    	}
;;;324    	return CRC_Result;
00006a  f8bd0004          LDRH     r0,[sp,#4]
;;;325    }
00006e  b004              ADD      sp,sp,#0x10
000070  bd00              POP      {pc}
                          ENDP


                          AREA ||i.Transformation_ADC||, CODE, READONLY, ALIGN=2

                  Transformation_ADC PROC
;;;142    //===============================AD值转换成测量值============================================//
;;;143    void Transformation_ADC(void)  
000000  b538              PUSH     {r3-r5,lr}
;;;144    {
;;;145    	vu32 var32;
;;;146    	vu32 var32a;
;;;147    /*****************************测量电压转换*******************************************/
;;;148    	var32 = Vmon_value;
000002  48a5              LDR      r0,|L2.664|
000004  8800              LDRH     r0,[r0,#0]  ; Vmon_value
000006  9000              STR      r0,[sp,#0]
;;;149    	var32 = var32 * REG_CorrectionV;  
000008  4ba4              LDR      r3,|L2.668|
00000a  8818              LDRH     r0,[r3,#0]  ; Correct_Parametet
00000c  9900              LDR      r1,[sp,#0]
00000e  4348              MULS     r0,r1,r0
000010  9000              STR      r0,[sp,#0]
;;;150    	if ((Polar & 0x01) == 0x01)		  
000012  8918              LDRH     r0,[r3,#8]  ; Correct_Parametet
;;;151    	{
;;;152    		if (var32 < REG_ReadV_Offset) 
000014  f04f0100          MOV      r1,#0
000018  07c2              LSLS     r2,r0,#31             ;150
00001a  f103001c          ADD      r0,r3,#0x1c
00001e  d00a              BEQ      |L2.54|
000020  6802              LDR      r2,[r0,#0]  ; Correct_Strong
000022  9c00              LDR      r4,[sp,#0]
000024  42a2              CMP      r2,r4
000026  d901              BLS      |L2.44|
;;;153    		{
;;;154    			var32 = 0;
000028  9100              STR      r1,[sp,#0]
00002a  e008              B        |L2.62|
                  |L2.44|
;;;155    		}
;;;156    		else var32 = var32 - REG_ReadV_Offset;
00002c  6802              LDR      r2,[r0,#0]  ; Correct_Strong
00002e  9c00              LDR      r4,[sp,#0]
000030  1aa2              SUBS     r2,r4,r2
000032  9200              STR      r2,[sp,#0]
000034  e003              B        |L2.62|
                  |L2.54|
;;;157    	}
;;;158    	else var32 = var32 + REG_ReadV_Offset;
000036  6802              LDR      r2,[r0,#0]  ; Correct_Strong
000038  9c00              LDR      r4,[sp,#0]
00003a  4422              ADD      r2,r2,r4
00003c  9200              STR      r2,[sp,#0]
                  |L2.62|
;;;159    	var32 = var32 >> 12;
00003e  9a00              LDR      r2,[sp,#0]
000040  0b12              LSRS     r2,r2,#12
000042  9200              STR      r2,[sp,#0]
;;;160    	if (var32 < 5) var32 = 0;				  //40mV以下清零
000044  9a00              LDR      r2,[sp,#0]
000046  2a05              CMP      r2,#5
000048  d200              BCS      |L2.76|
00004a  9100              STR      r1,[sp,#0]
                  |L2.76|
;;;161    	Voltage = var32;
00004c  4a93              LDR      r2,|L2.668|
00004e  9c00              LDR      r4,[sp,#0]
000050  3240              ADDS     r2,r2,#0x40
000052  8294              STRH     r4,[r2,#0x14]
;;;162    	DISS_Voltage=Voltage;
000054  8a94              LDRH     r4,[r2,#0x14]  ; Run_Control
000056  ee004a10          VMOV     s0,r4
00005a  4c91              LDR      r4,|L2.672|
00005c  eeb80a40          VCVT.F32.U32 s0,s0
;;;163    	DISS_Voltage=DISS_Voltage/100;//计算显示电压
000060  eddf0a90          VLDR     s1,|L2.676|
000064  ee801a20          VDIV.F32 s2,s0,s1
000068  ed841a00          VSTR     s2,[r4,#0]
;;;164    	var32 = 0;
;;;165    /*****************************稳压电源测量电压转换*******************************************/
;;;166    	var32 = Vmon1_value;
00006c  4c8e              LDR      r4,|L2.680|
00006e  8824              LDRH     r4,[r4,#0]  ; Vmon1_value
000070  9400              STR      r4,[sp,#0]
;;;167    	var32 = var32 * REG_CorrectionV1;  
000072  8b1c              LDRH     r4,[r3,#0x18]  ; Correct_Parametet
000074  9d00              LDR      r5,[sp,#0]
000076  436c              MULS     r4,r5,r4
000078  9400              STR      r4,[sp,#0]
;;;168    	if ((Polar3 & 0x01) == 0x01)		  
00007a  8adc              LDRH     r4,[r3,#0x16]  ; Correct_Parametet
00007c  07e4              LSLS     r4,r4,#31
00007e  d00a              BEQ      |L2.150|
;;;169    	{
;;;170    		if (var32 < REG_ReadV1_Offset) 
000080  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
000082  9d00              LDR      r5,[sp,#0]
000084  42ac              CMP      r4,r5
000086  d901              BLS      |L2.140|
;;;171    		{
;;;172    			var32 = 0;
000088  9100              STR      r1,[sp,#0]
00008a  e008              B        |L2.158|
                  |L2.140|
;;;173    		}
;;;174    		else var32 = var32 - REG_ReadV1_Offset;
00008c  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
00008e  9d00              LDR      r5,[sp,#0]
000090  1b2c              SUBS     r4,r5,r4
000092  9400              STR      r4,[sp,#0]
000094  e003              B        |L2.158|
                  |L2.150|
;;;175    	}
;;;176    	else var32 = var32 + REG_ReadV1_Offset;
000096  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
000098  9d00              LDR      r5,[sp,#0]
00009a  442c              ADD      r4,r4,r5
00009c  9400              STR      r4,[sp,#0]
                  |L2.158|
;;;177    	var32 = var32 >> 14;
00009e  9c00              LDR      r4,[sp,#0]
0000a0  0ba4              LSRS     r4,r4,#14
0000a2  9400              STR      r4,[sp,#0]
;;;178    	if (var32 < 5) var32 = 0;				  //40mV以下清零
0000a4  9c00              LDR      r4,[sp,#0]
0000a6  2c05              CMP      r4,#5
0000a8  d200              BCS      |L2.172|
0000aa  9100              STR      r1,[sp,#0]
                  |L2.172|
;;;179    	POW_Voltage = var32;
0000ac  9c00              LDR      r4,[sp,#0]
0000ae  8254              STRH     r4,[r2,#0x12]
;;;180    	DISS_POW_Voltage=POW_Voltage;
0000b0  8a54              LDRH     r4,[r2,#0x12]  ; Run_Control
0000b2  ee004a10          VMOV     s0,r4
0000b6  4c7d              LDR      r4,|L2.684|
0000b8  eeb80a40          VCVT.F32.U32 s0,s0
;;;181    	DISS_POW_Voltage=DISS_POW_Voltage/100;//计算显示电压
0000bc  ee801a20          VDIV.F32 s2,s0,s1
0000c0  ed841a00          VSTR     s2,[r4,#0]
;;;182    	var32 = 0;
;;;183    /*****************************内阻值转换*******************************************/
;;;184    	var32 = Rmon_value;
0000c4  4c7a              LDR      r4,|L2.688|
0000c6  8824              LDRH     r4,[r4,#0]  ; Rmon_value
0000c8  9400              STR      r4,[sp,#0]
;;;185    	var32 = var32 * REG_CorrectionR;  
0000ca  88dc              LDRH     r4,[r3,#6]  ; Correct_Parametet
0000cc  9d00              LDR      r5,[sp,#0]
0000ce  436c              MULS     r4,r5,r4
0000d0  9400              STR      r4,[sp,#0]
;;;186    	if ((Polar1 & 0x04) == 0x04)		  
0000d2  8a5c              LDRH     r4,[r3,#0x12]  ; Correct_Parametet
0000d4  0764              LSLS     r4,r4,#29
0000d6  d50a              BPL      |L2.238|
;;;187    	{
;;;188    		if (var32 < REG_ReadR_Offset) 
0000d8  68c4              LDR      r4,[r0,#0xc]  ; Correct_Strong
0000da  9d00              LDR      r5,[sp,#0]
0000dc  42ac              CMP      r4,r5
0000de  d901              BLS      |L2.228|
;;;189    		{
;;;190    			var32 = 0;
0000e0  9100              STR      r1,[sp,#0]
0000e2  e008              B        |L2.246|
                  |L2.228|
;;;191    		}
;;;192    		else var32 = var32 - REG_ReadR_Offset;
0000e4  68c5              LDR      r5,[r0,#0xc]  ; Correct_Strong
0000e6  9c00              LDR      r4,[sp,#0]
0000e8  1b64              SUBS     r4,r4,r5
0000ea  9400              STR      r4,[sp,#0]
0000ec  e003              B        |L2.246|
                  |L2.238|
;;;193    	}
;;;194    	else var32 = var32 + REG_ReadR_Offset;
0000ee  68c4              LDR      r4,[r0,#0xc]  ; Correct_Strong
0000f0  9d00              LDR      r5,[sp,#0]
0000f2  442c              ADD      r4,r4,r5
0000f4  9400              STR      r4,[sp,#0]
                  |L2.246|
;;;195    	var32 = var32 >> 12;
0000f6  9c00              LDR      r4,[sp,#0]
0000f8  0b24              LSRS     r4,r4,#12
0000fa  9400              STR      r4,[sp,#0]
;;;196    	if (var32 < 5) var32 = 0;				  //40mV以下清零
0000fc  9c00              LDR      r4,[sp,#0]
0000fe  2c05              CMP      r4,#5
000100  d200              BCS      |L2.260|
000102  9100              STR      r1,[sp,#0]
                  |L2.260|
;;;197    	R_VLUE = var32;
000104  9c00              LDR      r4,[sp,#0]
000106  8354              STRH     r4,[r2,#0x1a]
;;;198    	var32 = 0;	
;;;199    /*****************************稳压电源测量电流转换*******************************************/
;;;200    	var32 = Imon_value;
000108  4c6a              LDR      r4,|L2.692|
00010a  8824              LDRH     r4,[r4,#0]  ; Imon_value
00010c  9400              STR      r4,[sp,#0]
;;;201    	var32 = var32 * CON_CorrectionA;	   
00010e  8a1c              LDRH     r4,[r3,#0x10]  ; Correct_Parametet
000110  9d00              LDR      r5,[sp,#0]
000112  436c              MULS     r4,r5,r4
000114  9400              STR      r4,[sp,#0]
;;;202    	if ((Polar2 & 0x01) == 0x01)			   
000116  8a9c              LDRH     r4,[r3,#0x14]  ; Correct_Parametet
000118  07e4              LSLS     r4,r4,#31
00011a  d00a              BEQ      |L2.306|
;;;203    	{
;;;204    		if (var32 < CON_ReadA_Offset) var32 = 0;
00011c  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
00011e  9d00              LDR      r5,[sp,#0]
000120  42ac              CMP      r4,r5
000122  d901              BLS      |L2.296|
000124  9100              STR      r1,[sp,#0]
000126  e008              B        |L2.314|
                  |L2.296|
;;;205    		else var32 = var32 - CON_ReadA_Offset;
000128  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
00012a  9d00              LDR      r5,[sp,#0]
00012c  1b2c              SUBS     r4,r5,r4
00012e  9400              STR      r4,[sp,#0]
000130  e003              B        |L2.314|
                  |L2.306|
;;;206    	}
;;;207    	else
;;;208    	{
;;;209    		var32 = var32 + CON_ReadA_Offset;
000132  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
000134  9d00              LDR      r5,[sp,#0]
000136  442c              ADD      r4,r4,r5
000138  9400              STR      r4,[sp,#0]
                  |L2.314|
;;;210    	}	
;;;211    	var32 = var32 >> 12;
00013a  9c00              LDR      r4,[sp,#0]
00013c  0b24              LSRS     r4,r4,#12
00013e  9400              STR      r4,[sp,#0]
;;;212    	Current = var32;;
000140  9c00              LDR      r4,[sp,#0]
000142  82d4              STRH     r4,[r2,#0x16]
;;;213    	DISS_POW_Current=Current;
000144  8ad4              LDRH     r4,[r2,#0x16]  ; Run_Control
000146  ee004a10          VMOV     s0,r4
00014a  4c5b              LDR      r4,|L2.696|
00014c  eeb80a40          VCVT.F32.U32 s0,s0
;;;214    	DISS_POW_Current=DISS_POW_Current/1000;//计算显示电流
000150  ed9f1a5a          VLDR     s2,|L2.700|
000154  eec01a01          VDIV.F32 s3,s0,s2
000158  edc41a00          VSTR     s3,[r4,#0]
;;;215    /**************************稳压电源设置电压转换******************************************/
;;;216    	var32 = SET_Voltage;
00015c  8854              LDRH     r4,[r2,#2]  ; Run_Control
00015e  9400              STR      r4,[sp,#0]
;;;217    	var32=var32<<14;   
000160  9c00              LDR      r4,[sp,#0]
000162  03a4              LSLS     r4,r4,#14
000164  9400              STR      r4,[sp,#0]
;;;218    	if ((Polar1 & 0x01) == 0)			   
000166  8a5c              LDRH     r4,[r3,#0x12]  ; Correct_Parametet
000168  07e4              LSLS     r4,r4,#31
00016a  d011              BEQ      |L2.400|
;;;219    	{
;;;220    		if (var32 < SET_ReadV_Offset) var32 = 0;
;;;221    		else var32 = var32 - SET_ReadV_Offset;
;;;222    	}
;;;223    	else var32 = var32 + SET_ReadV_Offset;
00016c  6904              LDR      r4,[r0,#0x10]  ; Correct_Strong
00016e  9d00              LDR      r5,[sp,#0]
000170  442c              ADD      r4,r4,r5
000172  9400              STR      r4,[sp,#0]
                  |L2.372|
;;;224    	var32 = var32/SET_CorrectionV;
000174  895c              LDRH     r4,[r3,#0xa]  ; Correct_Parametet
000176  9d00              LDR      r5,[sp,#0]
000178  fbb5f4f4          UDIV     r4,r5,r4
00017c  9400              STR      r4,[sp,#0]
;;;225    	var32=var32>>1;
00017e  9c00              LDR      r4,[sp,#0]
000180  0864              LSRS     r4,r4,#1
000182  9400              STR      r4,[sp,#0]
;;;226    	Contr_Voltage = var32;
000184  4c4e              LDR      r4,|L2.704|
000186  9d00              LDR      r5,[sp,#0]
000188  8025              STRH     r5,[r4,#0]
;;;227    	if(SET_Voltage==0)
00018a  8855              LDRH     r5,[r2,#2]  ; Run_Control
00018c  b15d              CBZ      r5,|L2.422|
00018e  e00b              B        |L2.424|
                  |L2.400|
000190  6904              LDR      r4,[r0,#0x10]         ;220  ; Correct_Strong
000192  9d00              LDR      r5,[sp,#0]            ;220
000194  42ac              CMP      r4,r5                 ;220
000196  d901              BLS      |L2.412|
000198  9100              STR      r1,[sp,#0]            ;220
00019a  e7eb              B        |L2.372|
                  |L2.412|
00019c  6904              LDR      r4,[r0,#0x10]         ;221  ; Correct_Strong
00019e  9d00              LDR      r5,[sp,#0]            ;221
0001a0  1b2c              SUBS     r4,r5,r4              ;221
0001a2  9400              STR      r4,[sp,#0]            ;221
0001a4  e7e6              B        |L2.372|
                  |L2.422|
;;;228    	{
;;;229    		Contr_Voltage=0;
0001a6  8021              STRH     r1,[r4,#0]
                  |L2.424|
;;;230    	}
;;;231    	var32 = 0;
;;;232    /**************************稳压电源设置电流转换**************************************/
;;;233    	var32 = SET_Current;
0001a8  8894              LDRH     r4,[r2,#4]  ; Run_Control
0001aa  9400              STR      r4,[sp,#0]
;;;234    	var32=var32<<14;   
0001ac  9c00              LDR      r4,[sp,#0]
0001ae  03a4              LSLS     r4,r4,#14
0001b0  9400              STR      r4,[sp,#0]
;;;235    	if ((Polar1 & 0x08) == 0)			   
0001b2  8a5c              LDRH     r4,[r3,#0x12]  ; Correct_Parametet
0001b4  0724              LSLS     r4,r4,#28
0001b6  d40a              BMI      |L2.462|
;;;236    	{
;;;237    		if (var32 < SET_ReadA_Offset) var32 = 0;
0001b8  6944              LDR      r4,[r0,#0x14]  ; Correct_Strong
0001ba  9d00              LDR      r5,[sp,#0]
0001bc  42ac              CMP      r4,r5
0001be  d901              BLS      |L2.452|
0001c0  9100              STR      r1,[sp,#0]
0001c2  e008              B        |L2.470|
                  |L2.452|
;;;238    		else var32 = var32 - SET_ReadA_Offset;
0001c4  6944              LDR      r4,[r0,#0x14]  ; Correct_Strong
0001c6  9d00              LDR      r5,[sp,#0]
0001c8  1b2c              SUBS     r4,r5,r4
0001ca  9400              STR      r4,[sp,#0]
0001cc  e003              B        |L2.470|
                  |L2.462|
;;;239    	}
;;;240    	else var32 = var32 + SET_ReadA_Offset;
0001ce  6944              LDR      r4,[r0,#0x14]  ; Correct_Strong
0001d0  9d00              LDR      r5,[sp,#0]
0001d2  442c              ADD      r4,r4,r5
0001d4  9400              STR      r4,[sp,#0]
                  |L2.470|
;;;241    	var32 = var32/SET_CorrectionA;
0001d6  899c              LDRH     r4,[r3,#0xc]  ; Correct_Parametet
0001d8  9d00              LDR      r5,[sp,#0]
0001da  fbb5f4f4          UDIV     r4,r5,r4
0001de  9400              STR      r4,[sp,#0]
;;;242    	var32=var32>>1;
0001e0  9c00              LDR      r4,[sp,#0]
0001e2  0864              LSRS     r4,r4,#1
0001e4  9400              STR      r4,[sp,#0]
;;;243    	Contr_Current = var32;
0001e6  4c37              LDR      r4,|L2.708|
0001e8  9d00              LDR      r5,[sp,#0]
0001ea  8025              STRH     r5,[r4,#0]
;;;244    	if(SET_Current==0)
0001ec  8895              LDRH     r5,[r2,#4]  ; Run_Control
0001ee  b905              CBNZ     r5,|L2.498|
;;;245    	{
;;;246    		Contr_Current=0;
0001f0  8021              STRH     r1,[r4,#0]
                  |L2.498|
;;;247    	}
;;;248    	
;;;249    	var32 = 0;
;;;250    
;;;251    /*************************负载电流控制转换**************************************/
;;;252    	var32 = SET_Current_Laod;
0001f2  8914              LDRH     r4,[r2,#8]  ; Run_Control
0001f4  9400              STR      r4,[sp,#0]
;;;253    	var32=var32<<12;   
0001f6  9c00              LDR      r4,[sp,#0]
0001f8  0324              LSLS     r4,r4,#12
0001fa  9400              STR      r4,[sp,#0]
;;;254    	if ((Polar2 & 0x08) == 0)			   
0001fc  8a9c              LDRH     r4,[r3,#0x14]  ; Correct_Parametet
0001fe  0724              LSLS     r4,r4,#28
000200  d40a              BMI      |L2.536|
;;;255    	{
;;;256    		if (var32 < SET_ReadA1_Offset) var32 = 0;
000202  6984              LDR      r4,[r0,#0x18]  ; Correct_Strong
000204  9d00              LDR      r5,[sp,#0]
000206  42ac              CMP      r4,r5
000208  d901              BLS      |L2.526|
00020a  9100              STR      r1,[sp,#0]
00020c  e008              B        |L2.544|
                  |L2.526|
;;;257    		else var32 = var32 - SET_ReadA1_Offset;
00020e  6984              LDR      r4,[r0,#0x18]  ; Correct_Strong
000210  9d00              LDR      r5,[sp,#0]
000212  1b2c              SUBS     r4,r5,r4
000214  9400              STR      r4,[sp,#0]
000216  e003              B        |L2.544|
                  |L2.536|
;;;258    	}
;;;259    	else var32 = var32 + SET_ReadA1_Offset;
000218  6984              LDR      r4,[r0,#0x18]  ; Correct_Strong
00021a  9d00              LDR      r5,[sp,#0]
00021c  442c              ADD      r4,r4,r5
00021e  9400              STR      r4,[sp,#0]
                  |L2.544|
;;;260    	var32 = var32/SET_CorrectionA1;
000220  89dc              LDRH     r4,[r3,#0xe]  ; Correct_Parametet
000222  9d00              LDR      r5,[sp,#0]
000224  fbb5f4f4          UDIV     r4,r5,r4
000228  9400              STR      r4,[sp,#0]
;;;261    	var32=var32>>1;
00022a  9c00              LDR      r4,[sp,#0]
00022c  0864              LSRS     r4,r4,#1
00022e  9400              STR      r4,[sp,#0]
;;;262    	if(Flag_DAC_OFF==0)
000230  4c25              LDR      r4,|L2.712|
000232  7824              LDRB     r4,[r4,#0]  ; flagB
000234  0725              LSLS     r5,r4,#28
;;;263    	{
;;;264    		Contr_Laod = var32;
000236  4c25              LDR      r4,|L2.716|
000238  d401              BMI      |L2.574|
00023a  9d00              LDR      r5,[sp,#0]
00023c  8025              STRH     r5,[r4,#0]
                  |L2.574|
;;;265    	}
;;;266    	if(SET_Current_Laod==0)
00023e  8915              LDRH     r5,[r2,#8]  ; Run_Control
000240  b905              CBNZ     r5,|L2.580|
;;;267    	{
;;;268    		Contr_Laod=0;
000242  8021              STRH     r1,[r4,#0]
                  |L2.580|
;;;269    	}
;;;270    	
;;;271    	var32 = 0;
;;;272    /*******************负载测量电流转换**************************************/
;;;273    	var32 = Imon1_value;
000244  4c22              LDR      r4,|L2.720|
000246  8824              LDRH     r4,[r4,#0]  ; Imon1_value
000248  9400              STR      r4,[sp,#0]
;;;274    	var32 = var32 * REG_CorrectionA1;  
00024a  889c              LDRH     r4,[r3,#4]  ; Correct_Parametet
00024c  9d00              LDR      r5,[sp,#0]
00024e  436c              MULS     r4,r5,r4
000250  9400              STR      r4,[sp,#0]
;;;275    	if ((Polar2 & 0x04) == 0x04)		  
000252  8a9b              LDRH     r3,[r3,#0x14]  ; Correct_Parametet
000254  075b              LSLS     r3,r3,#29
000256  d50a              BPL      |L2.622|
;;;276    	{
;;;277    		if (var32 < REG_ReadA1_Offset) 
000258  6883              LDR      r3,[r0,#8]  ; Correct_Strong
00025a  9c00              LDR      r4,[sp,#0]
00025c  42a3              CMP      r3,r4
00025e  d901              BLS      |L2.612|
;;;278    		{
;;;279    			var32 = 0;
000260  9100              STR      r1,[sp,#0]
000262  e008              B        |L2.630|
                  |L2.612|
;;;280    		}
;;;281    		else var32 = var32 - REG_ReadA1_Offset;
000264  6880              LDR      r0,[r0,#8]  ; Correct_Strong
000266  9b00              LDR      r3,[sp,#0]
000268  1a18              SUBS     r0,r3,r0
00026a  9000              STR      r0,[sp,#0]
00026c  e003              B        |L2.630|
                  |L2.622|
;;;282    	}
;;;283    	else var32 = var32 + REG_ReadA1_Offset;
00026e  6880              LDR      r0,[r0,#8]  ; Correct_Strong
000270  9b00              LDR      r3,[sp,#0]
000272  4418              ADD      r0,r0,r3
000274  9000              STR      r0,[sp,#0]
                  |L2.630|
;;;284    	var32 = var32 >> 12;
000276  9800              LDR      r0,[sp,#0]
000278  0b00              LSRS     r0,r0,#12
00027a  9000              STR      r0,[sp,#0]
;;;285    	Laod_Current = var32;
00027c  9800              LDR      r0,[sp,#0]
00027e  8310              STRH     r0,[r2,#0x18]
;;;286    	DISS_Current=Laod_Current;
000280  8b10              LDRH     r0,[r2,#0x18]  ; Run_Control
000282  ee000a10          VMOV     s0,r0
000286  4813              LDR      r0,|L2.724|
000288  eeb80a40          VCVT.F32.U32 s0,s0
;;;287    	DISS_Current=DISS_Current/100;//计算显示电流
00028c  ee801a20          VDIV.F32 s2,s0,s1
000290  ed801a00          VSTR     s2,[r0,#0]
;;;288    	var32 = 0;		
000294  9100              STR      r1,[sp,#0]
;;;289    	
;;;290    }
000296  bd38              POP      {r3-r5,pc}
;;;291    /********************************************************************************
                          ENDP

                  |L2.664|
                          DCD      Vmon_value
                  |L2.668|
                          DCD      ||.bss||
                  |L2.672|
                          DCD      DISS_Voltage
                  |L2.676|
0002a4  42c80000          DCFS     0x42c80000 ; 100
                  |L2.680|
                          DCD      Vmon1_value
                  |L2.684|
                          DCD      DISS_POW_Voltage
                  |L2.688|
                          DCD      Rmon_value
                  |L2.692|
                          DCD      Imon_value
                  |L2.696|
                          DCD      DISS_POW_Current
                  |L2.700|
0002bc  447a0000          DCFS     0x447a0000 ; 1000
                  |L2.704|
                          DCD      Contr_Voltage
                  |L2.708|
                          DCD      Contr_Current
                  |L2.712|
                          DCD      flagB
                  |L2.716|
                          DCD      Contr_Laod
                  |L2.720|
                          DCD      Imon1_value
                  |L2.724|
                          DCD      DISS_Current

                          AREA ||i.UART_Action||, CODE, READONLY, ALIGN=2

                  UART_Action PROC
;;;43     //===========================MODBUS协议=============================//
;;;44     void UART_Action(void)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;45     {//RUT格式：
;;;46     	//ADDR  命令码  读寄存器的起始地址高   读寄存器的起始地址低  读数据字个数高字节   读数据个数低字节  CRC高 CRC低
;;;47     	//返回格式：ADDR 命令码 返回数据字节数  数据高  数据低 ..... CRC高  CRC低
;;;48     	if (UART_Buffer_Rece[0] == ADDR)
000004  4c91              LDR      r4,|L3.588|
000006  7820              LDRB     r0,[r4,#0]  ; UART_Buffer_Rece
000008  4d91              LDR      r5,|L3.592|
00000a  7829              LDRB     r1,[r5,#0]  ; ADDR
;;;49     	{
;;;50     		if (UART_Buffer_Rece[1] == (0x03))	//命令3 读数据   
;;;51     		{																		 
;;;52     			vu8 i;
;;;53     			vu16 crc_result;
;;;54     			crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;55     			if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )
;;;56     			{
;;;57     				if (UART_Buffer_Rece[3] < 0x07)    								//如果寄存器在可读范围内
;;;58     				{
;;;59     					if ((UART_Buffer_Rece[3] + UART_Buffer_Rece[5]) < 0x0F)		//如果最后一个读取的寄存器地址在可读范围内
;;;60     					{							
;;;61     						UART_Buffer_Send[0] = ADDR;
00000c  4b91              LDR      r3,|L3.596|
;;;62     						UART_Buffer_Send[1] = 0x03;
;;;63     						UART_Buffer_Send[2] = UART_Buffer_Rece[5]*2;
;;;64     						for (i=0;i<UART_Buffer_Send[2];i++)
;;;65     						{
;;;66     							if ((i % 2) == 0) UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2] >> 8;
;;;67     							else UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2];														
;;;68     						}
;;;69     						crc_result = Hardware_CRC(UART_Buffer_Send,UART_Buffer_Send[2] + 3);
;;;70     						UART_Buffer_Send[3 + UART_Buffer_Send[2]] = crc_result >> 8;
;;;71     						UART_Buffer_Send[4 + UART_Buffer_Send[2]] = crc_result;
;;;72     						Transmit_BUFFERsize = UART_Buffer_Send[2] + 5;
00000e  f8df9248          LDR      r9,|L3.600|
;;;73     						UART_SEND_flag=1;
000012  4e92              LDR      r6,|L3.604|
000014  4f92              LDR      r7,|L3.608|
000016  f04f0800          MOV      r8,#0                 ;48
00001a  4288              CMP      r0,r1                 ;48
00001c  d15a              BNE      |L3.212|
00001e  7860              LDRB     r0,[r4,#1]            ;50  ; UART_Buffer_Rece
000020  2803              CMP      r0,#3                 ;50
000022  d157              BNE      |L3.212|
000024  79e0              LDRB     r0,[r4,#7]            ;54  ; UART_Buffer_Rece
000026  79a1              LDRB     r1,[r4,#6]            ;54  ; UART_Buffer_Rece
000028  eb002001          ADD      r0,r0,r1,LSL #8       ;54
00002c  9002              STR      r0,[sp,#8]            ;54
00002e  2106              MOVS     r1,#6                 ;55
000030  4620              MOV      r0,r4                 ;55
000032  f7fffffe          BL       Hardware_CRC
000036  f8bd1008          LDRH     r1,[sp,#8]            ;55
00003a  4288              CMP      r0,r1                 ;55
00003c  d002              BEQ      |L3.68|
00003e  f8bd0008          LDRH     r0,[sp,#8]            ;55
000042  bbe8              CBNZ     r0,|L3.192|
                  |L3.68|
000044  78e0              LDRB     r0,[r4,#3]            ;57  ; UART_Buffer_Rece
000046  2807              CMP      r0,#7                 ;57
000048  d244              BCS      |L3.212|
00004a  78e0              LDRB     r0,[r4,#3]            ;59  ; UART_Buffer_Rece
00004c  7961              LDRB     r1,[r4,#5]            ;59  ; UART_Buffer_Rece
00004e  4408              ADD      r0,r0,r1              ;59
000050  280f              CMP      r0,#0xf               ;59
000052  d23f              BCS      |L3.212|
000054  7828              LDRB     r0,[r5,#0]            ;61  ; ADDR
000056  7018              STRB     r0,[r3,#0]            ;61
000058  2003              MOVS     r0,#3                 ;62
00005a  7058              STRB     r0,[r3,#1]            ;62
00005c  7960              LDRB     r0,[r4,#5]            ;63  ; UART_Buffer_Rece
00005e  0040              LSLS     r0,r0,#1              ;63
000060  7098              STRB     r0,[r3,#2]            ;63
000062  f8cd800c          STR      r8,[sp,#0xc]          ;64
000066  e012              B        |L3.142|
                  |L3.104|
000068  f89d000c          LDRB     r0,[sp,#0xc]          ;66
00006c  07c0              LSLS     r0,r0,#31             ;66
00006e  d04a              BEQ      |L3.262|
000070  78e0              LDRB     r0,[r4,#3]            ;67  ; UART_Buffer_Rece
000072  f89d100c          LDRB     r1,[sp,#0xc]          ;67
000076  eb000051          ADD      r0,r0,r1,LSR #1       ;67
00007a  f8370010          LDRH     r0,[r7,r0,LSL #1]     ;67
00007e  f89d100c          LDRB     r1,[sp,#0xc]          ;67
000082  4419              ADD      r1,r1,r3              ;67
000084  70c8              STRB     r0,[r1,#3]            ;67
                  |L3.134|
000086  f89d000c          LDRB     r0,[sp,#0xc]          ;64
00008a  1c40              ADDS     r0,r0,#1              ;64
00008c  9003              STR      r0,[sp,#0xc]          ;64
                  |L3.142|
00008e  7898              LDRB     r0,[r3,#2]            ;64  ; UART_Buffer_Send
000090  f89d100c          LDRB     r1,[sp,#0xc]          ;64
000094  4288              CMP      r0,r1                 ;64
000096  d8e7              BHI      |L3.104|
000098  7898              LDRB     r0,[r3,#2]            ;69  ; UART_Buffer_Send
00009a  1cc0              ADDS     r0,r0,#3              ;69
00009c  b2c1              UXTB     r1,r0                 ;69
00009e  486d              LDR      r0,|L3.596|
0000a0  f7fffffe          BL       Hardware_CRC
0000a4  9002              STR      r0,[sp,#8]            ;69
0000a6  f8bd0008          LDRH     r0,[sp,#8]            ;70
0000aa  789a              LDRB     r2,[r3,#2]            ;70  ; UART_Buffer_Send
0000ac  0a01              LSRS     r1,r0,#8              ;70
0000ae  4869              LDR      r0,|L3.596|
0000b0  1cc0              ADDS     r0,r0,#3              ;70
0000b2  5411              STRB     r1,[r2,r0]            ;70
0000b4  f8bd0008          LDRH     r0,[sp,#8]            ;71
0000b8  789a              LDRB     r2,[r3,#2]            ;71  ; UART_Buffer_Send
0000ba  4966              LDR      r1,|L3.596|
0000bc  1d09              ADDS     r1,r1,#4              ;71
0000be  e000              B        |L3.194|
                  |L3.192|
0000c0  e008              B        |L3.212|
                  |L3.194|
0000c2  5450              STRB     r0,[r2,r1]            ;71
0000c4  7898              LDRB     r0,[r3,#2]            ;72  ; UART_Buffer_Send
0000c6  1d40              ADDS     r0,r0,#5              ;72
0000c8  f8890000          STRB     r0,[r9,#0]            ;72
0000cc  6830              LDR      r0,[r6,#0]  ; flagA
0000ce  f0400010          ORR      r0,r0,#0x10
0000d2  6030              STR      r0,[r6,#0]  ; flagA
                  |L3.212|
;;;74     					}
;;;75     				}
;;;76     			}	
;;;77     		}
;;;78     	} 
;;;79     //===============================写寄存器=================================
;;;80     	if ((UART_Buffer_Rece[0] == 0) || (UART_Buffer_Rece[0] == ADDR) || (UART_Buffer_Rece[0] == ((ADDR-1)/4+100)))	 
0000d4  7820              LDRB     r0,[r4,#0]  ; UART_Buffer_Rece
0000d6  b170              CBZ      r0,|L3.246|
0000d8  7820              LDRB     r0,[r4,#0]  ; UART_Buffer_Rece
0000da  7829              LDRB     r1,[r5,#0]  ; ADDR
0000dc  4288              CMP      r0,r1
0000de  d00a              BEQ      |L3.246|
0000e0  7828              LDRB     r0,[r5,#0]  ; ADDR
0000e2  1e40              SUBS     r0,r0,#1
0000e4  17c1              ASRS     r1,r0,#31
0000e6  eb007091          ADD      r0,r0,r1,LSR #30
0000ea  2164              MOVS     r1,#0x64
0000ec  eb0100a0          ADD      r0,r1,r0,ASR #2
0000f0  7821              LDRB     r1,[r4,#0]  ; UART_Buffer_Rece
0000f2  4288              CMP      r0,r1
0000f4  d17d              BNE      |L3.498|
                  |L3.246|
;;;81     	{
;;;82     		vu8 var8;
;;;83     		vu8 a=0;
0000f6  f8cd8008          STR      r8,[sp,#8]
;;;84     		vu16 var16;
;;;85     		vu16 crc_result;
;;;86     //=========================以下命令6 写单个寄存器===========================
;;;87     		if (UART_Buffer_Rece[1] == 6)                                 //判断第二个字节是否为命令6
0000fa  7860              LDRB     r0,[r4,#1]  ; UART_Buffer_Rece
;;;88     		{
;;;89     			if (UART_Buffer_Rece[3] < 0x05)							  //判断需要写的地址是否在可写范围内
;;;90     			{
;;;91     				crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;92     				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )		  //检查CRC
;;;93     				{
;;;94     					var16 = (UART_Buffer_Rece[4] << 8) + UART_Buffer_Rece[5];	//第5 6个字节为要写入的数据
;;;95     					var8 = UART_Buffer_Rece[3];	        						//第3 4个字节为要写入的地址
;;;96     					Run_Control[var8] = var16;			    //将数据写入指定的地址
;;;97     
;;;98     					if (UART_Buffer_Rece[0] == ADDR)							//广播模式下不返回数据
;;;99     					{
;;;100    						for (a=0;a<8;a++)
;;;101    						{UART_Buffer_Send[a] = UART_Buffer_Rece[a];}
;;;102    						Transmit_BUFFERsize = 8;						//原样数据返回，不计算CRC
0000fc  f04f0a08          MOV      r10,#8
000100  2806              CMP      r0,#6                 ;87
000102  d00d              BEQ      |L3.288|
000104  e047              B        |L3.406|
                  |L3.262|
000106  78e0              LDRB     r0,[r4,#3]            ;66  ; UART_Buffer_Rece
000108  f89d100c          LDRB     r1,[sp,#0xc]          ;66
00010c  eb000051          ADD      r0,r0,r1,LSR #1       ;66
000110  f8370010          LDRH     r0,[r7,r0,LSL #1]     ;66
000114  f89d100c          LDRB     r1,[sp,#0xc]          ;66
000118  0a00              LSRS     r0,r0,#8              ;66
00011a  4419              ADD      r1,r1,r3              ;66
00011c  70c8              STRB     r0,[r1,#3]            ;66
00011e  e7b2              B        |L3.134|
                  |L3.288|
000120  78e0              LDRB     r0,[r4,#3]            ;89  ; UART_Buffer_Rece
000122  2805              CMP      r0,#5                 ;89
000124  d237              BCS      |L3.406|
000126  79e0              LDRB     r0,[r4,#7]            ;91  ; UART_Buffer_Rece
000128  79a1              LDRB     r1,[r4,#6]            ;91  ; UART_Buffer_Rece
00012a  eb002001          ADD      r0,r0,r1,LSL #8       ;91
00012e  9000              STR      r0,[sp,#0]            ;91
000130  2106              MOVS     r1,#6                 ;92
000132  4846              LDR      r0,|L3.588|
000134  f7fffffe          BL       Hardware_CRC
000138  f8bd1000          LDRH     r1,[sp,#0]            ;92
00013c  4288              CMP      r0,r1                 ;92
00013e  d002              BEQ      |L3.326|
000140  f8bd0000          LDRH     r0,[sp,#0]            ;92
000144  bb38              CBNZ     r0,|L3.406|
                  |L3.326|
000146  7960              LDRB     r0,[r4,#5]            ;94  ; UART_Buffer_Rece
000148  7921              LDRB     r1,[r4,#4]            ;94  ; UART_Buffer_Rece
00014a  eb002001          ADD      r0,r0,r1,LSL #8       ;94
00014e  9001              STR      r0,[sp,#4]            ;94
000150  78e0              LDRB     r0,[r4,#3]            ;95  ; UART_Buffer_Rece
000152  9003              STR      r0,[sp,#0xc]          ;95
000154  f8bd0004          LDRH     r0,[sp,#4]            ;96
000158  f89d100c          LDRB     r1,[sp,#0xc]          ;96
00015c  f8270011          STRH     r0,[r7,r1,LSL #1]     ;96
000160  7820              LDRB     r0,[r4,#0]            ;98  ; UART_Buffer_Rece
000162  7829              LDRB     r1,[r5,#0]            ;98  ; ADDR
000164  4288              CMP      r0,r1                 ;98
000166  d116              BNE      |L3.406|
000168  f8cd8008          STR      r8,[sp,#8]            ;100
00016c  e009              B        |L3.386|
                  |L3.366|
00016e  f89d0008          LDRB     r0,[sp,#8]            ;101
000172  5c20              LDRB     r0,[r4,r0]            ;101
000174  f89d1008          LDRB     r1,[sp,#8]            ;101
000178  5458              STRB     r0,[r3,r1]            ;101
00017a  f89d0008          LDRB     r0,[sp,#8]            ;100
00017e  1c40              ADDS     r0,r0,#1              ;100
000180  9002              STR      r0,[sp,#8]            ;100
                  |L3.386|
000182  f89d0008          LDRB     r0,[sp,#8]            ;100
000186  2808              CMP      r0,#8                 ;100
000188  d3f1              BCC      |L3.366|
00018a  f889a000          STRB     r10,[r9,#0]
;;;103    						UART_SEND_flag=1;
00018e  6830              LDR      r0,[r6,#0]  ; flagA
000190  f0400010          ORR      r0,r0,#0x10
000194  6030              STR      r0,[r6,#0]  ; flagA
                  |L3.406|
;;;104    					}
;;;105    				}
;;;106    			}
;;;107    		}
;;;108    //=======================================以下是命令16，连写寄存器===========================================
;;;109    //功能码16格式:
;;;110    //     地址 命令 写入起始地址高  写入起始地址低 写入字数高  写入字数低 写入字节数  数据高 数据低 ......CRC高 CRC低
;;;111    //返回数据格式:
;;;112    //     地址 命令 写入起始地址高  写入起始地址低  写入字节数高 写入字节数低  CRC高  CRC低 
;;;113    		if (UART_Buffer_Rece[1] == 16)										  
000196  7860              LDRB     r0,[r4,#1]  ; UART_Buffer_Rece
000198  2810              CMP      r0,#0x10
00019a  d155              BNE      |L3.584|
;;;114    		{	
;;;115    			if ((UART_Buffer_Rece[6] == 6) && (UART_Buffer_Rece[3] == 0x00))	//规定连写寄存器的个数
00019c  79a0              LDRB     r0,[r4,#6]  ; UART_Buffer_Rece
00019e  2806              CMP      r0,#6
0001a0  d152              BNE      |L3.584|
0001a2  78e0              LDRB     r0,[r4,#3]  ; UART_Buffer_Rece
0001a4  2800              CMP      r0,#0
0001a6  d14f              BNE      |L3.584|
;;;116    			{
;;;117    				crc_result = (UART_Buffer_Rece[13] << 8) + UART_Buffer_Rece[14];
0001a8  7ba0              LDRB     r0,[r4,#0xe]  ; UART_Buffer_Rece
0001aa  7b61              LDRB     r1,[r4,#0xd]  ; UART_Buffer_Rece
0001ac  eb002001          ADD      r0,r0,r1,LSL #8
0001b0  9000              STR      r0,[sp,#0]
;;;118    				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,13)) ||(crc_result == 0) )	   //检查CRC
0001b2  210d              MOVS     r1,#0xd
0001b4  4825              LDR      r0,|L3.588|
0001b6  f7fffffe          BL       Hardware_CRC
0001ba  f8bd1000          LDRH     r1,[sp,#0]
0001be  4288              CMP      r0,r1
0001c0  d003              BEQ      |L3.458|
0001c2  f8bd0000          LDRH     r0,[sp,#0]
0001c6  2800              CMP      r0,#0
0001c8  d13e              BNE      |L3.584|
                  |L3.458|
;;;119    				{												
;;;120    					for (var8=0;var8<3;var8++) Run_Control[var8] = (UART_Buffer_Rece[var8*2+7] << 8) + UART_Buffer_Rece[var8*2+8];
0001ca  f8cd800c          STR      r8,[sp,#0xc]
0001ce  e015              B        |L3.508|
                  |L3.464|
0001d0  f89d000c          LDRB     r0,[sp,#0xc]
0001d4  eb040040          ADD      r0,r4,r0,LSL #1
0001d8  7a00              LDRB     r0,[r0,#8]
0001da  f89d100c          LDRB     r1,[sp,#0xc]
0001de  eb040141          ADD      r1,r4,r1,LSL #1
0001e2  79c9              LDRB     r1,[r1,#7]
0001e4  eb002001          ADD      r0,r0,r1,LSL #8
0001e8  f89d100c          LDRB     r1,[sp,#0xc]
0001ec  f8270011          STRH     r0,[r7,r1,LSL #1]
0001f0  e000              B        |L3.500|
                  |L3.498|
0001f2  e029              B        |L3.584|
                  |L3.500|
0001f4  f89d000c          LDRB     r0,[sp,#0xc]
0001f8  1c40              ADDS     r0,r0,#1
0001fa  9003              STR      r0,[sp,#0xc]
                  |L3.508|
0001fc  f89d000c          LDRB     r0,[sp,#0xc]
000200  2803              CMP      r0,#3
000202  d3e5              BCC      |L3.464|
;;;121    
;;;122    					if (UART_Buffer_Rece[0] == ADDR)					  //广播模式不返回数据
000204  7820              LDRB     r0,[r4,#0]  ; UART_Buffer_Rece
000206  7829              LDRB     r1,[r5,#0]  ; ADDR
000208  4288              CMP      r0,r1
00020a  d11d              BNE      |L3.584|
;;;123    					{
;;;124    						UART_Buffer_Send[0] = ADDR;
00020c  7828              LDRB     r0,[r5,#0]  ; ADDR
00020e  7018              STRB     r0,[r3,#0]
;;;125    						UART_Buffer_Send[1] = 16;
000210  2010              MOVS     r0,#0x10
000212  7058              STRB     r0,[r3,#1]
;;;126    						UART_Buffer_Send[2] = UART_Buffer_Rece[2];
000214  78a0              LDRB     r0,[r4,#2]  ; UART_Buffer_Rece
000216  7098              STRB     r0,[r3,#2]
;;;127    						UART_Buffer_Send[3] = UART_Buffer_Rece[3];
000218  78e0              LDRB     r0,[r4,#3]  ; UART_Buffer_Rece
00021a  70d8              STRB     r0,[r3,#3]
;;;128    						UART_Buffer_Send[4] = UART_Buffer_Rece[4];
00021c  7920              LDRB     r0,[r4,#4]  ; UART_Buffer_Rece
00021e  7118              STRB     r0,[r3,#4]
;;;129    						UART_Buffer_Send[5] = UART_Buffer_Rece[5];
000220  7960              LDRB     r0,[r4,#5]  ; UART_Buffer_Rece
000222  7158              STRB     r0,[r3,#5]
;;;130    						crc_result = Hardware_CRC(UART_Buffer_Send,6);	 //计算CRC码
000224  2106              MOVS     r1,#6
000226  480b              LDR      r0,|L3.596|
000228  f7fffffe          BL       Hardware_CRC
00022c  9000              STR      r0,[sp,#0]
;;;131    						UART_Buffer_Send[6] = crc_result>>8;
00022e  f8bd0000          LDRH     r0,[sp,#0]
000232  0a00              LSRS     r0,r0,#8
000234  7198              STRB     r0,[r3,#6]
;;;132    						UART_Buffer_Send[7] = crc_result;				 
000236  f8bd0000          LDRH     r0,[sp,#0]
00023a  71d8              STRB     r0,[r3,#7]
;;;133    						Transmit_BUFFERsize = 8;					     //设置发送字节数长度
00023c  f889a000          STRB     r10,[r9,#0]
;;;134    						UART_SEND_flag=1;
000240  6830              LDR      r0,[r6,#0]  ; flagA
000242  f0400010          ORR      r0,r0,#0x10
000246  6030              STR      r0,[r6,#0]  ; flagA
                  |L3.584|
;;;135    					}
;;;136    				}
;;;137    			}			 
;;;138    		}
;;;139    	}
;;;140    //===================================================================================
;;;141    }
000248  e8bd87ff          POP      {r0-r10,pc}
;;;142    //===============================AD值转换成测量值============================================//
                          ENDP

                  |L3.588|
                          DCD      UART_Buffer_Rece
                  |L3.592|
                          DCD      ||area_number.15||
                  |L3.596|
                          DCD      UART_Buffer_Send
                  |L3.600|
                          DCD      Transmit_BUFFERsize
                  |L3.604|
                          DCD      flagA
                  |L3.608|
                          DCD      ||.bss||+0x40

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Correct_Parametet
                          %        28
                  Correct_Strong
                          %        36
                  Run_Control
                          %        28

                          AREA ||.data||, DATA, ALIGN=1

                  ADJ_Write
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.8||, DATA, ALIGN=0

                          EXPORTAS ||area_number.8||, ||.data||
                  DAC_Flag
000000  00                DCB      0x00

                          AREA ||area_number.9||, DATA, ALIGN=1

                          EXPORTAS ||area_number.9||, ||.data||
                  Modify_A_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.10||, DATA, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.data||
                  Modify_C_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.11||, DATA, ALIGN=1

                          EXPORTAS ||area_number.11||, ||.data||
                  Modify_A_ACT
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.12||, DATA, ALIGN=1

                          EXPORTAS ||area_number.12||, ||.data||
                  Modify_B_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.13||, DATA, ALIGN=1

                          EXPORTAS ||area_number.13||, ||.data||
                  Modify_D_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.14||, DATA, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.data||
                  Modify_B_ACT
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.15||, DATA, ALIGN=0

                          EXPORTAS ||area_number.15||, ||.data||
                  ADDR
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\modbus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_modbus_c_bae18981____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REVSH|
#line 144
|__asm___8_modbus_c_bae18981____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
