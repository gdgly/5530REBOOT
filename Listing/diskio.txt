; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\diskio.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\diskio.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\Libraries\STM32_USB_OTG_Driver\inc -I..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\User\usbh_mass_storage -I..\User\fatfs\src -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY -DSTM32F40XX --omf_browse=..\output\diskio.crf --no_multibyte_chars ..\User\fatfs\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;25     /*-------------------------------------------------------------------------------------------*/
;;;26     DSTATUS disk_initialize (
000000  b510              PUSH     {r4,lr}
;;;27     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;28     )
;;;29     {
;;;30     	DSTATUS stat = STA_NOINIT;
000002  2401              MOVS     r4,#1
;;;31     
;;;32     	switch (pdrv)
000004  2801              CMP      r0,#1
000006  d006              BEQ      |L1.22|
000008  2802              CMP      r0,#2
00000a  d104              BNE      |L1.22|
;;;33     	{
;;;34     //		case FS_SD :		/* SD卡 */
;;;35     //			if (SD_Init() == SD_OK)
;;;36     //			{
;;;37     //				stat = RES_OK;
;;;38     //			}
;;;39     //			else
;;;40     //			{
;;;41     //				stat = STA_NODISK;
;;;42     //			}
;;;43     //			break;
;;;44     			
;;;45     		case FS_NAND :		/* NAND Flash */
;;;46     			break;
;;;47     		
;;;48     		case FS_USB :		/* STM32 USB Host 口外接U盘 */
;;;49     			if(HCD_IsDeviceConnected(&USB_OTG_Core))
00000c  4803              LDR      r0,|L1.28|
00000e  f7fffffe          BL       HCD_IsDeviceConnected
000012  b100              CBZ      r0,|L1.22|
;;;50     			{
;;;51     				stat &= ~STA_NOINIT;
000014  2400              MOVS     r4,#0
                  |L1.22|
;;;52     			}
;;;53     			break;
;;;54     
;;;55     		default :
;;;56     			break;
;;;57     	}
;;;58     
;;;59     	return stat;
000016  4620              MOV      r0,r4
;;;60     }
000018  bd10              POP      {r4,pc}
;;;61     
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      USB_OTG_Core

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;289    #if _USE_IOCTL
;;;290    DRESULT disk_ioctl (
000000  b510              PUSH     {r4,lr}
;;;291    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;292    	BYTE cmd,		/* Control code */
;;;293    	void *buff		/* Buffer to send/receive control data */
;;;294    )
;;;295    {
000002  4603              MOV      r3,r0
;;;296    	DRESULT res = RES_PARERR;
000004  2004              MOVS     r0,#4
;;;297    
;;;298    	switch (pdrv) {
;;;299    	case FS_SD :
;;;300    		res = RES_ERROR;
;;;301    		switch (cmd)
;;;302    		{
;;;303    			/* SD卡磁盘容量： SDCardInfo.CardCapacity */
;;;304    			case CTRL_SYNC :		/* Wait for end of internal write process of the drive */
;;;305    				res = RES_OK;
;;;306    				break;
;;;307    
;;;308    			case GET_SECTOR_COUNT :	/* Get drive capacity in unit of sector (DWORD) */
;;;309    //				*(DWORD*)buff = SDCardInfo.CardCapacity / 512;
;;;310    				res = RES_OK;
;;;311    				break;
;;;312    
;;;313    			case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
;;;314    				*(WORD*)buff = 512;
000006  01c4              LSLS     r4,r0,#7
000008  2b00              CMP      r3,#0                 ;298
00000a  d00d              BEQ      |L2.40|
00000c  2b01              CMP      r3,#1                 ;298
00000e  d00a              BEQ      |L2.38|
000010  2b02              CMP      r3,#2                 ;298
000012  d108              BNE      |L2.38|
;;;315    				res = RES_OK;
;;;316    				break;
;;;317    
;;;318    			case CTRL_ERASE_SECTOR: /* Erase a block of sectors (used when _USE_ERASE == 1) */
;;;319    			default:
;;;320    				res = RES_PARERR;
;;;321    				break;
;;;322    		}
;;;323    		break;
;;;324    
;;;325    	case FS_NAND :
;;;326    		break;
;;;327    
;;;328    	case FS_USB :
;;;329    		//if (drv) return RES_PARERR;
;;;330    		//if (Stat & STA_NOINIT) return RES_NOTRDY;
;;;331    		switch (cmd)
000014  b1b1              CBZ      r1,|L2.68|
000016  2901              CMP      r1,#1
000018  d016              BEQ      |L2.72|
00001a  2902              CMP      r1,#2
00001c  d019              BEQ      |L2.82|
00001e  2903              CMP      r1,#3
000020  d101              BNE      |L2.38|
;;;332    		{
;;;333    			case CTRL_SYNC :		/* Make sure that no pending write process */
;;;334    				res = RES_OK;
;;;335    				break;
;;;336    
;;;337    			case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
;;;338    				*(DWORD*)buff = (DWORD) USBH_MSC_Param.MSCapacity;
;;;339    				res = RES_OK;
;;;340    				break;
;;;341    
;;;342    			case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
;;;343    				*(WORD*)buff = 512;
;;;344    				res = RES_OK;
;;;345    				break;
;;;346    
;;;347    			case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */\
;;;348    				*(DWORD*)buff = 512;
000022  6014              STR      r4,[r2,#0]
;;;349    				res = RES_OK;
000024  2000              MOVS     r0,#0
                  |L2.38|
;;;350    				break;
;;;351    
;;;352    			default:
;;;353    				res = RES_PARERR;
;;;354    				break;
;;;355    		}
;;;356    		break;
;;;357    
;;;358    	default:
;;;359    		res = RES_PARERR;
;;;360    		break;
;;;361    	}
;;;362    	return res;
;;;363    }
000026  bd10              POP      {r4,pc}
                  |L2.40|
000028  b129              CBZ      r1,|L2.54|
00002a  2901              CMP      r1,#1                 ;301
00002c  d005              BEQ      |L2.58|
00002e  2903              CMP      r1,#3                 ;301
000030  d005              BEQ      |L2.62|
000032  2004              MOVS     r0,#4                 ;320
000034  bd10              POP      {r4,pc}
                  |L2.54|
000036  2000              MOVS     r0,#0                 ;305
000038  bd10              POP      {r4,pc}
                  |L2.58|
00003a  2000              MOVS     r0,#0                 ;310
00003c  bd10              POP      {r4,pc}
                  |L2.62|
00003e  8014              STRH     r4,[r2,#0]            ;314
000040  2000              MOVS     r0,#0                 ;315
000042  bd10              POP      {r4,pc}
                  |L2.68|
000044  2000              MOVS     r0,#0                 ;334
000046  bd10              POP      {r4,pc}
                  |L2.72|
000048  4803              LDR      r0,|L2.88|
00004a  6800              LDR      r0,[r0,#0]            ;338  ; USBH_MSC_Param
00004c  6010              STR      r0,[r2,#0]            ;338
00004e  2000              MOVS     r0,#0                 ;339
000050  bd10              POP      {r4,pc}
                  |L2.82|
000052  8014              STRH     r4,[r2,#0]            ;343
000054  2000              MOVS     r0,#0                 ;344
000056  bd10              POP      {r4,pc}
;;;364    #endif
                          ENDP

                  |L2.88|
                          DCD      USBH_MSC_Param

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=2

                  disk_read PROC
;;;94     /*-------------------------------------------------------------------------------------------*/
;;;95     DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;96     	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;97     	BYTE *buff,		/* Data buffer to store read data */
;;;98     	DWORD sector,	/* Sector address (LBA) */
;;;99     	UINT count		/* Number of sectors to read (1..128) */
;;;100    )
;;;101    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;102    	DRESULT res = RES_OK;
00000c  2000              MOVS     r0,#0
;;;103    
;;;104    	switch (pdrv)
00000e  2c01              CMP      r4,#1
000010  d002              BEQ      |L3.24|
000012  2c02              CMP      r4,#2
000014  d002              BEQ      |L3.28|
;;;105    	{
;;;106    //		case FS_SD :
;;;107    //		{
;;;108    //			SD_Error Status = SD_OK;
;;;109    
;;;110    //			if (count == 1)
;;;111    //			{
;;;112    //				Status = SD_ReadBlock(buff, sector << 9 , SECTOR_SIZE);
;;;113    //			}
;;;114    //			else
;;;115    //			{
;;;116    //				Status = SD_ReadMultiBlocks(buff, sector << 9 , SECTOR_SIZE, count);
;;;117    //			}
;;;118    //			
;;;119    //			if (Status != SD_OK)
;;;120    //			{
;;;121    //				res = RES_ERROR;
;;;122    //				break;
;;;123    //			}
;;;124    
;;;125    //		#ifdef SD_DMA_MODE
;;;126    //			/* SDIO工作在DMA模式，需要检查操作DMA传输是否完成 */
;;;127    //			Status = SD_WaitReadOperation();
;;;128    //			if (Status != SD_OK)
;;;129    //			{
;;;130    //				res = RES_ERROR;
;;;131    //				break;
;;;132    //			}
;;;133    
;;;134    //			while(SD_GetStatus() != SD_TRANSFER_OK);
;;;135    //		#endif
;;;136    
;;;137    //			res = RES_OK;
;;;138    //			break;
;;;139    //		}
;;;140    		
;;;141    		case FS_NAND :
;;;142    			break;
;;;143    
;;;144    		case FS_USB :
;;;145    			//res = USB_disk_read(buff, sector, count);
;;;146    			{
;;;147    				BYTE status = USBH_MSC_OK;
;;;148    
;;;149    				//if (Stat & STA_NOINIT) 	return RES_NOTRDY;
;;;150    
;;;151    				if (HCD_IsDeviceConnected(&USB_OTG_Core))
;;;152    				{
;;;153    					do
;;;154    					{
;;;155    						USBH_Process(&USB_OTG_Core, &USB_Host);
;;;156    						status = USBH_MSC_Read10(&USB_OTG_Core, buff,sector,512 * count);
;;;157    						USBH_MSC_HandleBOTXfer(&USB_OTG_Core ,&USB_Host);
;;;158    
;;;159    						if (!HCD_IsDeviceConnected(&USB_OTG_Core))
;;;160    						{
;;;161    							break;
;;;162    						}
;;;163    					}
;;;164    					while (status == USBH_MSC_BUSY );
;;;165    				}
;;;166    
;;;167    				if (status == USBH_MSC_OK)
;;;168    				{
;;;169    					res = RES_OK;
;;;170    				}
;;;171    				else
;;;172    				{
;;;173    					res = RES_ERROR;
;;;174    				}
;;;175    			}
;;;176    			break;
;;;177    			
;;;178    		default:
;;;179    			res = RES_PARERR;
000016  2004              MOVS     r0,#4
                  |L3.24|
;;;180    			break;
;;;181    	}
;;;182    	
;;;183    	return res;
;;;184    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L3.28|
00001c  2400              MOVS     r4,#0                 ;147
00001e  480f              LDR      r0,|L3.92|
000020  f7fffffe          BL       HCD_IsDeviceConnected
000024  b1a8              CBZ      r0,|L3.82|
000026  026d              LSLS     r5,r5,#9              ;156
                  |L3.40|
000028  490d              LDR      r1,|L3.96|
00002a  480c              LDR      r0,|L3.92|
00002c  f7fffffe          BL       USBH_Process
000030  462b              MOV      r3,r5                 ;156
000032  463a              MOV      r2,r7                 ;156
000034  4631              MOV      r1,r6                 ;156
000036  4809              LDR      r0,|L3.92|
000038  f7fffffe          BL       USBH_MSC_Read10
00003c  4604              MOV      r4,r0                 ;156
00003e  4908              LDR      r1,|L3.96|
000040  4806              LDR      r0,|L3.92|
000042  f7fffffe          BL       USBH_MSC_HandleBOTXfer
000046  4805              LDR      r0,|L3.92|
000048  f7fffffe          BL       HCD_IsDeviceConnected
00004c  b108              CBZ      r0,|L3.82|
00004e  2c03              CMP      r4,#3                 ;164
000050  d0ea              BEQ      |L3.40|
                  |L3.82|
000052  b10c              CBZ      r4,|L3.88|
000054  2001              MOVS     r0,#1                 ;173
000056  e7df              B        |L3.24|
                  |L3.88|
000058  2000              MOVS     r0,#0                 ;169
00005a  e7dd              B        |L3.24|
;;;185    
                          ENDP

                  |L3.92|
                          DCD      USB_OTG_Core
                  |L3.96|
                          DCD      USB_Host

                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;64     /*-------------------------------------------------------------------------------------------*/
;;;65     DSTATUS disk_status (
000000  2800              CMP      r0,#0
;;;66     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;67     )
;;;68     {
000002  d005              BEQ      |L4.16|
;;;69     	DSTATUS stat = STA_NOINIT;
;;;70     
;;;71     	switch (pdrv)
000004  2801              CMP      r0,#1
000006  d005              BEQ      |L4.20|
000008  2802              CMP      r0,#2
00000a  d005              BEQ      |L4.24|
;;;72     	{
;;;73     		case FS_SD :
;;;74     			stat = 0;
;;;75     			break;
;;;76     		
;;;77     		case FS_NAND :
;;;78     			stat = 0;
;;;79     			break;
;;;80     
;;;81     		case FS_USB :
;;;82     			stat = 0;
;;;83     			break;
;;;84     
;;;85     		default:
;;;86     			stat = 0;
00000c  2000              MOVS     r0,#0
;;;87     			break;
;;;88     	}
;;;89     	return stat;
;;;90     }
00000e  4770              BX       lr
                  |L4.16|
000010  2000              MOVS     r0,#0                 ;74
000012  4770              BX       lr
                  |L4.20|
000014  2000              MOVS     r0,#0                 ;78
000016  4770              BX       lr
                  |L4.24|
000018  2000              MOVS     r0,#0                 ;82
00001a  4770              BX       lr
;;;91     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=2

                  disk_write PROC
;;;189    #if _USE_WRITE
;;;190    DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;191    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;192    	const BYTE *buff,	/* Data to be written */
;;;193    	DWORD sector,		/* Sector address (LBA) */
;;;194    	UINT count			/* Number of sectors to write (1..128) */
;;;195    )
;;;196    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;197    	DRESULT res = RES_OK;
00000c  2000              MOVS     r0,#0
;;;198    
;;;199    	switch (pdrv)
00000e  2c01              CMP      r4,#1
000010  d002              BEQ      |L5.24|
000012  2c02              CMP      r4,#2
000014  d002              BEQ      |L5.28|
;;;200    	{
;;;201    //		case FS_SD :
;;;202    //		{
;;;203    //			SD_Error Status = SD_OK;
;;;204    
;;;205    //			if (count == 1)
;;;206    //			{
;;;207    //				Status = SD_WriteBlock((uint8_t *)buff, sector << 9 ,SECTOR_SIZE);
;;;208    //			}
;;;209    //			else
;;;210    //			{
;;;211    //				/* 此处存在疑问： 扇区个数如果写 count ，将导致最后1个block无法写入 */
;;;212    //				//Status = SD_WriteMultiBlocks((uint8_t *)buff, sector << 9 ,SECTOR_SIZE, count);
;;;213    //				Status = SD_WriteMultiBlocks((uint8_t *)buff, sector << 9 ,SECTOR_SIZE, count + 1);
;;;214    //			}
;;;215    //			
;;;216    //			if (Status != SD_OK)
;;;217    //			{
;;;218    //				res = RES_ERROR;
;;;219    //				break;
;;;220    //			}
;;;221    
;;;222    //		#ifdef SD_DMA_MODE
;;;223    //			/* SDIO工作在DMA模式，需要检查操作DMA传输是否完成 */
;;;224    //			Status = SD_WaitReadOperation();
;;;225    //			if (Status != SD_OK)
;;;226    //			{
;;;227    //				res = RES_ERROR;
;;;228    //				break;
;;;229    //			}
;;;230    //			while(SD_GetStatus() != SD_TRANSFER_OK);
;;;231    //		#endif
;;;232    //			
;;;233    //			res = RES_OK;
;;;234    //			break;
;;;235    //		}
;;;236    		
;;;237    		case FS_NAND :
;;;238    			break;
;;;239    
;;;240    		case FS_USB :
;;;241    			//res = USB_disk_write(buff, sector, count);
;;;242    			{
;;;243    				BYTE status = USBH_MSC_OK;
;;;244    
;;;245    				//if (drv || !count) return RES_PARERR;
;;;246    
;;;247    				//if (Stat & STA_NOINIT) return RES_NOTRDY;
;;;248    				//if (Stat & STA_PROTECT) return RES_WRPRT;
;;;249    
;;;250    				if (HCD_IsDeviceConnected(&USB_OTG_Core))
;;;251    				{
;;;252    					do
;;;253    					{
;;;254    						status = USBH_MSC_Write10(&USB_OTG_Core,(BYTE*)buff,sector, 512 * count);
;;;255    						USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
;;;256    
;;;257    						if(!HCD_IsDeviceConnected(&USB_OTG_Core))
;;;258    						{
;;;259    							break;
;;;260    						}
;;;261    					}
;;;262    					while(status == USBH_MSC_BUSY );
;;;263    
;;;264    				}
;;;265    
;;;266    				if (status == USBH_MSC_OK)
;;;267    				{
;;;268    					res = RES_OK;
;;;269    				}
;;;270    				else
;;;271    				{
;;;272    					res = RES_ERROR;
;;;273    				}
;;;274    			}
;;;275    			break;
;;;276    
;;;277    		default:
;;;278    			res = RES_PARERR;
000016  2004              MOVS     r0,#4
                  |L5.24|
;;;279    			break;
;;;280    	}
;;;281    	return res;
;;;282    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L5.28|
00001c  2400              MOVS     r4,#0                 ;243
00001e  480d              LDR      r0,|L5.84|
000020  f7fffffe          BL       HCD_IsDeviceConnected
000024  b188              CBZ      r0,|L5.74|
000026  026d              LSLS     r5,r5,#9              ;254
                  |L5.40|
000028  462b              MOV      r3,r5                 ;254
00002a  463a              MOV      r2,r7                 ;254
00002c  4631              MOV      r1,r6                 ;254
00002e  4809              LDR      r0,|L5.84|
000030  f7fffffe          BL       USBH_MSC_Write10
000034  4604              MOV      r4,r0                 ;254
000036  4908              LDR      r1,|L5.88|
000038  4806              LDR      r0,|L5.84|
00003a  f7fffffe          BL       USBH_MSC_HandleBOTXfer
00003e  4805              LDR      r0,|L5.84|
000040  f7fffffe          BL       HCD_IsDeviceConnected
000044  b108              CBZ      r0,|L5.74|
000046  2c03              CMP      r4,#3                 ;262
000048  d0ee              BEQ      |L5.40|
                  |L5.74|
00004a  b10c              CBZ      r4,|L5.80|
00004c  2001              MOVS     r0,#1                 ;272
00004e  e7e3              B        |L5.24|
                  |L5.80|
000050  2000              MOVS     r0,#0                 ;268
000052  e7e1              B        |L5.24|
;;;283    #endif
                          ENDP

                  |L5.84|
                          DCD      USB_OTG_Core
                  |L5.88|
                          DCD      USB_Host

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;373    */
;;;374    DWORD get_fattime (void)
000000  4800              LDR      r0,|L6.4|
;;;375    {
;;;376    	/* 如果有全局时钟，可按下面的格式进行时钟转换. 这个例子是2013-01-01 00:00:00 */
;;;377    
;;;378    	return	  ((DWORD)(2013 - 1980) << 25)	/* Year = 2013 */
;;;379    			| ((DWORD)1 << 21)				/* Month = 1 */
;;;380    			| ((DWORD)1 << 16)				/* Day_m = 1*/
;;;381    			| ((DWORD)0 << 11)				/* Hour = 0 */
;;;382    			| ((DWORD)0 << 5)				/* Min = 0 */
;;;383    			| ((DWORD)0 >> 1);				/* Sec = 0 */
;;;384    }
000002  4770              BX       lr
                          ENDP

                  |L6.4|
                          DCD      0x42210000

;*** Start embedded assembler ***

#line 1 "..\\User\\fatfs\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_b3252454____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REVSH|
#line 144
|__asm___8_diskio_c_b3252454____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
