; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\usbh_stdreq.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\usbh_stdreq.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\Libraries\STM32_USB_OTG_Driver\inc -I..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\User\usbh_mass_storage -I..\User\fatfs\src -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY -DSTM32F40XX --omf_browse=..\output\usbh_stdreq.crf --no_multibyte_chars ..\Libraries\STM32_USB_HOST_Library\Core\src\usbh_stdreq.c]
                          THUMB

                          AREA ||i.USBH_ClearDeviceFeature||, CODE, READONLY, ALIGN=1

                  USBH_ClearDeviceFeature PROC
;;;349    */
;;;350    USBH_Status USBH_ClearDeviceFeature(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;351                                        USBH_HOST *phost,
;;;352                                        uint8_t FeatureSelector, uint16_t wIndex)
;;;353    {
;;;354      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
000002  2400              MOVS     r4,#0
000004  750c              STRB     r4,[r1,#0x14]
;;;355        USB_REQ_TYPE_STANDARD;
;;;356      
;;;357      phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
000006  2501              MOVS     r5,#1
000008  754d              STRB     r5,[r1,#0x15]
;;;358      phost->Control.setup.b.wValue.w = FeatureSelector;
00000a  82ca              STRH     r2,[r1,#0x16]
;;;359      phost->Control.setup.b.wIndex.w = wIndex;
00000c  830b              STRH     r3,[r1,#0x18]
;;;360      phost->Control.setup.b.wLength.w = 0;           
00000e  834c              STRH     r4,[r1,#0x1a]
;;;361      
;;;362      return USBH_CtlReq(pdev, phost, 0 , 0 );     
000010  2300              MOVS     r3,#0
000012  bc30              POP      {r4,r5}
000014  461a              MOV      r2,r3
000016  f7ffbffe          B.W      USBH_CtlReq
;;;363    }
;;;364    
                          ENDP


                          AREA ||i.USBH_ClrFeature||, CODE, READONLY, ALIGN=1

                  USBH_ClrFeature PROC
;;;373    */
;;;374    USBH_Status USBH_ClrFeature(USB_OTG_CORE_HANDLE *pdev,
000000  b430              PUSH     {r4,r5}
;;;375                                USBH_HOST *phost,
;;;376                                uint8_t ep_num, 
;;;377                                uint8_t hc_num) 
;;;378    {
;;;379      
;;;380      phost->Control.setup.b.bmRequestType = USB_H2D | 
000002  2402              MOVS     r4,#2
000004  750c              STRB     r4,[r1,#0x14]
;;;381                                             USB_REQ_RECIPIENT_ENDPOINT |
;;;382                                             USB_REQ_TYPE_STANDARD;
;;;383      
;;;384      phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
000006  2401              MOVS     r4,#1
000008  754c              STRB     r4,[r1,#0x15]
;;;385      phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
00000a  2400              MOVS     r4,#0
00000c  82cc              STRH     r4,[r1,#0x16]
;;;386      phost->Control.setup.b.wIndex.w = ep_num;
00000e  830a              STRH     r2,[r1,#0x18]
;;;387      phost->Control.setup.b.wLength.w = 0;           
000010  834c              STRH     r4,[r1,#0x1a]
;;;388      
;;;389      if ((ep_num & USB_REQ_DIR_MASK ) == USB_D2H)
000012  0615              LSLS     r5,r2,#24
;;;390      { /* EP Type is IN */
;;;391        pdev->host.hc[hc_num].toggle_in = 0; 
000014  eb001243          ADD      r2,r0,r3,LSL #5
000018  d502              BPL      |L2.32|
00001a  f88248ac          STRB     r4,[r2,#0x8ac]
00001e  e001              B        |L2.36|
                  |L2.32|
;;;392      }
;;;393      else
;;;394      {/* EP Type is OUT */
;;;395        pdev->host.hc[hc_num].toggle_out = 0; 
000020  f88248ad          STRB     r4,[r2,#0x8ad]
                  |L2.36|
;;;396      }
;;;397      
;;;398      return USBH_CtlReq(pdev, phost, 0 , 0 );   
000024  2300              MOVS     r3,#0
000026  bc30              POP      {r4,r5}
000028  461a              MOV      r2,r3
00002a  f7ffbffe          B.W      USBH_CtlReq
;;;399    }
;;;400    
                          ENDP


                          AREA ||i.USBH_GetDescriptor||, CODE, READONLY, ALIGN=1

                  USBH_GetDescriptor PROC
;;;229    */
;;;230    USBH_Status USBH_GetDescriptor(USB_OTG_CORE_HANDLE *pdev,
000000  b430              PUSH     {r4,r5}
;;;231                                   USBH_HOST           *phost,                                
;;;232                                   uint8_t  req_type,
;;;233                                   uint16_t value_idx, 
;;;234                                   uint8_t* buff, 
;;;235                                   uint16_t length )
;;;236    { 
000002  e9dd5402          LDRD     r5,r4,[sp,#8]
;;;237      phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
000006  f0420280          ORR      r2,r2,#0x80
00000a  750a              STRB     r2,[r1,#0x14]
;;;238      phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
00000c  2206              MOVS     r2,#6
00000e  754a              STRB     r2,[r1,#0x15]
;;;239      phost->Control.setup.b.wValue.w = value_idx;
000010  82cb              STRH     r3,[r1,#0x16]
;;;240      
;;;241      if ((value_idx & 0xff00) == USB_DESC_STRING)
000012  2203              MOVS     r2,#3
000014  ebb22f13          CMP      r2,r3,LSR #8
000018  d103              BNE      |L3.34|
;;;242      {
;;;243        phost->Control.setup.b.wIndex.w = 0x0409;
00001a  f2404209          MOV      r2,#0x409
00001e  830a              STRH     r2,[r1,#0x18]
000020  e001              B        |L3.38|
                  |L3.34|
;;;244      }
;;;245      else
;;;246      {
;;;247        phost->Control.setup.b.wIndex.w = 0;
000022  2200              MOVS     r2,#0
000024  830a              STRH     r2,[r1,#0x18]
                  |L3.38|
;;;248      }
;;;249      phost->Control.setup.b.wLength.w = length;           
000026  834c              STRH     r4,[r1,#0x1a]
;;;250      return USBH_CtlReq(pdev, phost, buff , length );     
000028  4623              MOV      r3,r4
00002a  462a              MOV      r2,r5
00002c  bc30              POP      {r4,r5}
00002e  f7ffbffe          B.W      USBH_CtlReq
;;;251    }
;;;252    
                          ENDP


                          AREA ||i.USBH_GetNextDesc||, CODE, READONLY, ALIGN=1

                  USBH_GetNextDesc PROC
;;;630    */
;;;631    USBH_DescHeader_t  *USBH_GetNextDesc (uint8_t   *pbuf, uint16_t  *ptr)
000000  880a              LDRH     r2,[r1,#0]
;;;632    {
;;;633      USBH_DescHeader_t  *pnext;
;;;634     
;;;635      *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
000002  7803              LDRB     r3,[r0,#0]
000004  441a              ADD      r2,r2,r3
000006  800a              STRH     r2,[r1,#0]
;;;636      pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
000008  7801              LDRB     r1,[r0,#0]
00000a  4408              ADD      r0,r0,r1
;;;637             ((USBH_DescHeader_t *)pbuf)->bLength);
;;;638     
;;;639      return(pnext);
;;;640    }
00000c  4770              BX       lr
;;;641    
                          ENDP


                          AREA ||i.USBH_Get_CfgDesc||, CODE, READONLY, ALIGN=2

                  USBH_Get_CfgDesc PROC
;;;152    */
;;;153    USBH_Status USBH_Get_CfgDesc(USB_OTG_CORE_HANDLE *pdev, 
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;154                                 USBH_HOST           *phost,                      
;;;155                                 uint16_t length)
;;;156    
;;;157    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;158      USBH_Status status, result;
;;;159      uint16_t index = 0;
00000a  2400              MOVS     r4,#0
;;;160      
;;;161      if((status = USBH_GetDescriptor(pdev,
00000c  f20659f4          ADD      r9,r6,#0x5f4
000010  e9cd9500          STRD     r9,r5,[sp,#0]
000014  f44f7300          MOV      r3,#0x200
000018  2200              MOVS     r2,#0
00001a  4639              MOV      r1,r7
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       USBH_GetDescriptor
000022  f1b00800          SUBS     r8,r0,#0
000026  d115              BNE      |L5.84|
;;;162                                      phost,
;;;163                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
;;;164                                      USB_DESC_CONFIGURATION, 
;;;165                                      pdev->host.Rx_Buffer,
;;;166                                      length)) == USBH_OK)
;;;167      {
;;;168        /*save Cfg descriptor for class parsing usage */
;;;169        for( ; index < length ; index ++)
;;;170        {
;;;171          USBH_CfgDesc[index] = pdev->host.Rx_Buffer[index];
000028  480c              LDR      r0,|L5.92|
00002a  e005              B        |L5.56|
                  |L5.44|
00002c  1931              ADDS     r1,r6,r4
00002e  f89115f4          LDRB     r1,[r1,#0x5f4]
000032  5501              STRB     r1,[r0,r4]
000034  1c64              ADDS     r4,r4,#1              ;169
000036  b2a4              UXTH     r4,r4                 ;169
                  |L5.56|
000038  42ac              CMP      r4,r5                 ;169
00003a  d3f7              BCC      |L5.44|
;;;172        }
;;;173        
;;;174        /* Commands successfully sent and Response Received  */       
;;;175        result = USBH_ParseCfgDesc (&phost->device_prop.Cfg_Desc,
00003c  464b              MOV      r3,r9
00003e  f1070250          ADD      r2,r7,#0x50
000042  f107013e          ADD      r1,r7,#0x3e
000046  f1070034          ADD      r0,r7,#0x34
00004a  9500              STR      r5,[sp,#0]
00004c  f7fffffe          BL       USBH_ParseCfgDesc
;;;176                           phost->device_prop.Itf_Desc,
;;;177                           phost->device_prop.Ep_Desc, 
;;;178                           pdev->host.Rx_Buffer,
;;;179                           length);
;;;180        if (result != USBH_OK)  status= result;
000050  b100              CBZ      r0,|L5.84|
000052  4680              MOV      r8,r0
                  |L5.84|
;;;181         
;;;182        
;;;183      }
;;;184      return status;
000054  4640              MOV      r0,r8
;;;185    }
000056  e8bd87fc          POP      {r2-r10,pc}
;;;186    
                          ENDP

00005a  0000              DCW      0x0000
                  |L5.92|
                          DCD      ||.bss||

                          AREA ||i.USBH_Get_DevDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_DevDesc PROC
;;;120    */
;;;121    USBH_Status USBH_Get_DevDesc(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;122                                 USBH_HOST *phost,
;;;123                                 uint8_t length)
;;;124    {
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;125      
;;;126      USBH_Status status;
;;;127      
;;;128      if((status = USBH_GetDescriptor(pdev, 
000008  f20054f4          ADD      r4,r0,#0x5f4
00000c  f44f7380          MOV      r3,#0x100
000010  2200              MOVS     r2,#0
000012  4631              MOV      r1,r6
000014  e9cd4500          STRD     r4,r5,[sp,#0]
000018  f7fffffe          BL       USBH_GetDescriptor
00001c  1e07              SUBS     r7,r0,#0
00001e  d105              BNE      |L6.44|
;;;129                                      phost,
;;;130                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
;;;131                                      USB_DESC_DEVICE, 
;;;132                                      pdev->host.Rx_Buffer,
;;;133                                      length)) == USBH_OK)
;;;134      {
;;;135        /* Commands successfully sent and Response Received */       
;;;136        USBH_ParseDevDesc(&phost->device_prop.Dev_Desc, pdev->host.Rx_Buffer, length);
000020  462a              MOV      r2,r5
000022  4621              MOV      r1,r4
000024  f1060022          ADD      r0,r6,#0x22
000028  f7fffffe          BL       USBH_ParseDevDesc
                  |L6.44|
;;;137      }
;;;138      return status;      
00002c  4638              MOV      r0,r7
;;;139    }
00002e  e8bd81fc          POP      {r2-r8,pc}
;;;140    
                          ENDP


                          AREA ||i.USBH_Get_StringDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_StringDesc PROC
;;;197    */
;;;198    USBH_Status USBH_Get_StringDesc(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;199                                    USBH_HOST *phost,
;;;200                                    uint8_t string_index, 
;;;201                                    uint8_t *buff, 
;;;202                                    uint16_t length)
;;;203    {
000004  461e              MOV      r6,r3
000006  9d08              LDR      r5,[sp,#0x20]
;;;204      USBH_Status status;
;;;205      
;;;206      if((status = USBH_GetDescriptor(pdev,
000008  f20054f4          ADD      r4,r0,#0x5f4
00000c  f4427340          ORR      r3,r2,#0x300
000010  2200              MOVS     r2,#0
000012  e9cd4500          STRD     r4,r5,[sp,#0]
000016  f7fffffe          BL       USBH_GetDescriptor
00001a  1e07              SUBS     r7,r0,#0
00001c  d104              BNE      |L7.40|
;;;207                                      phost,
;;;208                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                                    
;;;209                                      USB_DESC_STRING | string_index, 
;;;210                                      pdev->host.Rx_Buffer,
;;;211                                      length)) == USBH_OK)
;;;212      {
;;;213        /* Commands successfully sent and Response Received  */       
;;;214        USBH_ParseStringDesc(pdev->host.Rx_Buffer,buff, length);    
00001e  462a              MOV      r2,r5
000020  4631              MOV      r1,r6
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       USBH_ParseStringDesc
                  |L7.40|
;;;215      }
;;;216      return status;
000028  4638              MOV      r0,r7
;;;217    }
00002a  e8bd81fc          POP      {r2-r8,pc}
;;;218    
                          ENDP


                          AREA ||i.USBH_ParseCfgDesc||, CODE, READONLY, ALIGN=2

                  USBH_ParseCfgDesc PROC
;;;443    */
;;;444    USBH_Status USBH_ParseCfgDesc (USBH_CfgDesc_TypeDef* cfg_desc,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;445                                    USBH_InterfaceDesc_TypeDef* itf_desc,
;;;446                                    USBH_EpDesc_TypeDef   ep_desc[][USBH_MAX_NUM_ENDPOINTS], 
;;;447                                    uint8_t *buf, 
;;;448                                    uint16_t length)
;;;449    {  
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  9912              LDR      r1,[sp,#0x48]
00000a  4690              MOV      r8,r2
;;;450      USBH_InterfaceDesc_TypeDef    *pif ;
;;;451      USBH_InterfaceDesc_TypeDef    temp_pif ;  
;;;452      USBH_EpDesc_TypeDef           *pep;  
;;;453      USBH_DescHeader_t             *pdesc = (USBH_DescHeader_t *)buf;
00000c  461c              MOV      r4,r3
;;;454      uint16_t                      ptr;
;;;455      int8_t                        if_ix = 0;
;;;456      int8_t                        ep_ix = 0;  
;;;457      static uint16_t               prev_ep_size = 0;
;;;458      static uint8_t                prev_itf = 0;  
;;;459      USBH_Status status;
;;;460      
;;;461      
;;;462      pdesc   = (USBH_DescHeader_t *)buf;
;;;463      
;;;464      /* Parse configuration descriptor */
;;;465      cfg_desc->bLength             = *(uint8_t  *) (buf + 0);
00000e  7818              LDRB     r0,[r3,#0]
000010  7038              STRB     r0,[r7,#0]
;;;466      cfg_desc->bDescriptorType     = *(uint8_t  *) (buf + 1);
000012  7858              LDRB     r0,[r3,#1]
000014  7078              STRB     r0,[r7,#1]
;;;467      cfg_desc->wTotalLength        = LE16 (buf + 2);
000016  7898              LDRB     r0,[r3,#2]
000018  78da              LDRB     r2,[r3,#3]
00001a  eb002002          ADD      r0,r0,r2,LSL #8
00001e  8078              STRH     r0,[r7,#2]
;;;468      cfg_desc->bNumInterfaces      = *(uint8_t  *) (buf + 4);
000020  7918              LDRB     r0,[r3,#4]
000022  7138              STRB     r0,[r7,#4]
;;;469      cfg_desc->bConfigurationValue = *(uint8_t  *) (buf + 5);
000024  795a              LDRB     r2,[r3,#5]
000026  717a              STRB     r2,[r7,#5]
;;;470      cfg_desc->iConfiguration      = *(uint8_t  *) (buf + 6);
000028  799a              LDRB     r2,[r3,#6]
00002a  71ba              STRB     r2,[r7,#6]
;;;471      cfg_desc->bmAttributes        = *(uint8_t  *) (buf + 7);
00002c  79da              LDRB     r2,[r3,#7]
00002e  71fa              STRB     r2,[r7,#7]
;;;472      cfg_desc->bMaxPower           = *(uint8_t  *) (buf + 8);    
000030  7a1a              LDRB     r2,[r3,#8]
000032  723a              STRB     r2,[r7,#8]
;;;473      
;;;474      
;;;475      if (length > USB_CONFIGURATION_DESC_SIZE)
000034  2909              CMP      r1,#9
000036  d961              BLS      |L8.252|
;;;476      {
;;;477        ptr = USB_LEN_CFG_DESC;
000038  2109              MOVS     r1,#9
00003a  9101              STR      r1,[sp,#4]
;;;478        
;;;479        if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
00003c  2802              CMP      r0,#2
00003e  d863              BHI      |L8.264|
;;;480        {
;;;481          pif = (USBH_InterfaceDesc_TypeDef *)0;
;;;482          while (ptr < cfg_desc->wTotalLength ) 
;;;483          {
;;;484            pdesc = USBH_GetNextDesc((uint8_t *)pdesc, &ptr);
;;;485            if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
;;;486            {
;;;487              if_ix             = *(((uint8_t *)pdesc ) + 2);
;;;488              pif               = &itf_desc[if_ix];
;;;489              if((*((uint8_t *)pdesc + 3)) < 3)
;;;490              {
;;;491                USBH_ParseInterfaceDesc (&temp_pif, (uint8_t *)pdesc);            
;;;492                ep_ix = 0;
;;;493                
;;;494                /* Parse Ep descriptors relative to the current interface */
;;;495                if(temp_pif.bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
;;;496                {          
;;;497                  while (ep_ix < temp_pif.bNumEndpoints) 
;;;498                  {
;;;499                    pdesc = USBH_GetNextDesc((void* )pdesc, &ptr);
;;;500                    if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
;;;501                    {  
;;;502                      pep               = &ep_desc[if_ix][ep_ix];
;;;503                      if(prev_itf != if_ix)
000040  f8df90c8          LDR      r9,|L8.268|
000044  e050              B        |L8.232|
                  |L8.70|
000046  a901              ADD      r1,sp,#4              ;484
000048  4620              MOV      r0,r4                 ;484
00004a  f7fffffe          BL       USBH_GetNextDesc
00004e  4604              MOV      r4,r0                 ;484
000050  7860              LDRB     r0,[r4,#1]            ;485
000052  2804              CMP      r0,#4                 ;485
000054  d148              BNE      |L8.232|
000056  f9946002          LDRSB    r6,[r4,#2]            ;487
00005a  9806              LDR      r0,[sp,#0x18]         ;488
00005c  eb0601c6          ADD      r1,r6,r6,LSL #3       ;488
000060  eb010a00          ADD      r10,r1,r0             ;488
000064  78e0              LDRB     r0,[r4,#3]            ;489
000066  2803              CMP      r0,#3                 ;489
000068  d23e              BCS      |L8.232|
00006a  4621              MOV      r1,r4                 ;491
00006c  a802              ADD      r0,sp,#8              ;491
00006e  f7fffffe          BL       USBH_ParseInterfaceDesc
000072  2500              MOVS     r5,#0                 ;492
000074  f89d000c          LDRB     r0,[sp,#0xc]          ;495
000078  2803              CMP      r0,#3                 ;495
00007a  d931              BLS      |L8.224|
00007c  e042              B        |L8.260|
                  |L8.126|
00007e  a901              ADD      r1,sp,#4              ;499
000080  4620              MOV      r0,r4                 ;499
000082  f7fffffe          BL       USBH_GetNextDesc
000086  4604              MOV      r4,r0                 ;499
000088  7860              LDRB     r0,[r4,#1]            ;500
00008a  2805              CMP      r0,#5                 ;500
00008c  d128              BNE      |L8.224|
00008e  eb060046          ADD      r0,r6,r6,LSL #1       ;502
000092  eb0800c0          ADD      r0,r8,r0,LSL #3       ;502
000096  eb000bc5          ADD      r11,r0,r5,LSL #3      ;502
00009a  f8990000          LDRB     r0,[r9,#0]  ; prev_itf
00009e  42b0              CMP      r0,r6
0000a0  d006              BEQ      |L8.176|
;;;504                      {
;;;505                        prev_itf = if_ix;
0000a2  f8896000          STRB     r6,[r9,#0]
;;;506                        USBH_ParseInterfaceDesc (pif, (uint8_t *)&temp_pif); 
0000a6  a902              ADD      r1,sp,#8
0000a8  4650              MOV      r0,r10
0000aa  f7fffffe          BL       USBH_ParseInterfaceDesc
0000ae  e00b              B        |L8.200|
                  |L8.176|
;;;507                      }
;;;508                      else
;;;509                      {
;;;510                        if(prev_ep_size > LE16((uint8_t *)pdesc + 4))
0000b0  7920              LDRB     r0,[r4,#4]
0000b2  7961              LDRB     r1,[r4,#5]
0000b4  eb002001          ADD      r0,r0,r1,LSL #8
0000b8  f8b91002          LDRH     r1,[r9,#2]  ; prev_ep_size
0000bc  4288              CMP      r0,r1
0000be  d313              BCC      |L8.232|
;;;511                        {
;;;512                          break;
;;;513                        }
;;;514                        else
;;;515                        {
;;;516                          USBH_ParseInterfaceDesc (pif, (uint8_t *)&temp_pif);    
0000c0  a902              ADD      r1,sp,#8
0000c2  4650              MOV      r0,r10
0000c4  f7fffffe          BL       USBH_ParseInterfaceDesc
                  |L8.200|
;;;517                        }
;;;518                      }
;;;519                      USBH_ParseEPDesc (pep, (uint8_t *)pdesc);
0000c8  4621              MOV      r1,r4
0000ca  4658              MOV      r0,r11
0000cc  f7fffffe          BL       USBH_ParseEPDesc
;;;520                      prev_ep_size = LE16((uint8_t *)pdesc + 4);
0000d0  7920              LDRB     r0,[r4,#4]
0000d2  7961              LDRB     r1,[r4,#5]
0000d4  eb002001          ADD      r0,r0,r1,LSL #8
0000d8  f8a90002          STRH     r0,[r9,#2]
;;;521                      ep_ix++;
0000dc  1c6d              ADDS     r5,r5,#1
0000de  b26d              SXTB     r5,r5
                  |L8.224|
0000e0  f89d000c          LDRB     r0,[sp,#0xc]          ;497
0000e4  42a8              CMP      r0,r5                 ;497
0000e6  dcca              BGT      |L8.126|
                  |L8.232|
0000e8  8878              LDRH     r0,[r7,#2]            ;482
0000ea  f8bd1004          LDRH     r1,[sp,#4]            ;482
0000ee  4288              CMP      r0,r1                 ;482
0000f0  d8a9              BHI      |L8.70|
;;;522                    }
;;;523                  }
;;;524                }
;;;525                else /*num endpoints exceeded */
;;;526                {
;;;527                  status = USBH_NOT_SUPPORTED;
;;;528                  return status;
;;;529                } 
;;;530              }
;;;531            }
;;;532          }
;;;533        }
;;;534        else /*num interfaces exceeded */
;;;535        {
;;;536          status = USBH_NOT_SUPPORTED;
;;;537          return status;
;;;538        } 
;;;539        prev_ep_size = 0;
0000f2  2000              MOVS     r0,#0
0000f4  f8a90002          STRH     r0,[r9,#2]
;;;540        prev_itf = 0; 
0000f8  f8890000          STRB     r0,[r9,#0]
                  |L8.252|
;;;541      }
;;;542      return USBH_OK ;
0000fc  2000              MOVS     r0,#0
                  |L8.254|
;;;543    }
0000fe  b009              ADD      sp,sp,#0x24
000100  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.260|
000104  2003              MOVS     r0,#3                 ;527
000106  e7fa              B        |L8.254|
                  |L8.264|
000108  2003              MOVS     r0,#3                 ;536
00010a  e7f8              B        |L8.254|
;;;544    
                          ENDP

                  |L8.268|
                          DCD      ||.data||

                          AREA ||i.USBH_ParseDevDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseDevDesc PROC
;;;408    */
;;;409    static void  USBH_ParseDevDesc (USBH_DevDesc_TypeDef* dev_desc,
000000  b510              PUSH     {r4,lr}
;;;410                                    uint8_t *buf, 
;;;411                                    uint16_t length)
;;;412    {
;;;413      dev_desc->bLength            = *(uint8_t  *) (buf +  0);
000002  780b              LDRB     r3,[r1,#0]
000004  7003              STRB     r3,[r0,#0]
;;;414      dev_desc->bDescriptorType    = *(uint8_t  *) (buf +  1);
000006  784b              LDRB     r3,[r1,#1]
000008  7043              STRB     r3,[r0,#1]
;;;415      dev_desc->bcdUSB             = LE16 (buf +  2);
00000a  788b              LDRB     r3,[r1,#2]
00000c  78cc              LDRB     r4,[r1,#3]
00000e  eb032304          ADD      r3,r3,r4,LSL #8
000012  8043              STRH     r3,[r0,#2]
;;;416      dev_desc->bDeviceClass       = *(uint8_t  *) (buf +  4);
000014  790b              LDRB     r3,[r1,#4]
000016  7103              STRB     r3,[r0,#4]
;;;417      dev_desc->bDeviceSubClass    = *(uint8_t  *) (buf +  5);
000018  794b              LDRB     r3,[r1,#5]
00001a  7143              STRB     r3,[r0,#5]
;;;418      dev_desc->bDeviceProtocol    = *(uint8_t  *) (buf +  6);
00001c  798b              LDRB     r3,[r1,#6]
00001e  7183              STRB     r3,[r0,#6]
;;;419      dev_desc->bMaxPacketSize     = *(uint8_t  *) (buf +  7);
000020  79cb              LDRB     r3,[r1,#7]
000022  71c3              STRB     r3,[r0,#7]
;;;420      
;;;421      if (length > 8)
000024  2a08              CMP      r2,#8
000026  d916              BLS      |L9.86|
;;;422      { /* For 1st time after device connection, Host may issue only 8 bytes for 
;;;423        Device Descriptor Length  */
;;;424        dev_desc->idVendor           = LE16 (buf +  8);
000028  7a0a              LDRB     r2,[r1,#8]
00002a  7a4b              LDRB     r3,[r1,#9]
00002c  eb022203          ADD      r2,r2,r3,LSL #8
000030  8102              STRH     r2,[r0,#8]
;;;425        dev_desc->idProduct          = LE16 (buf + 10);
000032  7a8a              LDRB     r2,[r1,#0xa]
000034  7acb              LDRB     r3,[r1,#0xb]
000036  eb022203          ADD      r2,r2,r3,LSL #8
00003a  8142              STRH     r2,[r0,#0xa]
;;;426        dev_desc->bcdDevice          = LE16 (buf + 12);
00003c  7b0a              LDRB     r2,[r1,#0xc]
00003e  7b4b              LDRB     r3,[r1,#0xd]
000040  eb022203          ADD      r2,r2,r3,LSL #8
000044  8182              STRH     r2,[r0,#0xc]
;;;427        dev_desc->iManufacturer      = *(uint8_t  *) (buf + 14);
000046  7b8a              LDRB     r2,[r1,#0xe]
000048  7382              STRB     r2,[r0,#0xe]
;;;428        dev_desc->iProduct           = *(uint8_t  *) (buf + 15);
00004a  7bca              LDRB     r2,[r1,#0xf]
00004c  73c2              STRB     r2,[r0,#0xf]
;;;429        dev_desc->iSerialNumber      = *(uint8_t  *) (buf + 16);
00004e  7c0a              LDRB     r2,[r1,#0x10]
000050  7402              STRB     r2,[r0,#0x10]
;;;430        dev_desc->bNumConfigurations = *(uint8_t  *) (buf + 17);
000052  7c49              LDRB     r1,[r1,#0x11]
000054  7441              STRB     r1,[r0,#0x11]
                  |L9.86|
;;;431      }
;;;432    }
000056  bd10              POP      {r4,pc}
;;;433    
                          ENDP


                          AREA ||i.USBH_ParseEPDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseEPDesc PROC
;;;573    */
;;;574    static void  USBH_ParseEPDesc (USBH_EpDesc_TypeDef  *ep_descriptor, 
000000  780a              LDRB     r2,[r1,#0]
;;;575                                   uint8_t *buf)
;;;576    {
;;;577      
;;;578      ep_descriptor->bLength          = *(uint8_t  *) (buf + 0);
000002  7002              STRB     r2,[r0,#0]
;;;579      ep_descriptor->bDescriptorType  = *(uint8_t  *) (buf + 1);
000004  784a              LDRB     r2,[r1,#1]
000006  7042              STRB     r2,[r0,#1]
;;;580      ep_descriptor->bEndpointAddress = *(uint8_t  *) (buf + 2);
000008  788a              LDRB     r2,[r1,#2]
00000a  7082              STRB     r2,[r0,#2]
;;;581      ep_descriptor->bmAttributes     = *(uint8_t  *) (buf + 3);
00000c  78ca              LDRB     r2,[r1,#3]
00000e  70c2              STRB     r2,[r0,#3]
;;;582      ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
000010  790a              LDRB     r2,[r1,#4]
000012  794b              LDRB     r3,[r1,#5]
000014  eb022203          ADD      r2,r2,r3,LSL #8
000018  8082              STRH     r2,[r0,#4]
;;;583      ep_descriptor->bInterval        = *(uint8_t  *) (buf + 6);
00001a  7989              LDRB     r1,[r1,#6]
00001c  7181              STRB     r1,[r0,#6]
;;;584    }
00001e  4770              BX       lr
;;;585    
                          ENDP


                          AREA ||i.USBH_ParseInterfaceDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseInterfaceDesc PROC
;;;552    */
;;;553    static void  USBH_ParseInterfaceDesc (USBH_InterfaceDesc_TypeDef *if_descriptor, 
000000  780a              LDRB     r2,[r1,#0]
;;;554                                          uint8_t *buf)
;;;555    {
;;;556      if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
000002  7002              STRB     r2,[r0,#0]
;;;557      if_descriptor->bDescriptorType    = *(uint8_t  *) (buf + 1);
000004  784a              LDRB     r2,[r1,#1]
000006  7042              STRB     r2,[r0,#1]
;;;558      if_descriptor->bInterfaceNumber   = *(uint8_t  *) (buf + 2);
000008  788a              LDRB     r2,[r1,#2]
00000a  7082              STRB     r2,[r0,#2]
;;;559      if_descriptor->bAlternateSetting  = *(uint8_t  *) (buf + 3);
00000c  78ca              LDRB     r2,[r1,#3]
00000e  70c2              STRB     r2,[r0,#3]
;;;560      if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
000010  790a              LDRB     r2,[r1,#4]
000012  7102              STRB     r2,[r0,#4]
;;;561      if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
000014  794a              LDRB     r2,[r1,#5]
000016  7142              STRB     r2,[r0,#5]
;;;562      if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
000018  798a              LDRB     r2,[r1,#6]
00001a  7182              STRB     r2,[r0,#6]
;;;563      if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
00001c  79ca              LDRB     r2,[r1,#7]
00001e  71c2              STRB     r2,[r0,#7]
;;;564      if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
000020  7a09              LDRB     r1,[r1,#8]
000022  7201              STRB     r1,[r0,#8]
;;;565    }
000024  4770              BX       lr
;;;566    
                          ENDP


                          AREA ||i.USBH_ParseStringDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseStringDesc PROC
;;;593    */
;;;594    static void USBH_ParseStringDesc (uint8_t* psrc, 
000000  b510              PUSH     {r4,lr}
;;;595                                      uint8_t* pdest, 
;;;596                                      uint16_t length)
;;;597    {
;;;598      uint16_t strlength;
;;;599      uint16_t idx;
;;;600      
;;;601      /* The UNICODE string descriptor is not NULL-terminated. The string length is
;;;602      computed by subtracting two from the value of the first byte of the descriptor.
;;;603      */
;;;604      
;;;605      /* Check which is lower size, the Size of string or the length of bytes read 
;;;606      from the device */
;;;607      
;;;608      if ( psrc[1] == USB_DESC_TYPE_STRING)
000002  7843              LDRB     r3,[r0,#1]
000004  2b03              CMP      r3,#3
000006  d111              BNE      |L12.44|
;;;609      { /* Make sure the Descriptor is String Type */
;;;610        
;;;611        /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */      
;;;612        strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
000008  7803              LDRB     r3,[r0,#0]
00000a  1e9c              SUBS     r4,r3,#2
00000c  4294              CMP      r4,r2
00000e  dc00              BGT      |L12.18|
000010  1e9a              SUBS     r2,r3,#2
                  |L12.18|
000012  b293              UXTH     r3,r2
;;;613        psrc += 2; /* Adjust the offset ignoring the String Len and Descriptor type */
000014  1c80              ADDS     r0,r0,#2
;;;614        
;;;615        for (idx = 0; idx < strlength; idx+=2 )
000016  2200              MOVS     r2,#0
000018  e004              B        |L12.36|
                  |L12.26|
;;;616        {/* Copy Only the string and ignore the UNICODE ID, hence add the src */
;;;617          *pdest =  psrc[idx];
00001a  5c84              LDRB     r4,[r0,r2]
00001c  f8014b01          STRB     r4,[r1],#1
000020  1c92              ADDS     r2,r2,#2              ;615
000022  b292              UXTH     r2,r2                 ;615
                  |L12.36|
000024  429a              CMP      r2,r3                 ;615
000026  d3f8              BCC      |L12.26|
;;;618          pdest++;
;;;619        }  
;;;620        *pdest = 0; /* mark end of string */  
000028  2000              MOVS     r0,#0
00002a  7008              STRB     r0,[r1,#0]
                  |L12.44|
;;;621      }
;;;622    }
00002c  bd10              POP      {r4,pc}
;;;623    
                          ENDP


                          AREA ||i.USBH_SetAddress||, CODE, READONLY, ALIGN=1

                  USBH_SetAddress PROC
;;;259    */
;;;260    USBH_Status USBH_SetAddress(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;261                                USBH_HOST *phost,
;;;262                                uint8_t DeviceAddress)
;;;263    {
;;;264      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
000002  2300              MOVS     r3,#0
000004  750b              STRB     r3,[r1,#0x14]
;;;265        USB_REQ_TYPE_STANDARD;
;;;266      
;;;267      phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
000006  2405              MOVS     r4,#5
000008  754c              STRB     r4,[r1,#0x15]
;;;268      
;;;269      phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
00000a  82ca              STRH     r2,[r1,#0x16]
;;;270      phost->Control.setup.b.wIndex.w = 0;
00000c  830b              STRH     r3,[r1,#0x18]
;;;271      phost->Control.setup.b.wLength.w = 0;
00000e  834b              STRH     r3,[r1,#0x1a]
;;;272      
;;;273      return USBH_CtlReq(pdev, phost, 0 , 0 );
000010  bc30              POP      {r4,r5}
000012  461a              MOV      r2,r3
000014  f7ffbffe          B.W      USBH_CtlReq
;;;274    }
;;;275    
                          ENDP


                          AREA ||i.USBH_SetCfg||, CODE, READONLY, ALIGN=1

                  USBH_SetCfg PROC
;;;282    */
;;;283    USBH_Status USBH_SetCfg(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;284                            USBH_HOST *phost,
;;;285                            uint16_t cfg_idx)
;;;286    {
;;;287      
;;;288      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
000002  2300              MOVS     r3,#0
000004  750b              STRB     r3,[r1,#0x14]
;;;289        USB_REQ_TYPE_STANDARD;
;;;290      phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
000006  2409              MOVS     r4,#9
000008  754c              STRB     r4,[r1,#0x15]
;;;291      phost->Control.setup.b.wValue.w = cfg_idx;
00000a  82ca              STRH     r2,[r1,#0x16]
;;;292      phost->Control.setup.b.wIndex.w = 0;
00000c  830b              STRH     r3,[r1,#0x18]
;;;293      phost->Control.setup.b.wLength.w = 0;           
00000e  834b              STRH     r3,[r1,#0x1a]
;;;294      
;;;295      return USBH_CtlReq(pdev, phost, 0 , 0 );      
000010  bc30              POP      {r4,r5}
000012  461a              MOV      r2,r3
000014  f7ffbffe          B.W      USBH_CtlReq
;;;296    }
;;;297    
                          ENDP


                          AREA ||i.USBH_SetDeviceFeature||, CODE, READONLY, ALIGN=1

                  USBH_SetDeviceFeature PROC
;;;326    */
;;;327    USBH_Status USBH_SetDeviceFeature(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;328                                      USBH_HOST *phost,
;;;329                                      uint8_t FeatureSelector, uint16_t wIndex)
;;;330    {
;;;331      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
000002  2400              MOVS     r4,#0
000004  750c              STRB     r4,[r1,#0x14]
;;;332        USB_REQ_TYPE_STANDARD;
;;;333      
;;;334      phost->Control.setup.b.bRequest = USB_REQ_SET_FEATURE;
000006  2503              MOVS     r5,#3
000008  754d              STRB     r5,[r1,#0x15]
;;;335      phost->Control.setup.b.wValue.w = FeatureSelector;
00000a  82ca              STRH     r2,[r1,#0x16]
;;;336      phost->Control.setup.b.wIndex.w = wIndex;
00000c  830b              STRH     r3,[r1,#0x18]
;;;337      phost->Control.setup.b.wLength.w = 0;           
00000e  834c              STRH     r4,[r1,#0x1a]
;;;338      
;;;339      return USBH_CtlReq(pdev, phost, 0 , 0 );     
000010  2300              MOVS     r3,#0
000012  bc30              POP      {r4,r5}
000014  461a              MOV      r2,r3
000016  f7ffbffe          B.W      USBH_CtlReq
;;;340    }
;;;341    
                          ENDP


                          AREA ||i.USBH_SetInterface||, CODE, READONLY, ALIGN=1

                  USBH_SetInterface PROC
;;;304    */
;;;305    USBH_Status USBH_SetInterface(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;306                            USBH_HOST *phost,
;;;307                            uint8_t ep_num, uint8_t altSetting)
;;;308    {
;;;309      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_INTERFACE | \
000002  2401              MOVS     r4,#1
000004  750c              STRB     r4,[r1,#0x14]
;;;310        USB_REQ_TYPE_STANDARD;
;;;311      
;;;312      phost->Control.setup.b.bRequest = USB_REQ_SET_INTERFACE;
000006  240b              MOVS     r4,#0xb
000008  754c              STRB     r4,[r1,#0x15]
;;;313      phost->Control.setup.b.wValue.w = altSetting;
00000a  82cb              STRH     r3,[r1,#0x16]
;;;314      phost->Control.setup.b.wIndex.w = ep_num;
00000c  830a              STRH     r2,[r1,#0x18]
;;;315      phost->Control.setup.b.wLength.w = 0;           
00000e  2200              MOVS     r2,#0
000010  834a              STRH     r2,[r1,#0x1a]
;;;316      
;;;317      return USBH_CtlReq(pdev, phost, 0 , 0 );     
000012  2300              MOVS     r3,#0
000014  bc30              POP      {r4,r5}
000016  461a              MOV      r2,r3
000018  f7ffbffe          B.W      USBH_CtlReq
;;;318    }
;;;319    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USBH_CfgDesc
                          %        512

                          AREA ||.data||, DATA, ALIGN=1

                  prev_itf
000000  0000              DCB      0x00,0x00
                  prev_ep_size
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32_USB_HOST_Library\\Core\\src\\usbh_stdreq.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_usbh_stdreq_c_3531d2fa____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_usbh_stdreq_c_3531d2fa____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_usbh_stdreq_c_3531d2fa____REVSH|
#line 144
|__asm___13_usbh_stdreq_c_3531d2fa____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
