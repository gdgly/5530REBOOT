; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\usbh_msc_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\usbh_msc_core.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\Libraries\STM32_USB_OTG_Driver\inc -I..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\User\usbh_mass_storage -I..\User\fatfs\src -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY -DSTM32F40XX --omf_browse=..\output\usbh_msc_core.crf --no_multibyte_chars ..\Libraries\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_core.c]
                          THUMB

                          AREA ||i.USBH_MSC_ClassRequest||, CODE, READONLY, ALIGN=2

                  USBH_MSC_ClassRequest PROC
;;;309    
;;;310    static USBH_Status USBH_MSC_ClassRequest(USB_OTG_CORE_HANDLE *pdev , 
000000  4901              LDR      r1,|L1.8|
;;;311                                            void *phost)
;;;312    {   
;;;313      
;;;314      USBH_Status status = USBH_OK ;
;;;315      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_INIT_STATE;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;316      
;;;317      return status; 
;;;318    }
000006  4770              BX       lr
;;;319    
                          ENDP

                  |L1.8|
                          DCD      USBH_MSC_BOTXferParam

                          AREA ||i.USBH_MSC_ErrorHandle||, CODE, READONLY, ALIGN=2

                  USBH_MSC_ErrorHandle PROC
;;;518    
;;;519    void USBH_MSC_ErrorHandle(uint8_t status)
000000  490a              LDR      r1,|L2.44|
;;;520    {  
;;;521        if(status == USBH_MSC_FAIL)
;;;522        { 
;;;523          MSCErrorCount++;
;;;524          if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
;;;525          { /* Try MSC level error recovery, Issue the request Sense to get 
;;;526            Drive error reason  */
;;;527            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
;;;528            USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
;;;529          }
;;;530          else
;;;531          {
;;;532            /* Error trials exceeded the limit, go to unrecovered state */
;;;533            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
000002  220a              MOVS     r2,#0xa
000004  2801              CMP      r0,#1                 ;521
000006  d003              BEQ      |L2.16|
;;;534          }
;;;535        } 
;;;536        else if(status == USBH_MSC_PHASE_ERROR)
000008  2802              CMP      r0,#2
00000a  d100              BNE      |L2.14|
;;;537        {
;;;538          /* Phase error, Go to Unrecovered state */
;;;539          USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
00000c  700a              STRB     r2,[r1,#0]
                  |L2.14|
;;;540        }
;;;541        else if(status == USBH_MSC_BUSY)
;;;542        {
;;;543          /*No change in state*/
;;;544        }
;;;545    }
00000e  4770              BX       lr
                  |L2.16|
000010  4b07              LDR      r3,|L2.48|
000012  7818              LDRB     r0,[r3,#0]            ;523  ; MSCErrorCount
000014  1c40              ADDS     r0,r0,#1              ;523
000016  b2c0              UXTB     r0,r0                 ;523
000018  7018              STRB     r0,[r3,#0]            ;523
00001a  280a              CMP      r0,#0xa               ;524
00001c  d204              BCS      |L2.40|
00001e  2006              MOVS     r0,#6                 ;527
000020  7008              STRB     r0,[r1,#0]            ;527
000022  2001              MOVS     r0,#1                 ;528
000024  70c8              STRB     r0,[r1,#3]            ;528
000026  4770              BX       lr
                  |L2.40|
000028  700a              STRB     r2,[r1,#0]            ;533
00002a  4770              BX       lr
;;;546    
                          ENDP

                  |L2.44|
                          DCD      USBH_MSC_BOTXferParam
                  |L2.48|
                          DCD      ||.data||

                          AREA ||i.USBH_MSC_GETMaxLUN||, CODE, READONLY, ALIGN=2

                  USBH_MSC_GETMaxLUN PROC
;;;497      */
;;;498    static USBH_Status USBH_MSC_GETMaxLUN(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
000000  22a1              MOVS     r2,#0xa1
;;;499    {
;;;500      phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
000002  750a              STRB     r2,[r1,#0x14]
;;;501                                  USB_REQ_RECIPIENT_INTERFACE;
;;;502      
;;;503      phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
000004  22fe              MOVS     r2,#0xfe
000006  754a              STRB     r2,[r1,#0x15]
;;;504      phost->Control.setup.b.wValue.w = 0;
000008  2200              MOVS     r2,#0
00000a  82ca              STRH     r2,[r1,#0x16]
;;;505      phost->Control.setup.b.wIndex.w = 0;
00000c  830a              STRH     r2,[r1,#0x18]
;;;506      phost->Control.setup.b.wLength.w = 1;           
00000e  2201              MOVS     r2,#1
000010  834a              STRH     r2,[r1,#0x1a]
;;;507      
;;;508      return USBH_CtlReq(pdev, phost, MSC_Machine.buff , 1 ); 
000012  2301              MOVS     r3,#1
000014  4a01              LDR      r2,|L3.28|
000016  f7ffbffe          B.W      USBH_CtlReq
;;;509    }
;;;510    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      ||.bss||+0x8

                          AREA ||i.USBH_MSC_Handle||, CODE, READONLY, ALIGN=2

                  USBH_MSC_Handle PROC
;;;328    
;;;329    static USBH_Status USBH_MSC_Handle(USB_OTG_CORE_HANDLE *pdev ,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;330                                       void   *phost)
;;;331    {
000004  4683              MOV      r11,r0
000006  460e              MOV      r6,r1
;;;332      USBH_HOST *pphost = phost;
;;;333        
;;;334      USBH_Status status = USBH_BUSY;
000008  2401              MOVS     r4,#1
;;;335      uint8_t mscStatus = USBH_MSC_BUSY;
;;;336      uint8_t appliStatus = 0;
;;;337      
;;;338     
;;;339      static uint8_t maxLunExceed = FALSE;
;;;340        
;;;341      if(HCD_IsDeviceConnected(pdev))
00000a  4658              MOV      r0,r11
00000c  f7fffffe          BL       HCD_IsDeviceConnected
000010  2800              CMP      r0,#0
000012  d017              BEQ      |L4.68|
;;;342      {   
;;;343        switch(USBH_MSC_BOTXferParam.MSCState)
000014  4d47              LDR      r5,|L4.308|
;;;344        {
;;;345        case USBH_MSC_BOT_INIT_STATE:
;;;346          USBH_MSC_Init(pdev);
;;;347          USBH_MSC_BOTXferParam.MSCState = USBH_MSC_GET_MAX_LUN;  
;;;348          break;
;;;349          
;;;350          
;;;351        case USBH_MSC_GET_MAX_LUN:
;;;352          /* Issue GetMaxLUN request */
;;;353          status = USBH_MSC_GETMaxLUN(pdev, phost);
;;;354          
;;;355          if(status == USBH_OK )
;;;356          {
;;;357            MSC_Machine.maxLun = *(MSC_Machine.buff) ;
000016  f8dfa120          LDR      r10,|L4.312|
;;;358            
;;;359            /* If device has more that one logical unit then it is not supported */
;;;360            if((MSC_Machine.maxLun > 0) && (maxLunExceed == FALSE))
00001a  4f48              LDR      r7,|L4.316|
00001c  7828              LDRB     r0,[r5,#0]            ;343  ; USBH_MSC_BOTXferParam
00001e  f04f0800          MOV      r8,#0                 ;343
000022  f04f0908          MOV      r9,#8                 ;343
000026  280b              CMP      r0,#0xb               ;343
000028  d27c              BCS      |L4.292|
00002a  e8dff000          TBB      [pc,r0]               ;343
00002e  067b              DCB      0x06,0x7b
000030  0c394653          DCB      0x0c,0x39,0x46,0x53
000034  7560652b          DCB      0x75,0x60,0x65,0x2b
000038  7300              DCB      0x73,0x00
00003a  4658              MOV      r0,r11                ;346
00003c  f7fffffe          BL       USBH_MSC_Init
000040  2002              MOVS     r0,#2                 ;347
000042  7028              STRB     r0,[r5,#0]            ;347
                  |L4.68|
000044  e06e              B        |L4.292|
000046  4631              MOV      r1,r6                 ;353
000048  4658              MOV      r0,r11                ;353
00004a  f7fffffe          BL       USBH_MSC_GETMaxLUN
00004e  4604              MOV      r4,r0                 ;353
000050  0020              MOVS     r0,r4                 ;355
000052  f04f0103          MOV      r1,#3                 ;335
000056  d107              BNE      |L4.104|
000058  f89a0008          LDRB     r0,[r10,#8]           ;357  ; MSC_Machine
00005c  f88a0208          STRB     r0,[r10,#0x208]       ;357
000060  b108              CBZ      r0,|L4.102|
000062  7878              LDRB     r0,[r7,#1]  ; maxLunExceed
000064  b118              CBZ      r0,|L4.110|
                  |L4.102|
;;;361            {
;;;362              maxLunExceed = TRUE;
;;;363              pphost->usr_cb->DeviceNotSupported();
;;;364              
;;;365              break;
;;;366            }
;;;367            
;;;368            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_TEST_UNIT_READY;
000066  7029              STRB     r1,[r5,#0]
                  |L4.104|
;;;369          }
;;;370          
;;;371          if(status == USBH_NOT_SUPPORTED )
000068  2c03              CMP      r4,#3
00006a  d007              BEQ      |L4.124|
00006c  e05a              B        |L4.292|
                  |L4.110|
00006e  2001              MOVS     r0,#1                 ;362
000070  7078              STRB     r0,[r7,#1]            ;362
000072  f8d60090          LDR      r0,[r6,#0x90]         ;363
000076  6c00              LDR      r0,[r0,#0x40]         ;363
000078  4780              BLX      r0                    ;363
00007a  e053              B        |L4.292|
                  |L4.124|
;;;372          {
;;;373                   /* If the Command has failed, then we need to move to Next State, after
;;;374            STALL condition is cleared by Control-Transfer */
;;;375            USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_TEST_UNIT_READY;        
00007c  7069              STRB     r1,[r5,#1]
;;;376            /* a Clear Feature should be issued here */
;;;377            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
00007e  2009              MOVS     r0,#9
000080  7028              STRB     r0,[r5,#0]
000082  e04f              B        |L4.292|
;;;378          }    
;;;379          break;
;;;380          
;;;381        case USBH_MSC_CTRL_ERROR_STATE:
;;;382          /* Issue Clearfeature request */
;;;383          status = USBH_ClrFeature(pdev,
000084  7973              LDRB     r3,[r6,#5]
000086  2200              MOVS     r2,#0
000088  4631              MOV      r1,r6
00008a  4658              MOV      r0,r11
00008c  f7fffffe          BL       USBH_ClrFeature
000090  4604              MOV      r4,r0
;;;384                                   phost,
;;;385                                   0x00,
;;;386                                   pphost->Control.hc_num_out);
;;;387          if(status == USBH_OK )
000092  0020              MOVS     r0,r4
000094  d146              BNE      |L4.292|
;;;388          {
;;;389            /* If GetMaxLun Request not support, assume Single LUN configuration */
;;;390            MSC_Machine.maxLun = 0;  
000096  f88a8208          STRB     r8,[r10,#0x208]
;;;391            
;;;392            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;     
00009a  7868              LDRB     r0,[r5,#1]  ; USBH_MSC_BOTXferParam
00009c  7028              STRB     r0,[r5,#0]
00009e  e041              B        |L4.292|
;;;393          }
;;;394          break;  
;;;395          
;;;396        case USBH_MSC_TEST_UNIT_READY:
;;;397             /* Issue SCSI command TestUnitReady */ 
;;;398             mscStatus = USBH_MSC_TestUnitReady(pdev);
0000a0  4658              MOV      r0,r11
0000a2  f7fffffe          BL       USBH_MSC_TestUnitReady
;;;399    
;;;400             if(mscStatus == USBH_MSC_OK )
0000a6  b110              CBZ      r0,|L4.174|
;;;401             {
;;;402               USBH_MSC_BOTXferParam.MSCState = USBH_MSC_READ_CAPACITY10;
;;;403    MSCErrorCount = 0;
;;;404            status = USBH_OK;
;;;405          }
;;;406          else
;;;407          {
;;;408            USBH_MSC_ErrorHandle(mscStatus);
0000a8  f7fffffe          BL       USBH_MSC_ErrorHandle
0000ac  e03a              B        |L4.292|
                  |L4.174|
0000ae  2004              MOVS     r0,#4                 ;402
0000b0  7028              STRB     r0,[r5,#0]            ;402
0000b2  f8878000          STRB     r8,[r7,#0]            ;403
0000b6  2400              MOVS     r4,#0                 ;404
0000b8  e034              B        |L4.292|
;;;409          } 
;;;410          break;
;;;411          
;;;412        case USBH_MSC_READ_CAPACITY10:
;;;413          /* Issue READ_CAPACITY10 SCSI command */
;;;414          mscStatus = USBH_MSC_ReadCapacity10(pdev);
0000ba  4658              MOV      r0,r11
0000bc  f7fffffe          BL       USBH_MSC_ReadCapacity10
;;;415          if(mscStatus == USBH_MSC_OK )
0000c0  b110              CBZ      r0,|L4.200|
;;;416          {
;;;417            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_MODE_SENSE6;
;;;418            MSCErrorCount = 0;
;;;419            status = USBH_OK;
;;;420          }
;;;421          else
;;;422          {
;;;423            USBH_MSC_ErrorHandle(mscStatus);
0000c2  f7fffffe          BL       USBH_MSC_ErrorHandle
0000c6  e02d              B        |L4.292|
                  |L4.200|
0000c8  2005              MOVS     r0,#5                 ;417
0000ca  7028              STRB     r0,[r5,#0]            ;417
0000cc  f8878000          STRB     r8,[r7,#0]            ;418
0000d0  2400              MOVS     r4,#0                 ;419
0000d2  e027              B        |L4.292|
;;;424          }
;;;425          break;
;;;426    
;;;427        case USBH_MSC_MODE_SENSE6:
;;;428          /* Issue ModeSense6 SCSI command for detecting if device is write-protected */
;;;429          mscStatus = USBH_MSC_ModeSense6(pdev);
0000d4  4658              MOV      r0,r11
0000d6  f7fffffe          BL       USBH_MSC_ModeSense6
;;;430          if(mscStatus == USBH_MSC_OK )
0000da  b110              CBZ      r0,|L4.226|
;;;431          {
;;;432            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
;;;433            MSCErrorCount = 0;
;;;434            status = USBH_OK;
;;;435          }
;;;436          else
;;;437          {
;;;438            USBH_MSC_ErrorHandle(mscStatus);
0000dc  f7fffffe          BL       USBH_MSC_ErrorHandle
0000e0  e020              B        |L4.292|
                  |L4.226|
0000e2  f8859000          STRB     r9,[r5,#0]            ;432
0000e6  f8878000          STRB     r8,[r7,#0]            ;433
0000ea  2400              MOVS     r4,#0                 ;434
0000ec  e01a              B        |L4.292|
;;;439          }
;;;440          break;
;;;441           
;;;442        case USBH_MSC_BOT_USB_TRANSFERS:
;;;443          /* Process the BOT state machine */
;;;444          USBH_MSC_HandleBOTXfer(pdev,phost);
0000ee  4631              MOV      r1,r6
0000f0  4658              MOV      r0,r11
0000f2  f7fffffe          BL       USBH_MSC_HandleBOTXfer
;;;445          break;
0000f6  e015              B        |L4.292|
;;;446        
;;;447        case USBH_MSC_DEFAULT_APPLI_STATE:
;;;448          /* Process Application callback for MSC */
;;;449          appliStatus = pphost->usr_cb->UserApplication();
0000f8  f8d60090          LDR      r0,[r6,#0x90]
0000fc  6bc0              LDR      r0,[r0,#0x3c]
0000fe  4780              BLX      r0
000100  b2c0              UXTB     r0,r0
;;;450          if(appliStatus == 0)
000102  b110              CBZ      r0,|L4.266|
;;;451          {
;;;452            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
;;;453          }
;;;454          else if (appliStatus == 1) 
000104  2801              CMP      r0,#1
000106  d003              BEQ      |L4.272|
000108  e00c              B        |L4.292|
                  |L4.266|
00010a  f8859000          STRB     r9,[r5,#0]            ;452
00010e  e009              B        |L4.292|
                  |L4.272|
;;;455          {
;;;456            /* De-init requested from application layer */
;;;457            status =  USBH_APPLY_DEINIT;
000110  2406              MOVS     r4,#6
000112  e007              B        |L4.292|
;;;458          }
;;;459          break;
;;;460          
;;;461        case USBH_MSC_UNRECOVERED_STATE:
;;;462          
;;;463          status = USBH_UNRECOVERED_ERROR;
000114  2404              MOVS     r4,#4
;;;464          
;;;465          break;
000116  e005              B        |L4.292|
;;;466        
;;;467        case USBH_MSC_REQUEST_SENSE:
;;;468          /* Issue RequestSense SCSI command for retrieving error code */
;;;469          mscStatus = USBH_MSC_RequestSense(pdev);
000118  4658              MOV      r0,r11
00011a  f7fffffe          BL       USBH_MSC_RequestSense
;;;470          if(mscStatus == USBH_MSC_OK )
00011e  b120              CBZ      r0,|L4.298|
;;;471          {
;;;472            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;
;;;473            status = USBH_OK;
;;;474          }
;;;475          else
;;;476          {
;;;477            USBH_MSC_ErrorHandle(mscStatus);
000120  f7fffffe          BL       USBH_MSC_ErrorHandle
                  |L4.292|
;;;478          }  
;;;479          break;
;;;480          
;;;481        default:
;;;482          break; 
;;;483          
;;;484        }
;;;485      }
;;;486       return status;
000124  4620              MOV      r0,r4
;;;487    }
000126  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.298|
00012a  7868              LDRB     r0,[r5,#1]            ;472  ; USBH_MSC_BOTXferParam
00012c  7028              STRB     r0,[r5,#0]            ;472
00012e  2400              MOVS     r4,#0                 ;473
000130  e7f8              B        |L4.292|
;;;488    
                          ENDP

000132  0000              DCW      0x0000
                  |L4.308|
                          DCD      USBH_MSC_BOTXferParam
                  |L4.312|
                          DCD      ||.bss||
                  |L4.316|
                          DCD      ||.data||

                          AREA ||i.USBH_MSC_InterfaceDeInit||, CODE, READONLY, ALIGN=2

                  USBH_MSC_InterfaceDeInit PROC
;;;283      */
;;;284    void USBH_MSC_InterfaceDeInit ( USB_OTG_CORE_HANDLE *pdev,
000000  b570              PUSH     {r4-r6,lr}
;;;285                                    void *phost)
;;;286    {	
000002  4606              MOV      r6,r0
;;;287      if ( MSC_Machine.hc_num_out)
000004  4c0c              LDR      r4,|L5.56|
000006  2500              MOVS     r5,#0
000008  7861              LDRB     r1,[r4,#1]  ; MSC_Machine
00000a  2900              CMP      r1,#0
00000c  d007              BEQ      |L5.30|
;;;288      {
;;;289        USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_out);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       USB_OTG_HC_Halt
;;;290        USBH_Free_Channel  (pdev, MSC_Machine.hc_num_out);
000014  7861              LDRB     r1,[r4,#1]  ; MSC_Machine
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       USBH_Free_Channel
;;;291        MSC_Machine.hc_num_out = 0;     /* Reset the Channel as Free */
00001c  7065              STRB     r5,[r4,#1]
                  |L5.30|
;;;292      }
;;;293       
;;;294      if ( MSC_Machine.hc_num_in)
00001e  7821              LDRB     r1,[r4,#0]  ; MSC_Machine
000020  2900              CMP      r1,#0
000022  d007              BEQ      |L5.52|
;;;295      {
;;;296        USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_in);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       USB_OTG_HC_Halt
;;;297        USBH_Free_Channel  (pdev, MSC_Machine.hc_num_in);
00002a  7821              LDRB     r1,[r4,#0]  ; MSC_Machine
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       USBH_Free_Channel
;;;298        MSC_Machine.hc_num_in = 0;     /* Reset the Channel as Free */
000032  7025              STRB     r5,[r4,#0]
                  |L5.52|
;;;299      } 
;;;300    }
000034  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      ||.bss||

                          AREA ||i.USBH_MSC_InterfaceInit||, CODE, READONLY, ALIGN=2

                  USBH_MSC_InterfaceInit PROC
;;;172      */
;;;173    static USBH_Status USBH_MSC_InterfaceInit ( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;174                                            void *phost)
;;;175    {	 
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;176      USBH_HOST *pphost = phost;
;;;177      
;;;178      if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
000008  f8941043          LDRB     r1,[r4,#0x43]
00000c  2908              CMP      r1,#8
00000e  d103              BNE      |L6.24|
;;;179         (pphost->device_prop.Itf_Desc[0].bInterfaceProtocol == MSC_PROTOCOL))
000010  f8940045          LDRB     r0,[r4,#0x45]
000014  2850              CMP      r0,#0x50
000016  d006              BEQ      |L6.38|
                  |L6.24|
;;;180      {
;;;181        if(pphost->device_prop.Ep_Desc[0][0].bEndpointAddress & 0x80)
;;;182        {
;;;183          MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
;;;184          MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][0].wMaxPacketSize;
;;;185        }
;;;186        else
;;;187        {
;;;188          MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
;;;189          MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0] [0].wMaxPacketSize;      
;;;190        }
;;;191        
;;;192        if(pphost->device_prop.Ep_Desc[0][1].bEndpointAddress & 0x80)
;;;193        {
;;;194          MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
;;;195          MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
;;;196        }
;;;197        else
;;;198        {
;;;199          MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
;;;200          MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
;;;201        }
;;;202        
;;;203        MSC_Machine.hc_num_out = USBH_Alloc_Channel(pdev, 
;;;204                                                    MSC_Machine.MSBulkOutEp);
;;;205        MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
;;;206                                                    MSC_Machine.MSBulkInEp);  
;;;207        
;;;208        /* Open the new channels */
;;;209        USBH_Open_Channel  (pdev,
;;;210                            MSC_Machine.hc_num_out,
;;;211                            pphost->device_prop.address,
;;;212                            pphost->device_prop.speed,
;;;213                            EP_TYPE_BULK,
;;;214                            MSC_Machine.MSBulkOutEpSize);  
;;;215        
;;;216        USBH_Open_Channel  (pdev,
;;;217                            MSC_Machine.hc_num_in,
;;;218                            pphost->device_prop.address,
;;;219                            pphost->device_prop.speed,
;;;220                            EP_TYPE_BULK,
;;;221                            MSC_Machine.MSBulkInEpSize);    
;;;222        
;;;223      }
;;;224      
;;;225      else
;;;226      {
;;;227        if (pphost->device_prop.Itf_Desc[0].bInterfaceClass == USB_HUB)
;;;228        {
;;;229          LCD_ErrLog("Hub is not supported.\n");
;;;230        }
;;;231        
;;;232        else if (pphost->device_prop.Itf_Desc[0].bInterfaceClass == USB_CDCC)
;;;233        {
;;;234          LCD_ErrLog("Communications and CDC Control device is not supported.\n");
;;;235        }
;;;236        
;;;237        else if (pphost->device_prop.Itf_Desc[0].bInterfaceClass == USB_HID)
;;;238        {
;;;239          LCD_ErrLog("HID device is not supported.\n");
;;;240        }
;;;241        
;;;242        else if (pphost->device_prop.Itf_Desc[0].bInterfaceClass == USB_PRINTER)
;;;243        {
;;;244          LCD_ErrLog("Printer device is not supported.\n");
;;;245        }
;;;246        
;;;247        else if (pphost->device_prop.Itf_Desc[0].bInterfaceClass == USB_SMARTCARD)
;;;248        {
;;;249          LCD_ErrLog("Smart Card device is not supported.\n");
;;;250        }
;;;251        
;;;252        
;;;253        else if (pphost->device_prop.Itf_Desc[0].bInterfaceClass == USB_VIDEO)
;;;254        {
;;;255          LCD_ErrLog("Video device  is not supported.\n");
;;;256        }
;;;257        
;;;258        
;;;259        else if (pphost->device_prop.Itf_Desc[0].bInterfaceClass == USB_AVD)
;;;260        {
;;;261          LCD_ErrLog("Audio/Video Devices is not supported.\n");
;;;262        }
;;;263        
;;;264        else
;;;265        {
;;;266          LCD_ErrLog ("The attached device is not supported. \n");
;;;267        }
;;;268        
;;;269        pphost->usr_cb->DeviceNotSupported();
000018  f8d40090          LDR      r0,[r4,#0x90]
00001c  6c00              LDR      r0,[r0,#0x40]
00001e  4780              BLX      r0
                  |L6.32|
;;;270      }
;;;271      
;;;272      return USBH_OK ;
000020  2000              MOVS     r0,#0
;;;273     
;;;274    }
000022  e8bd81fc          POP      {r2-r8,pc}
                  |L6.38|
000026  f8941052          LDRB     r1,[r4,#0x52]         ;181
00002a  4d1c              LDR      r5,|L6.156|
00002c  0608              LSLS     r0,r1,#24             ;181
00002e  d504              BPL      |L6.58|
000030  70e9              STRB     r1,[r5,#3]            ;183
000032  f8b40054          LDRH     r0,[r4,#0x54]         ;184
000036  80a8              STRH     r0,[r5,#4]            ;184
000038  e003              B        |L6.66|
                  |L6.58|
00003a  70a9              STRB     r1,[r5,#2]            ;188
00003c  f8b40054          LDRH     r0,[r4,#0x54]         ;189
000040  80e8              STRH     r0,[r5,#6]            ;189
                  |L6.66|
000042  f894105a          LDRB     r1,[r4,#0x5a]         ;192
000046  0608              LSLS     r0,r1,#24             ;192
000048  d504              BPL      |L6.84|
00004a  70e9              STRB     r1,[r5,#3]            ;194
00004c  f8b4005c          LDRH     r0,[r4,#0x5c]         ;195
000050  80a8              STRH     r0,[r5,#4]            ;195
000052  e003              B        |L6.92|
                  |L6.84|
000054  70a9              STRB     r1,[r5,#2]            ;199
000056  f8b4005c          LDRH     r0,[r4,#0x5c]         ;200
00005a  80e8              STRH     r0,[r5,#6]            ;200
                  |L6.92|
00005c  78a9              LDRB     r1,[r5,#2]            ;203  ; MSC_Machine
00005e  4630              MOV      r0,r6                 ;203
000060  f7fffffe          BL       USBH_Alloc_Channel
000064  7068              STRB     r0,[r5,#1]            ;203
000066  78e9              LDRB     r1,[r5,#3]            ;205  ; MSC_Machine
000068  4630              MOV      r0,r6                 ;205
00006a  f7fffffe          BL       USBH_Alloc_Channel
00006e  7028              STRB     r0,[r5,#0]            ;205
000070  88e8              LDRH     r0,[r5,#6]            ;209  ; MSC_Machine
000072  2702              MOVS     r7,#2                 ;209
000074  e9cd7000          STRD     r7,r0,[sp,#0]         ;209
000078  3420              ADDS     r4,r4,#0x20           ;209
00007a  7869              LDRB     r1,[r5,#1]            ;209  ; MSC_Machine
00007c  7863              LDRB     r3,[r4,#1]            ;209
00007e  7822              LDRB     r2,[r4,#0]            ;209
000080  4630              MOV      r0,r6                 ;209
000082  f7fffffe          BL       USBH_Open_Channel
000086  88a8              LDRH     r0,[r5,#4]            ;216  ; MSC_Machine
000088  e9cd7000          STRD     r7,r0,[sp,#0]         ;216
00008c  7863              LDRB     r3,[r4,#1]            ;216
00008e  7822              LDRB     r2,[r4,#0]            ;216
000090  7829              LDRB     r1,[r5,#0]            ;216  ; MSC_Machine
000092  4630              MOV      r0,r6                 ;216
000094  f7fffffe          BL       USBH_Open_Channel
000098  e7c2              B        |L6.32|
;;;275    
                          ENDP

00009a  0000              DCW      0x0000
                  |L6.156|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  MSC_Machine
                          %        522

                          AREA ||.data||, DATA, ALIGN=0

                  MSCErrorCount
000000  00                DCB      0x00
                  maxLunExceed
000001  00                DCB      0x00

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  USBH_MSC_cb
                          DCD      USBH_MSC_InterfaceInit
                          DCD      USBH_MSC_InterfaceDeInit
                          DCD      USBH_MSC_ClassRequest
                          DCD      USBH_MSC_Handle

                          AREA ||area_number.12||, DATA, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.data||
                  MSC_Setup
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32_USB_HOST_Library\\Class\\MSC\\src\\usbh_msc_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_usbh_msc_core_c_0007fda2____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_usbh_msc_core_c_0007fda2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_usbh_msc_core_c_0007fda2____REVSH|
#line 144
|__asm___15_usbh_msc_core_c_0007fda2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
