; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\ff.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\ff.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\Libraries\STM32_USB_OTG_Driver\inc -I..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\User\usbh_mass_storage -I..\User\fatfs\src -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY -DSTM32F40XX --omf_browse=..\output\ff.crf --no_multibyte_chars ..\User\fatfs\src\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;2174   static
;;;2175   BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
000000  b510              PUSH     {r4,lr}
;;;2176   	FATFS* fs,	/* File system object */
;;;2177   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;2178   )
;;;2179   {
000002  4604              MOV      r4,r0
;;;2180   	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
000004  2000              MOVS     r0,#0
000006  7120              STRB     r0,[r4,#4]
000008  1e40              SUBS     r0,r0,#1
00000a  62e0              STR      r0,[r4,#0x2c]
;;;2181   	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       move_window
000012  b108              CBZ      r0,|L1.24|
;;;2182   		return 3;
000014  2003              MOVS     r0,#3
;;;2183   
;;;2184   	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
;;;2185   		return 2;
;;;2186   
;;;2187   	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
;;;2188   		return 0;
;;;2189   	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;;;2190   		return 0;
;;;2191   
;;;2192   	return 1;
;;;2193   }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  f894022e          LDRB     r0,[r4,#0x22e]        ;2184
00001c  f894122f          LDRB     r1,[r4,#0x22f]        ;2184
000020  ea402001          ORR      r0,r0,r1,LSL #8       ;2184
000024  f5a0412a          SUB      r1,r0,#0xaa00         ;2184
000028  3955              SUBS     r1,r1,#0x55           ;2184
00002a  d001              BEQ      |L1.48|
00002c  2002              MOVS     r0,#2                 ;2185
00002e  bd10              POP      {r4,pc}
                  |L1.48|
000030  f8140f66          LDRB     r0,[r4,#0x66]!        ;2187
000034  78e1              LDRB     r1,[r4,#3]            ;2187
000036  7862              LDRB     r2,[r4,#1]            ;2187
000038  ea406101          ORR      r1,r0,r1,LSL #24      ;2187
00003c  78a0              LDRB     r0,[r4,#2]            ;2187
00003e  3c66              SUBS     r4,r4,#0x66           ;2187
000040  0400              LSLS     r0,r0,#16             ;2187
000042  ea402002          ORR      r0,r0,r2,LSL #8       ;2187
000046  4301              ORRS     r1,r1,r0              ;2187
000048  480b              LDR      r0,|L1.120|
00004a  ebb02f01          CMP      r0,r1,LSL #8          ;2187
00004e  d101              BNE      |L1.84|
000050  2000              MOVS     r0,#0                 ;2188
000052  bd10              POP      {r4,pc}
                  |L1.84|
000054  f8141f82          LDRB     r1,[r4,#0x82]!        ;2189
000058  78e2              LDRB     r2,[r4,#3]            ;2189
00005a  7863              LDRB     r3,[r4,#1]            ;2189
00005c  ea416102          ORR      r1,r1,r2,LSL #24      ;2189
000060  78a2              LDRB     r2,[r4,#2]            ;2189
000062  0412              LSLS     r2,r2,#16             ;2189
000064  ea422203          ORR      r2,r2,r3,LSL #8       ;2189
000068  4311              ORRS     r1,r1,r2              ;2189
00006a  ebb02f01          CMP      r0,r1,LSL #8          ;2189
00006e  d101              BNE      |L1.116|
000070  2000              MOVS     r0,#0                 ;2190
000072  bd10              POP      {r4,pc}
                  |L1.116|
000074  2001              MOVS     r0,#1                 ;2192
000076  bd10              POP      {r4,pc}
;;;2194   
                          ENDP

                  |L1.120|
                          DCD      0x54414600

                          AREA ||i.chk_chr||, CODE, READONLY, ALIGN=1

                  chk_chr PROC
;;;542    static
;;;543    int chk_chr (const char* str, int chr) {
000000  e000              B        |L2.4|
                  |L2.2|
;;;544    	while (*str && *str != chr) str++;
000002  1c40              ADDS     r0,r0,#1
                  |L2.4|
000004  7802              LDRB     r2,[r0,#0]
000006  b10a              CBZ      r2,|L2.12|
000008  428a              CMP      r2,r1
00000a  d1fa              BNE      |L2.2|
                  |L2.12|
;;;545    	return *str;
00000c  7800              LDRB     r0,[r0,#0]
;;;546    }
00000e  4770              BX       lr
;;;547    
                          ENDP


                          AREA ||i.chk_lock||, CODE, READONLY, ALIGN=2

                  chk_lock PROC
;;;588    static
;;;589    FRESULT chk_lock (	/* Check if the file can be accessed */
000000  b5f0              PUSH     {r4-r7,lr}
;;;590    	DIR* dp,		/* Directory object pointing the file to be checked */
;;;591    	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
;;;592    )
;;;593    {
;;;594    	UINT i, be;
;;;595    
;;;596    	/* Search file semaphore table */
;;;597    	for (i = be = 0; i < _FS_LOCK; i++) {
000002  2200              MOVS     r2,#0
000004  4615              MOV      r5,r2
;;;598    		if (Files[i].fs) {	/* Existing entry */
000006  4e18              LDR      r6,|L3.104|
000008  e014              B        |L3.52|
                  |L3.10|
00000a  eb020342          ADD      r3,r2,r2,LSL #1
00000e  f8564023          LDR      r4,[r6,r3,LSL #2]
000012  b16c              CBZ      r4,|L3.48|
;;;599    			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
000014  6807              LDR      r7,[r0,#0]
000016  42bc              CMP      r4,r7
000018  d10b              BNE      |L3.50|
;;;600    				Files[i].clu == dp->sclust &&
00001a  eb060383          ADD      r3,r6,r3,LSL #2
00001e  6887              LDR      r7,[r0,#8]
000020  685c              LDR      r4,[r3,#4]
000022  42bc              CMP      r4,r7
000024  d105              BNE      |L3.50|
;;;601    				Files[i].idx == dp->index) break;
000026  891b              LDRH     r3,[r3,#8]
000028  88c4              LDRH     r4,[r0,#6]
00002a  42a3              CMP      r3,r4
00002c  d004              BEQ      |L3.56|
00002e  e000              B        |L3.50|
                  |L3.48|
;;;602    		} else {			/* Blank entry */
;;;603    			be = 1;
000030  2501              MOVS     r5,#1
                  |L3.50|
000032  1c52              ADDS     r2,r2,#1              ;597
                  |L3.52|
000034  2a03              CMP      r2,#3                 ;597
000036  d3e8              BCC      |L3.10|
                  |L3.56|
;;;604    		}
;;;605    	}
;;;606    	if (i == _FS_LOCK)	/* The object is not opened */
000038  2a03              CMP      r2,#3
00003a  d001              BEQ      |L3.64|
;;;607    		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
;;;608    
;;;609    	/* The object has been opened. Reject any open against writing file and all write mode open */
;;;610    	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
00003c  b989              CBNZ     r1,|L3.98|
00003e  e006              B        |L3.78|
                  |L3.64|
000040  b91d              CBNZ     r5,|L3.74|
000042  2902              CMP      r1,#2                 ;607
000044  d001              BEQ      |L3.74|
000046  2012              MOVS     r0,#0x12              ;607
;;;611    }
000048  bdf0              POP      {r4-r7,pc}
                  |L3.74|
00004a  2000              MOVS     r0,#0                 ;607
00004c  bdf0              POP      {r4-r7,pc}
                  |L3.78|
00004e  eb020042          ADD      r0,r2,r2,LSL #1       ;610
000052  eb060080          ADD      r0,r6,r0,LSL #2       ;610
000056  8940              LDRH     r0,[r0,#0xa]          ;610
000058  f5b07f80          CMP      r0,#0x100             ;610
00005c  d001              BEQ      |L3.98|
00005e  2000              MOVS     r0,#0                 ;610
000060  bdf0              POP      {r4-r7,pc}
                  |L3.98|
000062  2010              MOVS     r0,#0x10              ;610
000064  bdf0              POP      {r4-r7,pc}
;;;612    
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      ||.bss||+0xc

                          AREA ||i.clear_lock||, CODE, READONLY, ALIGN=2

                  clear_lock PROC
;;;679    static
;;;680    void clear_lock (	/* Clear lock entries of the volume */
000000  b530              PUSH     {r4,r5,lr}
;;;681    	FATFS *fs
;;;682    )
;;;683    {
;;;684    	UINT i;
;;;685    
;;;686    	for (i = 0; i < _FS_LOCK; i++) {
000002  2100              MOVS     r1,#0
;;;687    		if (Files[i].fs == fs) Files[i].fs = 0;
000004  4b06              LDR      r3,|L4.32|
000006  2400              MOVS     r4,#0                 ;686
                  |L4.8|
000008  eb010241          ADD      r2,r1,r1,LSL #1
00000c  f8535022          LDR      r5,[r3,r2,LSL #2]
000010  4285              CMP      r5,r0
000012  d101              BNE      |L4.24|
000014  f8434022          STR      r4,[r3,r2,LSL #2]
                  |L4.24|
000018  1c49              ADDS     r1,r1,#1              ;686
00001a  2903              CMP      r1,#3                 ;686
00001c  d3f4              BCC      |L4.8|
;;;688    	}
;;;689    }
00001e  bd30              POP      {r4,r5,pc}
;;;690    #endif
                          ENDP

                  |L4.32|
                          DCD      ||.bss||+0xc

                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;799    
;;;800    DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
000000  1e89              SUBS     r1,r1,#2
;;;801    	FATFS* fs,		/* File system object */
;;;802    	DWORD clst		/* Cluster# to be converted */
;;;803    )
;;;804    {
;;;805    	clst -= 2;
;;;806    	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
000002  6942              LDR      r2,[r0,#0x14]
000004  1e92              SUBS     r2,r2,#2
000006  428a              CMP      r2,r1
000008  d801              BHI      |L5.14|
00000a  2000              MOVS     r0,#0
;;;807    	return clst * fs->csize + fs->database;
;;;808    }
00000c  4770              BX       lr
                  |L5.14|
00000e  6a82              LDR      r2,[r0,#0x28]         ;807
000010  7880              LDRB     r0,[r0,#2]            ;807
000012  fb012000          MLA      r0,r1,r0,r2           ;807
000016  4770              BX       lr
;;;809    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;989    static
;;;990    DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;991    	FATFS* fs,			/* File system object */
;;;992    	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
;;;993    )
;;;994    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;995    	DWORD cs, ncl, scl;
;;;996    	FRESULT res;
;;;997    
;;;998    
;;;999    	if (clst == 0) {		/* Create a new chain */
000008  2f00              CMP      r7,#0
00000a  d008              BEQ      |L6.30|
;;;1000   		scl = fs->last_clust;			/* Get suggested start point */
;;;1001   		if (!scl || scl >= fs->n_fatent) scl = 1;
;;;1002   	}
;;;1003   	else {					/* Stretch the current chain */
;;;1004   		cs = get_fat(fs, clst);			/* Check the cluster status */
00000c  4639              MOV      r1,r7
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       get_fat
;;;1005   		if (cs < 2) return 1;			/* Invalid value */
000014  2802              CMP      r0,#2
000016  d209              BCS      |L6.44|
000018  2001              MOVS     r0,#1
                  |L6.26|
;;;1006   		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
;;;1007   		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;1008   		scl = clst;
;;;1009   	}
;;;1010   
;;;1011   	ncl = scl;				/* Start cluster */
;;;1012   	for (;;) {
;;;1013   		ncl++;							/* Next cluster */
;;;1014   		if (ncl >= fs->n_fatent) {		/* Check wrap around */
;;;1015   			ncl = 2;
;;;1016   			if (ncl > scl) return 0;	/* No free cluster */
;;;1017   		}
;;;1018   		cs = get_fat(fs, ncl);			/* Get the cluster status */
;;;1019   		if (cs == 0) break;				/* Found a free cluster */
;;;1020   		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
;;;1021   			return cs;
;;;1022   		if (ncl == scl) return 0;		/* No free cluster */
;;;1023   	}
;;;1024   
;;;1025   	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
;;;1026   	if (res == FR_OK && clst != 0) {
;;;1027   		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
;;;1028   	}
;;;1029   	if (res == FR_OK) {
;;;1030   		fs->last_clust = ncl;			/* Update FSINFO */
;;;1031   		if (fs->free_clust != 0xFFFFFFFF) {
;;;1032   			fs->free_clust--;
;;;1033   			fs->fsi_flag |= 1;
;;;1034   		}
;;;1035   	} else {
;;;1036   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
;;;1037   	}
;;;1038   
;;;1039   	return ncl;		/* Return new cluster number or error code */
;;;1040   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.30|
00001e  68f5              LDR      r5,[r6,#0xc]          ;1000
000020  b115              CBZ      r5,|L6.40|
000022  6970              LDR      r0,[r6,#0x14]         ;1001
000024  42a8              CMP      r0,r5                 ;1001
000026  d807              BHI      |L6.56|
                  |L6.40|
000028  2501              MOVS     r5,#1                 ;1001
00002a  e005              B        |L6.56|
                  |L6.44|
00002c  1c41              ADDS     r1,r0,#1              ;1006
00002e  d0f4              BEQ      |L6.26|
000030  6971              LDR      r1,[r6,#0x14]         ;1007
000032  4281              CMP      r1,r0                 ;1007
000034  d8f1              BHI      |L6.26|
000036  463d              MOV      r5,r7                 ;1008
                  |L6.56|
000038  462c              MOV      r4,r5                 ;1011
                  |L6.58|
00003a  1c64              ADDS     r4,r4,#1              ;1013
00003c  6970              LDR      r0,[r6,#0x14]         ;1014
00003e  42a0              CMP      r0,r4                 ;1014
000040  d804              BHI      |L6.76|
000042  2402              MOVS     r4,#2                 ;1015
000044  2d02              CMP      r5,#2                 ;1016
000046  d201              BCS      |L6.76|
000048  2000              MOVS     r0,#0                 ;1016
00004a  e7e6              B        |L6.26|
                  |L6.76|
00004c  4621              MOV      r1,r4                 ;1018
00004e  4630              MOV      r0,r6                 ;1018
000050  f7fffffe          BL       get_fat
000054  b138              CBZ      r0,|L6.102|
000056  1c41              ADDS     r1,r0,#1              ;1020
000058  d0df              BEQ      |L6.26|
00005a  2801              CMP      r0,#1                 ;1020
00005c  d0dd              BEQ      |L6.26|
00005e  42ac              CMP      r4,r5                 ;1022
000060  d1eb              BNE      |L6.58|
000062  2000              MOVS     r0,#0                 ;1022
000064  e7d9              B        |L6.26|
                  |L6.102|
000066  f06f4270          MVN      r2,#0xf0000000        ;1025
00006a  4621              MOV      r1,r4                 ;1025
00006c  4630              MOV      r0,r6                 ;1025
00006e  f7fffffe          BL       put_fat
000072  b928              CBNZ     r0,|L6.128|
000074  b127              CBZ      r7,|L6.128|
000076  4622              MOV      r2,r4                 ;1027
000078  4639              MOV      r1,r7                 ;1027
00007a  4630              MOV      r0,r6                 ;1027
00007c  f7fffffe          BL       put_fat
                  |L6.128|
000080  b120              CBZ      r0,|L6.140|
000082  2801              CMP      r0,#1                 ;1036
000084  d00d              BEQ      |L6.162|
000086  2401              MOVS     r4,#1                 ;1036
                  |L6.136|
000088  4620              MOV      r0,r4                 ;1039
00008a  e7c6              B        |L6.26|
                  |L6.140|
00008c  60f4              STR      r4,[r6,#0xc]          ;1030
00008e  6930              LDR      r0,[r6,#0x10]         ;1031
000090  1c41              ADDS     r1,r0,#1              ;1031
000092  d0f9              BEQ      |L6.136|
000094  1e40              SUBS     r0,r0,#1              ;1032
000096  6130              STR      r0,[r6,#0x10]         ;1032
000098  7970              LDRB     r0,[r6,#5]            ;1033
00009a  f0400001          ORR      r0,r0,#1              ;1033
00009e  7170              STRB     r0,[r6,#5]            ;1033
0000a0  e7f2              B        |L6.136|
                  |L6.162|
0000a2  f04f34ff          MOV      r4,#0xffffffff        ;1036
0000a6  e7ef              B        |L6.136|
;;;1041   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1842   static
;;;1843   FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1844   	DIR* dp,			/* Pointer to the directory object */
;;;1845   	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
;;;1846   )
;;;1847   {
000004  468b              MOV      r11,r1
;;;1848   #if _USE_LFN	/* LFN configuration */
;;;1849   	BYTE b, cf;
;;;1850   	WCHAR w, *lfn;
;;;1851   	UINT i, ni, si, di;
;;;1852   	const TCHAR *p;
;;;1853   
;;;1854   	/* Create LFN in Unicode */
;;;1855   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;;;1856   	lfn = dp->lfn;
;;;1857   	si = di = 0;
;;;1858   	for (;;) {
;;;1859   		w = p[si++];					/* Get a character */
;;;1860   		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
;;;1861   		if (di >= _MAX_LFN)				/* Reject too long name */
;;;1862   			return FR_INVALID_NAME;
;;;1863   #if !_LFN_UNICODE
;;;1864   		w &= 0xFF;
;;;1865   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1866   			b = (BYTE)p[si++];			/* Get 2nd byte */
;;;1867   			w = (w << 8) + b;			/* Create a DBC */
;;;1868   			if (!IsDBCS2(b))
;;;1869   				return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;1870   		}
;;;1871   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;;;1872   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;1873   #endif
;;;1874   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
;;;1875   			return FR_INVALID_NAME;
;;;1876   		lfn[di++] = w;					/* Store the Unicode character */
;;;1877   	}
;;;1878   	*path = &p[si];						/* Return pointer to the next segment */
;;;1879   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1880   #if _FS_RPATH
;;;1881   	if ((di == 1 && lfn[di - 1] == '.') ||
;;;1882   		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot entry? */
;;;1883   		lfn[di] = 0;
;;;1884   		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
;;;1885   			dp->fn[i] = (i < di) ? '.' : ' ';
;;;1886   		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;1887   		return FR_OK;
;;;1888   	}
;;;1889   #endif
;;;1890   	while (di) {						/* Snip off trailing spaces and dots if exist */
;;;1891   		w = lfn[di - 1];
;;;1892   		if (w != ' ' && w != '.') break;
;;;1893   		di--;
;;;1894   	}
;;;1895   	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
;;;1896   	lfn[di] = 0;						/* LFN is created */
;;;1897   
;;;1898   	/* Create SFN in directory form */
;;;1899   	mem_set(dp->fn, ' ', 11);
;;;1900   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;;;1901   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1902   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1903   
;;;1904   	b = i = 0; ni = 8;
;;;1905   	for (;;) {
;;;1906   		w = lfn[si++];					/* Get an LFN character */
;;;1907   		if (!w) break;					/* Break on end of the LFN */
;;;1908   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;1909   			cf |= NS_LOSS | NS_LFN; continue;
;;;1910   		}
;;;1911   
;;;1912   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1913   			if (ni == 11) {				/* Long extension */
;;;1914   				cf |= NS_LOSS | NS_LFN; break;
;;;1915   			}
;;;1916   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;1917   			if (si > di) break;			/* No extension */
;;;1918   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1919   			b <<= 2; continue;
;;;1920   		}
;;;1921   
;;;1922   		if (w >= 0x80) {				/* Non ASCII character */
;;;1923   #ifdef _EXCVT
;;;1924   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1925   			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
;;;1926   #else
;;;1927   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;1928   #endif
;;;1929   			cf |= NS_LFN;				/* Force create LFN entry */
;;;1930   		}
;;;1931   
;;;1932   		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
;;;1933   			if (i >= ni - 1) {
;;;1934   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;1935   			}
;;;1936   			dp->fn[i++] = (BYTE)(w >> 8);
;;;1937   		} else {						/* SBC */
;;;1938   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
;;;1939   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;1940   			} else {
;;;1941   				if (IsUpper(w)) {		/* ASCII large capital */
;;;1942   					b |= 2;
;;;1943   				} else {
;;;1944   					if (IsLower(w)) {	/* ASCII small capital */
;;;1945   						b |= 1; w -= 0x20;
;;;1946   					}
;;;1947   				}
;;;1948   			}
;;;1949   		}
;;;1950   		dp->fn[i++] = (BYTE)w;
;;;1951   	}
;;;1952   
;;;1953   	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
;;;1954   
;;;1955   	if (ni == 8) b <<= 2;
;;;1956   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;1957   		cf |= NS_LFN;
;;;1958   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
;;;1959   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1960   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1961   	}
;;;1962   
;;;1963   	dp->fn[NSFLAG] = cf;	/* SFN is created */
;;;1964   
;;;1965   	return FR_OK;
;;;1966   
;;;1967   
;;;1968   #else	/* Non-LFN configuration */
;;;1969   	BYTE b, c, d, *sfn;
;;;1970   	UINT ni, si, i;
;;;1971   	const char *p;
;;;1972   
;;;1973   	/* Create file name in directory form */
;;;1974   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
000006  f8db8000          LDR      r8,[r11,#0]
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f1080801          ADD      r8,r8,#1
                  |L7.16|
000010  f8981000          LDRB     r1,[r8,#0]
000014  292f              CMP      r1,#0x2f
000016  d0f9              BEQ      |L7.12|
000018  295c              CMP      r1,#0x5c
00001a  d0f7              BEQ      |L7.12|
;;;1975   	sfn = dp->fn;
00001c  f8d09018          LDR      r9,[r0,#0x18]
;;;1976   	mem_set(sfn, ' ', 11);
000020  220b              MOVS     r2,#0xb
000022  2120              MOVS     r1,#0x20
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       mem_set
;;;1977   	si = i = b = 0; ni = 8;
00002a  2500              MOVS     r5,#0
00002c  462e              MOV      r6,r5
00002e  462f              MOV      r7,r5
000030  f04f0a08          MOV      r10,#8
                  |L7.52|
;;;1978   #if _FS_RPATH
;;;1979   	if (p[si] == '.') { /* Is this a dot entry? */
;;;1980   		for (;;) {
;;;1981   			c = (BYTE)p[si++];
;;;1982   			if (c != '.' || si >= 3) break;
;;;1983   			sfn[i++] = c;
;;;1984   		}
;;;1985   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;1986   		*path = &p[si];									/* Return pointer to the next segment */
;;;1987   		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;1988   		return FR_OK;
;;;1989   	}
;;;1990   #endif
;;;1991   	for (;;) {
;;;1992   		c = (BYTE)p[si++];
000034  4638              MOV      r0,r7
000036  1c7f              ADDS     r7,r7,#1
000038  f8184000          LDRB     r4,[r8,r0]
;;;1993   		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
00003c  2c20              CMP      r4,#0x20
00003e  d90b              BLS      |L7.88|
000040  2c2f              CMP      r4,#0x2f
000042  d009              BEQ      |L7.88|
000044  2c5c              CMP      r4,#0x5c
000046  d007              BEQ      |L7.88|
;;;1994   		if (c == '.' || i >= ni) {
000048  2c2e              CMP      r4,#0x2e
00004a  d001              BEQ      |L7.80|
00004c  4556              CMP      r6,r10
00004e  d316              BCC      |L7.126|
                  |L7.80|
;;;1995   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
000050  f1ba0f08          CMP      r10,#8
000054  d10a              BNE      |L7.108|
000056  e007              B        |L7.104|
                  |L7.88|
;;;1996   			i = 8; ni = 11;
;;;1997   			b <<= 2; continue;
;;;1998   		}
;;;1999   		if (c >= 0x80) {				/* Extended character? */
;;;2000   			b |= 3;						/* Eliminate NT flag */
;;;2001   #ifdef _EXCVT
;;;2002   			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
;;;2003   #else
;;;2004   #if !_DF1S
;;;2005   			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
;;;2006   #endif
;;;2007   #endif
;;;2008   		}
;;;2009   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
;;;2010   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;2011   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
;;;2012   				return FR_INVALID_NAME;
;;;2013   			sfn[i++] = c;
;;;2014   			sfn[i++] = d;
;;;2015   		} else {						/* SBC */
;;;2016   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
;;;2017   				return FR_INVALID_NAME;
;;;2018   			if (IsUpper(c)) {			/* ASCII large capital? */
;;;2019   				b |= 2;
;;;2020   			} else {
;;;2021   				if (IsLower(c)) {		/* ASCII small capital? */
;;;2022   					b |= 1; c -= 0x20;
;;;2023   				}
;;;2024   			}
;;;2025   			sfn[i++] = c;
;;;2026   		}
;;;2027   	}
;;;2028   	*path = &p[si];						/* Return pointer to the next segment */
000058  eb080007          ADD      r0,r8,r7
00005c  f8cb0000          STR      r0,[r11,#0]
;;;2029   	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
000060  2c20              CMP      r4,#0x20
000062  d847              BHI      |L7.244|
000064  2004              MOVS     r0,#4
000066  e046              B        |L7.246|
                  |L7.104|
000068  2c2e              CMP      r4,#0x2e              ;1995
00006a  d002              BEQ      |L7.114|
                  |L7.108|
00006c  2006              MOVS     r0,#6                 ;1995
                  |L7.110|
;;;2030   
;;;2031   	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
;;;2032   	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
;;;2033   
;;;2034   	if (ni == 8) b <<= 2;
;;;2035   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;;;2036   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;;;2037   
;;;2038   	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
;;;2039   
;;;2040   	return FR_OK;
;;;2041   #endif
;;;2042   }
00006e  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.114|
000072  2608              MOVS     r6,#8                 ;1996
000074  f04f0a0b          MOV      r10,#0xb              ;1996
000078  06a8              LSLS     r0,r5,#26             ;1997
00007a  0e05              LSRS     r5,r0,#24             ;1997
00007c  e7da              B        |L7.52|
                  |L7.126|
00007e  2c80              CMP      r4,#0x80              ;1999
000080  d301              BCC      |L7.134|
000082  f0450503          ORR      r5,r5,#3              ;2000
                  |L7.134|
000086  f1a40081          SUB      r0,r4,#0x81           ;2009
00008a  287d              CMP      r0,#0x7d              ;2009
00008c  d817              BHI      |L7.190|
00008e  4638              MOV      r0,r7                 ;2010
000090  1c7f              ADDS     r7,r7,#1              ;2010
000092  f8180000          LDRB     r0,[r8,r0]            ;2010
000096  f1a00140          SUB      r1,r0,#0x40           ;2011
00009a  293f              CMP      r1,#0x3f              ;2011
00009c  d302              BCC      |L7.164|
00009e  3940              SUBS     r1,r1,#0x40           ;2011
0000a0  297f              CMP      r1,#0x7f              ;2011
0000a2  d203              BCS      |L7.172|
                  |L7.164|
0000a4  f1aa0101          SUB      r1,r10,#1             ;2011
0000a8  428e              CMP      r6,r1                 ;2011
0000aa  d301              BCC      |L7.176|
                  |L7.172|
0000ac  2006              MOVS     r0,#6                 ;2012
0000ae  e7de              B        |L7.110|
                  |L7.176|
0000b0  1c71              ADDS     r1,r6,#1              ;2013
0000b2  f8094006          STRB     r4,[r9,r6]            ;2013
0000b6  1c4e              ADDS     r6,r1,#1              ;2014
0000b8  f8090001          STRB     r0,[r9,r1]            ;2014
0000bc  e7ba              B        |L7.52|
                  |L7.190|
0000be  4621              MOV      r1,r4                 ;2016
0000c0  a01d              ADR      r0,|L7.312|
0000c2  f7fffffe          BL       chk_chr
0000c6  b108              CBZ      r0,|L7.204|
0000c8  2006              MOVS     r0,#6                 ;2017
0000ca  e7d0              B        |L7.110|
                  |L7.204|
0000cc  f1a40041          SUB      r0,r4,#0x41           ;2018
0000d0  2819              CMP      r0,#0x19              ;2018
0000d2  d802              BHI      |L7.218|
0000d4  f0450502          ORR      r5,r5,#2              ;2019
0000d8  e007              B        |L7.234|
                  |L7.218|
0000da  f1a40061          SUB      r0,r4,#0x61           ;2021
0000de  2819              CMP      r0,#0x19              ;2021
0000e0  d803              BHI      |L7.234|
0000e2  f0450501          ORR      r5,r5,#1              ;2022
0000e6  3c20              SUBS     r4,r4,#0x20           ;2022
0000e8  b2e4              UXTB     r4,r4                 ;2022
                  |L7.234|
0000ea  4630              MOV      r0,r6                 ;2025
0000ec  1c76              ADDS     r6,r6,#1              ;2025
0000ee  f8094000          STRB     r4,[r9,r0]            ;2025
0000f2  e79f              B        |L7.52|
                  |L7.244|
0000f4  2000              MOVS     r0,#0                 ;2029
                  |L7.246|
0000f6  b126              CBZ      r6,|L7.258|
0000f8  f8991000          LDRB     r1,[r9,#0]            ;2032
0000fc  29e5              CMP      r1,#0xe5              ;2032
0000fe  d002              BEQ      |L7.262|
000100  e004              B        |L7.268|
                  |L7.258|
000102  2006              MOVS     r0,#6                 ;2031
000104  e7b3              B        |L7.110|
                  |L7.262|
000106  2105              MOVS     r1,#5                 ;2032
000108  f8891000          STRB     r1,[r9,#0]            ;2032
                  |L7.268|
00010c  f1ba0f08          CMP      r10,#8                ;2034
000110  d101              BNE      |L7.278|
000112  06a9              LSLS     r1,r5,#26             ;2034
000114  0e0d              LSRS     r5,r1,#24             ;2034
                  |L7.278|
000116  f0050103          AND      r1,r5,#3              ;2035
00011a  2901              CMP      r1,#1                 ;2035
00011c  d101              BNE      |L7.290|
00011e  f0400010          ORR      r0,r0,#0x10           ;2035
                  |L7.290|
000122  f3c50181          UBFX     r1,r5,#2,#2           ;2036
000126  2901              CMP      r1,#1                 ;2036
000128  d101              BNE      |L7.302|
00012a  f0400008          ORR      r0,r0,#8              ;2036
                  |L7.302|
00012e  f889000b          STRB     r0,[r9,#0xb]          ;2038
000132  2000              MOVS     r0,#0                 ;2040
000134  e79b              B        |L7.110|
;;;2043   
                          ENDP

000136  0000              DCW      0x0000
                  |L7.312|
000138  222a2b2c          DCB      """*+,:;<=>?[]|",127,0
00013c  3a3b3c3d
000140  3e3f5b5d
000144  7c7f00  
000147  00                DCB      0

                          AREA ||i.dec_lock||, CODE, READONLY, ALIGN=2

                  dec_lock PROC
;;;656    static
;;;657    FRESULT dec_lock (	/* Decrement object open counter */
000000  1e40              SUBS     r0,r0,#1
;;;658    	UINT i			/* Semaphore index (1..) */
;;;659    )
;;;660    {
;;;661    	WORD n;
;;;662    	FRESULT res;
;;;663    
;;;664    
;;;665    	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
000002  2803              CMP      r0,#3
000004  d213              BCS      |L8.46|
;;;666    		n = Files[i].ctr;
000006  4b0b              LDR      r3,|L8.52|
000008  eb000240          ADD      r2,r0,r0,LSL #1
00000c  eb030182          ADD      r1,r3,r2,LSL #2
000010  8948              LDRH     r0,[r1,#0xa]
;;;667    		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
000012  f5b07f80          CMP      r0,#0x100
000016  d100              BNE      |L8.26|
000018  2000              MOVS     r0,#0
                  |L8.26|
;;;668    		if (n) n--;					/* Decrement read mode open count */
00001a  b108              CBZ      r0,|L8.32|
00001c  1e40              SUBS     r0,r0,#1
00001e  b280              UXTH     r0,r0
                  |L8.32|
;;;669    		Files[i].ctr = n;
000020  8148              STRH     r0,[r1,#0xa]
;;;670    		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
000022  b910              CBNZ     r0,|L8.42|
000024  2000              MOVS     r0,#0
000026  f8430022          STR      r0,[r3,r2,LSL #2]
                  |L8.42|
;;;671    		res = FR_OK;
00002a  2000              MOVS     r0,#0
;;;672    	} else {
;;;673    		res = FR_INT_ERR;			/* Invalid index nunber */
;;;674    	}
;;;675    	return res;
;;;676    }
00002c  4770              BX       lr
                  |L8.46|
00002e  2002              MOVS     r0,#2                 ;673
000030  4770              BX       lr
;;;677    
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      ||.bss||+0xc

                          AREA ||i.dir_alloc||, CODE, READONLY, ALIGN=1

                  dir_alloc PROC
;;;1198   static
;;;1199   FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;1200   	DIR* dp,		/* Pointer to the directory object */
;;;1201   	UINT nent		/* Number of contiguous entries to allocate (1-21) */
;;;1202   )
;;;1203   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1204   	FRESULT res;
;;;1205   	UINT n;
;;;1206   
;;;1207   
;;;1208   	res = dir_sdi(dp, 0);
000006  2100              MOVS     r1,#0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       dir_sdi
;;;1209   	if (res == FR_OK) {
00000e  b988              CBNZ     r0,|L9.52|
;;;1210   		n = 0;
000010  2400              MOVS     r4,#0
                  |L9.18|
;;;1211   		do {
;;;1212   			res = move_window(dp->fs, dp->sect);
000012  6929              LDR      r1,[r5,#0x10]
000014  6828              LDR      r0,[r5,#0]
000016  f7fffffe          BL       move_window
;;;1213   			if (res != FR_OK) break;
00001a  b958              CBNZ     r0,|L9.52|
;;;1214   			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
00001c  6969              LDR      r1,[r5,#0x14]
00001e  7809              LDRB     r1,[r1,#0]
000020  29e5              CMP      r1,#0xe5
000022  d00b              BEQ      |L9.60|
000024  b151              CBZ      r1,|L9.60|
;;;1215   				if (++n == nent) break;	/* A block of contiguous free entries is found */
;;;1216   			} else {
;;;1217   				n = 0;					/* Not a blank entry. Restart to search */
000026  2400              MOVS     r4,#0
                  |L9.40|
;;;1218   			}
;;;1219   			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
000028  2101              MOVS     r1,#1
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       dir_next
;;;1220   		} while (res == FR_OK);
000030  2800              CMP      r0,#0
000032  d0ee              BEQ      |L9.18|
                  |L9.52|
;;;1221   	}
;;;1222   	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
000034  2804              CMP      r0,#4
000036  d100              BNE      |L9.58|
000038  2007              MOVS     r0,#7
                  |L9.58|
;;;1223   	return res;
;;;1224   }
00003a  bd70              POP      {r4-r6,pc}
                  |L9.60|
00003c  1c64              ADDS     r4,r4,#1              ;1215
00003e  42b4              CMP      r4,r6                 ;1215
000040  d0f8              BEQ      |L9.52|
000042  e7f1              B        |L9.40|
;;;1225   #endif
                          ENDP


                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=1

                  dir_find PROC
;;;1457   static
;;;1458   FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;1459   	DIR* dp			/* Pointer to the directory object linked to the file name */
;;;1460   )
;;;1461   {
000002  4604              MOV      r4,r0
;;;1462   	FRESULT res;
;;;1463   	BYTE c, *dir;
;;;1464   #if _USE_LFN
;;;1465   	BYTE a, ord, sum;
;;;1466   #endif
;;;1467   
;;;1468   	res = dir_sdi(dp, 0);			/* Rewind directory object */
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       dir_sdi
;;;1469   	if (res != FR_OK) return res;
00000c  2800              CMP      r0,#0
00000e  d118              BNE      |L10.66|
                  |L10.16|
;;;1470   
;;;1471   #if _USE_LFN
;;;1472   	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1473   #endif
;;;1474   	do {
;;;1475   		res = move_window(dp->fs, dp->sect);
000010  6921              LDR      r1,[r4,#0x10]
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       move_window
000018  4605              MOV      r5,r0
;;;1476   		if (res != FR_OK) break;
00001a  b98d              CBNZ     r5,|L10.64|
;;;1477   		dir = dp->dir;					/* Ptr to the directory entry of current index */
00001c  6960              LDR      r0,[r4,#0x14]
;;;1478   		c = dir[DIR_Name];
00001e  7801              LDRB     r1,[r0,#0]
;;;1479   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000020  b181              CBZ      r1,|L10.68|
;;;1480   #if _USE_LFN	/* LFN configuration */
;;;1481   		a = dir[DIR_Attr] & AM_MASK;
;;;1482   		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;;;1483   			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1484   		} else {
;;;1485   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;1486   				if (dp->lfn) {
;;;1487   					if (c & LLEF) {		/* Is it start of LFN sequence? */
;;;1488   						sum = dir[LDIR_Chksum];
;;;1489   						c &= ~LLEF; ord = c;	/* LFN start order */
;;;1490   						dp->lfn_idx = dp->index;	/* Start index of LFN */
;;;1491   					}
;;;1492   					/* Check validity of the LFN entry and compare it with given name */
;;;1493   					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1494   				}
;;;1495   			} else {					/* An SFN entry is found */
;;;1496   				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
;;;1497   				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
;;;1498   				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1499   			}
;;;1500   		}
;;;1501   #else		/* Non LFN configuration */
;;;1502   		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
000022  7ac1              LDRB     r1,[r0,#0xb]
000024  0709              LSLS     r1,r1,#28
000026  d404              BMI      |L10.50|
000028  220b              MOVS     r2,#0xb
00002a  69a1              LDR      r1,[r4,#0x18]
00002c  f7fffffe          BL       mem_cmp
000030  b130              CBZ      r0,|L10.64|
                  |L10.50|
;;;1503   			break;
;;;1504   #endif
;;;1505   		res = dir_next(dp, 0);		/* Next entry */
000032  2100              MOVS     r1,#0
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       dir_next
00003a  4605              MOV      r5,r0
;;;1506   	} while (res == FR_OK);
00003c  2d00              CMP      r5,#0
00003e  d0e7              BEQ      |L10.16|
                  |L10.64|
;;;1507   
;;;1508   	return res;
000040  4628              MOV      r0,r5
                  |L10.66|
;;;1509   }
000042  bd70              POP      {r4-r6,pc}
                  |L10.68|
000044  2504              MOVS     r5,#4                 ;1479
000046  e7fb              B        |L10.64|
;;;1510   
                          ENDP


                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1127   static
;;;1128   FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1129   	DIR* dp,		/* Pointer to the directory object */
;;;1130   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1131   )
;;;1132   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1133   	DWORD clst;
;;;1134   	UINT i;
;;;1135   #if !_FS_READONLY
;;;1136   	UINT c;
;;;1137   #endif
;;;1138   
;;;1139   
;;;1140   	i = dp->index + 1;
000008  88e7              LDRH     r7,[r4,#6]
00000a  1c7f              ADDS     r7,r7,#1
;;;1141   	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
00000c  0438              LSLS     r0,r7,#16
00000e  0c00              LSRS     r0,r0,#16
000010  d004              BEQ      |L11.28|
000012  6920              LDR      r0,[r4,#0x10]
000014  b110              CBZ      r0,|L11.28|
;;;1142   		return FR_NO_FILE;
;;;1143   
;;;1144   	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
000016  0739              LSLS     r1,r7,#28
000018  d003              BEQ      |L11.34|
00001a  e067              B        |L11.236|
                  |L11.28|
00001c  2004              MOVS     r0,#4                 ;1142
                  |L11.30|
;;;1145   		dp->sect++;					/* Next sector */
;;;1146   
;;;1147   		if (!dp->clust) {		/* Static table */
;;;1148   			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
;;;1149   				return FR_NO_FILE;
;;;1150   		}
;;;1151   		else {					/* Dynamic table */
;;;1152   			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
;;;1153   				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
;;;1154   				if (clst <= 1) return FR_INT_ERR;
;;;1155   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
;;;1156   				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
;;;1157   #if !_FS_READONLY
;;;1158   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
;;;1159   					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
;;;1160   					if (clst == 0) return FR_DENIED;			/* No free cluster */
;;;1161   					if (clst == 1) return FR_INT_ERR;
;;;1162   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
;;;1163   					/* Clean-up stretched table */
;;;1164   					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
;;;1165   					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
;;;1166   					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
;;;1167   					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;1168   						dp->fs->wflag = 1;
;;;1169   						if (sync_window(dp->fs)) return FR_DISK_ERR;
;;;1170   						dp->fs->winsect++;
;;;1171   					}
;;;1172   					dp->fs->winsect -= c;						/* Rewind window offset */
;;;1173   #else
;;;1174   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
;;;1175   					return FR_NO_FILE;							/* Report EOT */
;;;1176   #endif
;;;1177   				}
;;;1178   				dp->clust = clst;				/* Initialize data for new cluster */
;;;1179   				dp->sect = clust2sect(dp->fs, clst);
;;;1180   			}
;;;1181   		}
;;;1182   	}
;;;1183   
;;;1184   	dp->index = (WORD)i;	/* Current index */
;;;1185   	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
;;;1186   
;;;1187   	return FR_OK;
;;;1188   }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L11.34|
000022  1c40              ADDS     r0,r0,#1              ;1145
000024  6120              STR      r0,[r4,#0x10]         ;1145
000026  68e1              LDR      r1,[r4,#0xc]          ;1147
000028  b131              CBZ      r1,|L11.56|
00002a  6820              LDR      r0,[r4,#0]            ;1152
00002c  7882              LDRB     r2,[r0,#2]            ;1152
00002e  1e52              SUBS     r2,r2,#1              ;1152
000030  ea121f17          TST      r2,r7,LSR #4          ;1152
000034  d006              BEQ      |L11.68|
000036  e059              B        |L11.236|
                  |L11.56|
000038  6820              LDR      r0,[r4,#0]            ;1148
00003a  8900              LDRH     r0,[r0,#8]            ;1148
00003c  42b8              CMP      r0,r7                 ;1148
00003e  d855              BHI      |L11.236|
000040  2004              MOVS     r0,#4                 ;1149
000042  e7ec              B        |L11.30|
                  |L11.68|
000044  f7fffffe          BL       get_fat
000048  4605              MOV      r5,r0                 ;1153
00004a  2d01              CMP      r5,#1                 ;1154
00004c  d801              BHI      |L11.82|
00004e  2002              MOVS     r0,#2                 ;1154
000050  e7e5              B        |L11.30|
                  |L11.82|
000052  1c68              ADDS     r0,r5,#1              ;1155
000054  d014              BEQ      |L11.128|
000056  6820              LDR      r0,[r4,#0]            ;1156
000058  6941              LDR      r1,[r0,#0x14]         ;1156
00005a  42a9              CMP      r1,r5                 ;1156
00005c  d840              BHI      |L11.224|
00005e  b18e              CBZ      r6,|L11.132|
000060  68e1              LDR      r1,[r4,#0xc]          ;1159
000062  f7fffffe          BL       create_chain
000066  4605              MOV      r5,r0                 ;1159
000068  0028              MOVS     r0,r5                 ;1160
00006a  d00d              BEQ      |L11.136|
00006c  2d01              CMP      r5,#1                 ;1161
00006e  d00d              BEQ      |L11.140|
000070  1c68              ADDS     r0,r5,#1              ;1162
000072  d00d              BEQ      |L11.144|
000074  6820              LDR      r0,[r4,#0]            ;1164
000076  f7fffffe          BL       sync_window
00007a  b158              CBZ      r0,|L11.148|
00007c  2001              MOVS     r0,#1                 ;1164
00007e  e7ce              B        |L11.30|
                  |L11.128|
000080  2001              MOVS     r0,#1                 ;1155
000082  e7cc              B        |L11.30|
                  |L11.132|
000084  2004              MOVS     r0,#4                 ;1158
000086  e7ca              B        |L11.30|
                  |L11.136|
000088  2007              MOVS     r0,#7                 ;1160
00008a  e7c8              B        |L11.30|
                  |L11.140|
00008c  2002              MOVS     r0,#2                 ;1161
00008e  e7c6              B        |L11.30|
                  |L11.144|
000090  2001              MOVS     r0,#1                 ;1162
000092  e7c4              B        |L11.30|
                  |L11.148|
000094  6820              LDR      r0,[r4,#0]            ;1165
000096  f44f7200          MOV      r2,#0x200             ;1165
00009a  3030              ADDS     r0,r0,#0x30           ;1165
00009c  2100              MOVS     r1,#0                 ;1165
00009e  f7fffffe          BL       mem_set
0000a2  4629              MOV      r1,r5                 ;1166
0000a4  6820              LDR      r0,[r4,#0]            ;1166
0000a6  f7fffffe          BL       clust2sect
0000aa  6821              LDR      r1,[r4,#0]            ;1166
0000ac  62c8              STR      r0,[r1,#0x2c]         ;1166
0000ae  2600              MOVS     r6,#0                 ;1167
0000b0  f04f0801          MOV      r8,#1                 ;1155
0000b4  e00c              B        |L11.208|
                  |L11.182|
0000b6  f8808004          STRB     r8,[r0,#4]            ;1168
0000ba  6820              LDR      r0,[r4,#0]            ;1169
0000bc  f7fffffe          BL       sync_window
0000c0  b108              CBZ      r0,|L11.198|
0000c2  2001              MOVS     r0,#1                 ;1169
0000c4  e7ab              B        |L11.30|
                  |L11.198|
0000c6  6820              LDR      r0,[r4,#0]            ;1170
0000c8  6ac1              LDR      r1,[r0,#0x2c]         ;1170
0000ca  1c49              ADDS     r1,r1,#1              ;1170
0000cc  62c1              STR      r1,[r0,#0x2c]         ;1170
0000ce  1c76              ADDS     r6,r6,#1              ;1167
                  |L11.208|
0000d0  6820              LDR      r0,[r4,#0]            ;1167
0000d2  7881              LDRB     r1,[r0,#2]            ;1167
0000d4  42b1              CMP      r1,r6                 ;1167
0000d6  d8ee              BHI      |L11.182|
0000d8  6821              LDR      r1,[r4,#0]            ;1172
0000da  6ac9              LDR      r1,[r1,#0x2c]         ;1172
0000dc  1b89              SUBS     r1,r1,r6              ;1172
0000de  62c1              STR      r1,[r0,#0x2c]         ;1172
                  |L11.224|
0000e0  60e5              STR      r5,[r4,#0xc]          ;1178
0000e2  4629              MOV      r1,r5                 ;1179
0000e4  6820              LDR      r0,[r4,#0]            ;1179
0000e6  f7fffffe          BL       clust2sect
0000ea  6120              STR      r0,[r4,#0x10]         ;1179
                  |L11.236|
0000ec  80e7              STRH     r7,[r4,#6]            ;1184
0000ee  f007010f          AND      r1,r7,#0xf            ;1185
0000f2  2230              MOVS     r2,#0x30              ;1185
0000f4  6820              LDR      r0,[r4,#0]            ;1185
0000f6  eb021141          ADD      r1,r2,r1,LSL #5       ;1185
0000fa  4408              ADD      r0,r0,r1              ;1185
0000fc  6160              STR      r0,[r4,#0x14]         ;1185
0000fe  2000              MOVS     r0,#0                 ;1187
000100  e78d              B        |L11.30|
;;;1189   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;1518   static
;;;1519   FRESULT dir_read (
000000  b570              PUSH     {r4-r6,lr}
;;;1520   	DIR* dp,		/* Pointer to the directory object */
;;;1521   	int vol			/* Filtered by 0:file/directory or 1:volume label */
;;;1522   )
;;;1523   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1524   	FRESULT res;
;;;1525   	BYTE a, c, *dir;
;;;1526   #if _USE_LFN
;;;1527   	BYTE ord = 0xFF, sum = 0xFF;
;;;1528   #endif
;;;1529   
;;;1530   	res = FR_NO_FILE;
000006  2004              MOVS     r0,#4
000008  e020              B        |L12.76|
                  |L12.10|
;;;1531   	while (dp->sect) {
;;;1532   		res = move_window(dp->fs, dp->sect);
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       move_window
;;;1533   		if (res != FR_OK) break;
000010  b9f8              CBNZ     r0,|L12.82|
;;;1534   		dir = dp->dir;					/* Ptr to the directory entry of current index */
000012  6962              LDR      r2,[r4,#0x14]
;;;1535   		c = dir[DIR_Name];
000014  7811              LDRB     r1,[r2,#0]
;;;1536   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000016  b1a9              CBZ      r1,|L12.68|
;;;1537   		a = dir[DIR_Attr] & AM_MASK;
000018  7ad2              LDRB     r2,[r2,#0xb]
00001a  f002023f          AND      r2,r2,#0x3f
;;;1538   #if _USE_LFN	/* LFN configuration */
;;;1539   		if (c == DDEM || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
;;;1540   			ord = 0xFF;
;;;1541   		} else {
;;;1542   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;1543   				if (c & LLEF) {			/* Is it start of LFN sequence? */
;;;1544   					sum = dir[LDIR_Chksum];
;;;1545   					c &= ~LLEF; ord = c;
;;;1546   					dp->lfn_idx = dp->index;
;;;1547   				}
;;;1548   				/* Check LFN validity and capture it */
;;;1549   				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1550   			} else {					/* An SFN entry is found */
;;;1551   				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
;;;1552   					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
;;;1553   				break;
;;;1554   			}
;;;1555   		}
;;;1556   #else		/* Non LFN configuration */
;;;1557   		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
00001e  29e5              CMP      r1,#0xe5
000020  d00a              BEQ      |L12.56|
000022  292e              CMP      r1,#0x2e
000024  d008              BEQ      |L12.56|
000026  2a0f              CMP      r2,#0xf
000028  d006              BEQ      |L12.56|
00002a  f0220120          BIC      r1,r2,#0x20
00002e  2908              CMP      r1,#8
000030  d00a              BEQ      |L12.72|
000032  2100              MOVS     r1,#0
                  |L12.52|
000034  42a9              CMP      r1,r5
000036  d00c              BEQ      |L12.82|
                  |L12.56|
;;;1558   			break;
;;;1559   #endif
;;;1560   		res = dir_next(dp, 0);				/* Next entry */
000038  2100              MOVS     r1,#0
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       dir_next
;;;1561   		if (res != FR_OK) break;
000040  b120              CBZ      r0,|L12.76|
000042  e006              B        |L12.82|
                  |L12.68|
000044  2004              MOVS     r0,#4                 ;1536
000046  e004              B        |L12.82|
                  |L12.72|
000048  2101              MOVS     r1,#1                 ;1557
00004a  e7f3              B        |L12.52|
                  |L12.76|
00004c  6921              LDR      r1,[r4,#0x10]         ;1531
00004e  2900              CMP      r1,#0                 ;1531
000050  d1db              BNE      |L12.10|
                  |L12.82|
;;;1562   	}
;;;1563   
;;;1564   	if (res != FR_OK) dp->sect = 0;
000052  2800              CMP      r0,#0
000054  d001              BEQ      |L12.90|
000056  2100              MOVS     r1,#0
000058  6121              STR      r1,[r4,#0x10]
                  |L12.90|
;;;1565   
;;;1566   	return res;
;;;1567   }
00005a  bd70              POP      {r4-r6,pc}
;;;1568   #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;1577   static
;;;1578   FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;1579   	DIR* dp				/* Target directory with object name to be created */
;;;1580   )
;;;1581   {
000002  4604              MOV      r4,r0
;;;1582   	FRESULT res;
;;;1583   #if _USE_LFN	/* LFN configuration */
;;;1584   	UINT n, nent;
;;;1585   	BYTE sn[12], *fn, sum;
;;;1586   	WCHAR *lfn;
;;;1587   
;;;1588   
;;;1589   	fn = dp->fn; lfn = dp->lfn;
;;;1590   	mem_cpy(sn, fn, 12);
;;;1591   
;;;1592   	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
;;;1593   		return FR_INVALID_NAME;
;;;1594   
;;;1595   	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;1596   		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
;;;1597   		for (n = 1; n < 100; n++) {
;;;1598   			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
;;;1599   			res = dir_find(dp);				/* Check if the name collides with existing SFN */
;;;1600   			if (res != FR_OK) break;
;;;1601   		}
;;;1602   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;1603   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;1604   		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
;;;1605   	}
;;;1606   
;;;1607   	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
;;;1608   		for (n = 0; lfn[n]; n++) ;
;;;1609   		nent = (n + 25) / 13;
;;;1610   	} else {						/* Otherwise allocate an entry for an SFN  */
;;;1611   		nent = 1;
;;;1612   	}
;;;1613   	res = dir_alloc(dp, nent);		/* Allocate entries */
;;;1614   
;;;1615   	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
;;;1616   		res = dir_sdi(dp, dp->index - nent);
;;;1617   		if (res == FR_OK) {
;;;1618   			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
;;;1619   			do {					/* Store LFN entries in bottom first */
;;;1620   				res = move_window(dp->fs, dp->sect);
;;;1621   				if (res != FR_OK) break;
;;;1622   				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
;;;1623   				dp->fs->wflag = 1;
;;;1624   				res = dir_next(dp, 0);	/* Next entry */
;;;1625   			} while (res == FR_OK && --nent);
;;;1626   		}
;;;1627   	}
;;;1628   #else	/* Non LFN configuration */
;;;1629   	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       dir_alloc
00000c  4605              MOV      r5,r0
;;;1630   #endif
;;;1631   
;;;1632   	if (res == FR_OK) {				/* Set SFN entry */
00000e  b995              CBNZ     r5,|L13.54|
;;;1633   		res = move_window(dp->fs, dp->sect);
000010  6921              LDR      r1,[r4,#0x10]
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       move_window
000018  4605              MOV      r5,r0
;;;1634   		if (res == FR_OK) {
00001a  b965              CBNZ     r5,|L13.54|
;;;1635   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
00001c  2220              MOVS     r2,#0x20
00001e  2100              MOVS     r1,#0
000020  6960              LDR      r0,[r4,#0x14]
000022  f7fffffe          BL       mem_set
;;;1636   			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
000026  e9d40105          LDRD     r0,r1,[r4,#0x14]
00002a  220b              MOVS     r2,#0xb
00002c  f7fffffe          BL       mem_cpy
;;;1637   #if _USE_LFN
;;;1638   			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;1639   #endif
;;;1640   			dp->fs->wflag = 1;
000030  6821              LDR      r1,[r4,#0]
000032  2001              MOVS     r0,#1
000034  7108              STRB     r0,[r1,#4]
                  |L13.54|
;;;1641   		}
;;;1642   	}
;;;1643   
;;;1644   	return res;
000036  4628              MOV      r0,r5
;;;1645   }
000038  bd70              POP      {r4-r6,pc}
;;;1646   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;1655   static
;;;1656   FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;1657   	DIR* dp				/* Directory object pointing the entry to be removed */
;;;1658   )
;;;1659   {
000002  4604              MOV      r4,r0
;;;1660   	FRESULT res;
;;;1661   #if _USE_LFN	/* LFN configuration */
;;;1662   	UINT i;
;;;1663   
;;;1664   	i = dp->index;	/* SFN index */
;;;1665   	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
;;;1666   	if (res == FR_OK) {
;;;1667   		do {
;;;1668   			res = move_window(dp->fs, dp->sect);
;;;1669   			if (res != FR_OK) break;
;;;1670   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
;;;1671   			*dp->dir = DDEM;
;;;1672   			dp->fs->wflag = 1;
;;;1673   			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
;;;1674   			res = dir_next(dp, 0);		/* Next entry */
;;;1675   		} while (res == FR_OK);
;;;1676   		if (res == FR_NO_FILE) res = FR_INT_ERR;
;;;1677   	}
;;;1678   
;;;1679   #else			/* Non LFN configuration */
;;;1680   	res = dir_sdi(dp, dp->index);
000004  4620              MOV      r0,r4
000006  88e1              LDRH     r1,[r4,#6]
000008  f7fffffe          BL       dir_sdi
00000c  4605              MOV      r5,r0
;;;1681   	if (res == FR_OK) {
00000e  b985              CBNZ     r5,|L14.50|
;;;1682   		res = move_window(dp->fs, dp->sect);
000010  6921              LDR      r1,[r4,#0x10]
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       move_window
000018  4605              MOV      r5,r0
;;;1683   		if (res == FR_OK) {
00001a  b955              CBNZ     r5,|L14.50|
;;;1684   			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
00001c  2220              MOVS     r2,#0x20
00001e  2100              MOVS     r1,#0
000020  6960              LDR      r0,[r4,#0x14]
000022  f7fffffe          BL       mem_set
;;;1685   			*dp->dir = DDEM;
000026  6961              LDR      r1,[r4,#0x14]
000028  20e5              MOVS     r0,#0xe5
00002a  7008              STRB     r0,[r1,#0]
;;;1686   			dp->fs->wflag = 1;
00002c  6821              LDR      r1,[r4,#0]
00002e  2001              MOVS     r0,#1
000030  7108              STRB     r0,[r1,#4]
                  |L14.50|
;;;1687   		}
;;;1688   	}
;;;1689   #endif
;;;1690   
;;;1691   	return res;
000032  4628              MOV      r0,r5
;;;1692   }
000034  bd70              POP      {r4-r6,pc}
;;;1693   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;1079   static
;;;1080   FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;1081   	DIR* dp,		/* Pointer to directory object */
;;;1082   	UINT idx		/* Index of directory table */
;;;1083   )
;;;1084   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1085   	DWORD clst, sect;
;;;1086   	UINT ic;
;;;1087   
;;;1088   
;;;1089   	dp->index = (WORD)idx;	/* Current index */
000006  80e5              STRH     r5,[r4,#6]
;;;1090   	clst = dp->sclust;		/* Table start cluster (0:root) */
000008  68a3              LDR      r3,[r4,#8]
;;;1091   	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
00000a  2b01              CMP      r3,#1
00000c  d003              BEQ      |L15.22|
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  4299              CMP      r1,r3
000014  d801              BHI      |L15.26|
                  |L15.22|
;;;1092   		return FR_INT_ERR;
000016  2002              MOVS     r0,#2
;;;1093   	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
;;;1094   		clst = dp->fs->dirbase;
;;;1095   
;;;1096   	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
;;;1097   		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
;;;1098   			return FR_INT_ERR;
;;;1099   		sect = dp->fs->dirbase;
;;;1100   	}
;;;1101   	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
;;;1102   		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
;;;1103   		while (idx >= ic) {	/* Follow cluster chain */
;;;1104   			clst = get_fat(dp->fs, clst);				/* Get next cluster */
;;;1105   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
;;;1106   			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
;;;1107   				return FR_INT_ERR;
;;;1108   			idx -= ic;
;;;1109   		}
;;;1110   		sect = clust2sect(dp->fs, clst);
;;;1111   	}
;;;1112   	dp->clust = clst;	/* Current cluster# */
;;;1113   	if (!sect) return FR_INT_ERR;
;;;1114   	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
;;;1115   	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
;;;1116   
;;;1117   	return FR_OK;
;;;1118   }
000018  bd70              POP      {r4-r6,pc}
                  |L15.26|
00001a  b91b              CBNZ     r3,|L15.36|
00001c  7801              LDRB     r1,[r0,#0]            ;1093
00001e  2903              CMP      r1,#3                 ;1093
000020  d100              BNE      |L15.36|
000022  6a43              LDR      r3,[r0,#0x24]         ;1094
                  |L15.36|
000024  b113              CBZ      r3,|L15.44|
000026  7880              LDRB     r0,[r0,#2]            ;1102
000028  0106              LSLS     r6,r0,#4              ;1102
00002a  e018              B        |L15.94|
                  |L15.44|
00002c  8901              LDRH     r1,[r0,#8]            ;1097
00002e  42a9              CMP      r1,r5                 ;1097
000030  d801              BHI      |L15.54|
000032  2002              MOVS     r0,#2                 ;1098
000034  bd70              POP      {r4-r6,pc}
                  |L15.54|
000036  6a40              LDR      r0,[r0,#0x24]         ;1099
000038  e017              B        |L15.106|
                  |L15.58|
00003a  4619              MOV      r1,r3                 ;1104
00003c  6820              LDR      r0,[r4,#0]            ;1104
00003e  f7fffffe          BL       get_fat
000042  4603              MOV      r3,r0                 ;1104
000044  1c58              ADDS     r0,r3,#1              ;1105
000046  d007              BEQ      |L15.88|
000048  2b02              CMP      r3,#2                 ;1106
00004a  d303              BCC      |L15.84|
00004c  6820              LDR      r0,[r4,#0]            ;1106
00004e  6940              LDR      r0,[r0,#0x14]         ;1106
000050  4298              CMP      r0,r3                 ;1106
000052  d803              BHI      |L15.92|
                  |L15.84|
000054  2002              MOVS     r0,#2                 ;1107
000056  bd70              POP      {r4-r6,pc}
                  |L15.88|
000058  2001              MOVS     r0,#1                 ;1105
00005a  bd70              POP      {r4-r6,pc}
                  |L15.92|
00005c  1bad              SUBS     r5,r5,r6              ;1108
                  |L15.94|
00005e  42b5              CMP      r5,r6                 ;1103
000060  d2eb              BCS      |L15.58|
000062  4619              MOV      r1,r3                 ;1110
000064  6820              LDR      r0,[r4,#0]            ;1110
000066  f7fffffe          BL       clust2sect
                  |L15.106|
00006a  60e3              STR      r3,[r4,#0xc]          ;1112
00006c  b160              CBZ      r0,|L15.136|
00006e  eb001015          ADD      r0,r0,r5,LSR #4       ;1114
000072  6120              STR      r0,[r4,#0x10]         ;1114
000074  f005010f          AND      r1,r5,#0xf            ;1115
000078  2230              MOVS     r2,#0x30              ;1115
00007a  6820              LDR      r0,[r4,#0]            ;1115
00007c  eb021141          ADD      r1,r2,r1,LSL #5       ;1115
000080  4408              ADD      r0,r0,r1              ;1115
000082  6160              STR      r0,[r4,#0x14]         ;1115
000084  2000              MOVS     r0,#0                 ;1117
000086  bd70              POP      {r4-r6,pc}
                  |L15.136|
000088  2002              MOVS     r0,#2                 ;1113
00008a  bd70              POP      {r4-r6,pc}
;;;1119   
                          ENDP


                          AREA ||i.enq_lock||, CODE, READONLY, ALIGN=2

                  enq_lock PROC
;;;614    static
;;;615    int enq_lock (void)	/* Check if an entry is available for a new object */
000000  2000              MOVS     r0,#0
;;;616    {
;;;617    	UINT i;
;;;618    
;;;619    	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
000002  4908              LDR      r1,|L16.36|
000004  e000              B        |L16.8|
                  |L16.6|
000006  1c40              ADDS     r0,r0,#1
                  |L16.8|
000008  2803              CMP      r0,#3
00000a  d205              BCS      |L16.24|
00000c  eb000240          ADD      r2,r0,r0,LSL #1
000010  f8512022          LDR      r2,[r1,r2,LSL #2]
000014  2a00              CMP      r2,#0
000016  d1f6              BNE      |L16.6|
                  |L16.24|
;;;620    	return (i == _FS_LOCK) ? 0 : 1;
000018  2803              CMP      r0,#3
00001a  d001              BEQ      |L16.32|
00001c  2001              MOVS     r0,#1
;;;621    }
00001e  4770              BX       lr
                  |L16.32|
000020  2000              MOVS     r0,#0                 ;620
000022  4770              BX       lr
;;;622    
                          ENDP

                  |L16.36|
                          DCD      ||.bss||+0xc

                          AREA ||i.f_chmod||, CODE, READONLY, ALIGN=1

                  f_chmod PROC
;;;3668   
;;;3669   FRESULT f_chmod (
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;3670   	const TCHAR* path,	/* Pointer to the file path */
;;;3671   	BYTE attr,			/* Attribute bits */
;;;3672   	BYTE mask			/* Attribute mask to change */
;;;3673   )
;;;3674   {
000002  b08c              SUB      sp,sp,#0x30
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;3675   	FRESULT res;
;;;3676   	DIR dj;
;;;3677   	BYTE *dir;
;;;3678   	DEFINE_NAMEBUF;
;;;3679   
;;;3680   
;;;3681   	res = find_volume(&dj.fs, &path, 1);	/* Get logical drive number */
000008  2201              MOVS     r2,#1
00000a  a90c              ADD      r1,sp,#0x30
00000c  a804              ADD      r0,sp,#0x10
00000e  f7fffffe          BL       find_volume
;;;3682   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d116              BNE      |L17.68|
;;;3683   		INIT_BUF(dj);
000016  a801              ADD      r0,sp,#4
000018  900a              STR      r0,[sp,#0x28]
;;;3684   		res = follow_path(&dj, path);		/* Follow the file path */
00001a  a804              ADD      r0,sp,#0x10
00001c  990c              LDR      r1,[sp,#0x30]
00001e  f7fffffe          BL       follow_path
;;;3685   		FREE_BUF();
;;;3686   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3687   			res = FR_INVALID_NAME;
;;;3688   		if (res == FR_OK) {
000022  2800              CMP      r0,#0
000024  d10e              BNE      |L17.68|
;;;3689   			dir = dj.dir;
000026  9809              LDR      r0,[sp,#0x24]
;;;3690   			if (!dir) {						/* Is it a root directory? */
000028  b170              CBZ      r0,|L17.72|
;;;3691   				res = FR_INVALID_NAME;
;;;3692   			} else {						/* File or sub directory */
;;;3693   				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
00002a  f0050227          AND      r2,r5,#0x27
;;;3694   				dir[DIR_Attr] = (attr & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
00002e  7ac1              LDRB     r1,[r0,#0xb]
000030  4014              ANDS     r4,r4,r2
000032  4391              BICS     r1,r1,r2
000034  430c              ORRS     r4,r4,r1
000036  72c4              STRB     r4,[r0,#0xb]
;;;3695   				dj.fs->wflag = 1;
000038  9904              LDR      r1,[sp,#0x10]
00003a  2001              MOVS     r0,#1
00003c  7108              STRB     r0,[r1,#4]
;;;3696   				res = sync_fs(dj.fs);
00003e  9804              LDR      r0,[sp,#0x10]
000040  f7fffffe          BL       sync_fs
                  |L17.68|
;;;3697   			}
;;;3698   		}
;;;3699   	}
;;;3700   
;;;3701   	LEAVE_FF(dj.fs, res);
;;;3702   }
000044  b00f              ADD      sp,sp,#0x3c
000046  bd30              POP      {r4,r5,pc}
                  |L17.72|
000048  2006              MOVS     r0,#6                 ;3691
00004a  e7fb              B        |L17.68|
;;;3703   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2856   
;;;2857   FRESULT f_close (
000000  b510              PUSH     {r4,lr}
;;;2858   	FIL *fp		/* Pointer to the file object to be closed */
;;;2859   )
;;;2860   {
000002  4604              MOV      r4,r0
;;;2861   	FRESULT res;
;;;2862   
;;;2863   
;;;2864   #if !_FS_READONLY
;;;2865   	res = f_sync(fp);					/* Flush cached data */
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       f_sync
;;;2866   	if (res == FR_OK)
00000a  2800              CMP      r0,#0
00000c  d10b              BNE      |L18.38|
;;;2867   #endif
;;;2868   	{
;;;2869   		res = validate(fp);				/* Lock volume */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       validate
;;;2870   		if (res == FR_OK) {
000014  2800              CMP      r0,#0
000016  d106              BNE      |L18.38|
;;;2871   #if _FS_REENTRANT
;;;2872   			FATFS *fs = fp->fs;
;;;2873   #endif
;;;2874   #if _FS_LOCK
;;;2875   			res = dec_lock(fp->lockid);	/* Decrement file open counter */
000018  6a60              LDR      r0,[r4,#0x24]
00001a  f7fffffe          BL       dec_lock
;;;2876   			if (res == FR_OK)
00001e  2800              CMP      r0,#0
000020  d101              BNE      |L18.38|
;;;2877   #endif
;;;2878   				fp->fs = 0;				/* Invalidate file object */
000022  2100              MOVS     r1,#0
000024  6021              STR      r1,[r4,#0]
                  |L18.38|
;;;2879   #if _FS_REENTRANT
;;;2880   			unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;2881   #endif
;;;2882   		}
;;;2883   	}
;;;2884   	return res;
;;;2885   }
000026  bd10              POP      {r4,pc}
;;;2886   
                          ENDP


                          AREA ||i.f_closedir||, CODE, READONLY, ALIGN=1

                  f_closedir PROC
;;;3242   
;;;3243   FRESULT f_closedir (
000000  b510              PUSH     {r4,lr}
;;;3244   	DIR *dp		/* Pointer to the directory object to be closed */
;;;3245   )
;;;3246   {
000002  4604              MOV      r4,r0
;;;3247   	FRESULT res;
;;;3248   
;;;3249   
;;;3250   	res = validate(dp);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       validate
;;;3251   	if (res == FR_OK) {
00000a  2800              CMP      r0,#0
00000c  d108              BNE      |L19.32|
;;;3252   #if _FS_REENTRANT
;;;3253   		FATFS *fs = dp->fs;
;;;3254   #endif
;;;3255   #if _FS_LOCK
;;;3256   		if (dp->lockid)				/* Decrement sub-directory open counter */
00000e  69e1              LDR      r1,[r4,#0x1c]
000010  b111              CBZ      r1,|L19.24|
;;;3257   			res = dec_lock(dp->lockid);
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       dec_lock
                  |L19.24|
;;;3258   		if (res == FR_OK)
000018  2800              CMP      r0,#0
00001a  d101              BNE      |L19.32|
;;;3259   #endif
;;;3260   			dp->fs = 0;				/* Invalidate directory object */
00001c  2100              MOVS     r1,#0
00001e  6021              STR      r1,[r4,#0]
                  |L19.32|
;;;3261   #if _FS_REENTRANT
;;;3262   		unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;3263   #endif
;;;3264   	}
;;;3265   	return res;
;;;3266   }
000020  bd10              POP      {r4,pc}
;;;3267   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;3403   
;;;3404   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3405   	const TCHAR* path,	/* Path name of the logical drive number */
;;;3406   	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
;;;3407   	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
;;;3408   )
;;;3409   {
000004  468b              MOV      r11,r1
000006  4614              MOV      r4,r2
;;;3410   	FRESULT res;
;;;3411   	FATFS *fs;
;;;3412   	DWORD nfree, clst, sect, stat;
;;;3413   	UINT i;
;;;3414   	BYTE fat, *p;
;;;3415   
;;;3416   
;;;3417   	/* Get logical drive number */
;;;3418   	res = find_volume(fatfs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  4669              MOV      r1,sp
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       find_volume
000012  4680              MOV      r8,r0
;;;3419   	fs = *fatfs;
000014  6826              LDR      r6,[r4,#0]
;;;3420   	if (res == FR_OK) {
000016  ea5f0008          MOVS     r0,r8
00001a  d15d              BNE      |L20.216|
;;;3421   		/* If free_clust is valid, return it without full cluster scan */
;;;3422   		if (fs->free_clust <= fs->n_fatent - 2) {
00001c  e9d60904          LDRD     r0,r9,[r6,#0x10]
000020  f1a90102          SUB      r1,r9,#2
000024  4288              CMP      r0,r1
000026  d802              BHI      |L20.46|
;;;3423   			*nclst = fs->free_clust;
000028  f8cb0000          STR      r0,[r11,#0]
00002c  e054              B        |L20.216|
                  |L20.46|
;;;3424   		} else {
;;;3425   			/* Get number of free clusters */
;;;3426   			fat = fs->fs_type;
00002e  f896a000          LDRB     r10,[r6,#0]
;;;3427   			nfree = 0;
000032  2500              MOVS     r5,#0
;;;3428   			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
000034  f1ba0f01          CMP      r10,#1
000038  d004              BEQ      |L20.68|
;;;3429   				clst = 2;
;;;3430   				do {
;;;3431   					stat = get_fat(fs, clst);
;;;3432   					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
;;;3433   					if (stat == 1) { res = FR_INT_ERR; break; }
;;;3434   					if (stat == 0) nfree++;
;;;3435   				} while (++clst < fs->n_fatent);
;;;3436   			} else {				/* Sector alighed entries: Accelerate the FAT search. */
;;;3437   				clst = fs->n_fatent; sect = fs->fatbase;
00003a  6a37              LDR      r7,[r6,#0x20]
;;;3438   				i = 0; p = 0;
00003c  2000              MOVS     r0,#0
00003e  2400              MOVS     r4,#0
                  |L20.64|
;;;3439   				do {
;;;3440   					if (!i) {
000040  b1b8              CBZ      r0,|L20.114|
000042  e023              B        |L20.140|
                  |L20.68|
000044  2402              MOVS     r4,#2                 ;3429
                  |L20.70|
000046  4621              MOV      r1,r4                 ;3431
000048  4630              MOV      r0,r6                 ;3431
00004a  f7fffffe          BL       get_fat
00004e  1c41              ADDS     r1,r0,#1              ;3432
000050  d003              BEQ      |L20.90|
000052  2801              CMP      r0,#1                 ;3433
000054  d004              BEQ      |L20.96|
000056  b130              CBZ      r0,|L20.102|
000058  e006              B        |L20.104|
                  |L20.90|
00005a  f04f0801          MOV      r8,#1                 ;3432
00005e  e034              B        |L20.202|
                  |L20.96|
000060  f04f0802          MOV      r8,#2                 ;3433
000064  e031              B        |L20.202|
                  |L20.102|
000066  1c6d              ADDS     r5,r5,#1              ;3434
                  |L20.104|
000068  6970              LDR      r0,[r6,#0x14]         ;3435
00006a  1c64              ADDS     r4,r4,#1              ;3435
00006c  4284              CMP      r4,r0                 ;3435
00006e  d3ea              BCC      |L20.70|
000070  e02b              B        |L20.202|
                  |L20.114|
;;;3441   						res = move_window(fs, sect++);
000072  4639              MOV      r1,r7
000074  1c7f              ADDS     r7,r7,#1
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       move_window
00007c  4680              MOV      r8,r0
;;;3442   						if (res != FR_OK) break;
00007e  ea5f0008          MOVS     r0,r8
000082  d122              BNE      |L20.202|
;;;3443   						p = fs->win;
000084  f1060430          ADD      r4,r6,#0x30
;;;3444   						i = SS(fs);
000088  f44f7000          MOV      r0,#0x200
                  |L20.140|
;;;3445   					}
;;;3446   					if (fat == FS_FAT16) {
00008c  f1ba0f02          CMP      r10,#2
000090  d00c              BEQ      |L20.172|
;;;3447   						if (LD_WORD(p) == 0) nfree++;
;;;3448   						p += 2; i -= 2;
;;;3449   					} else {
;;;3450   						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
000092  7821              LDRB     r1,[r4,#0]
000094  78e2              LDRB     r2,[r4,#3]
000096  7863              LDRB     r3,[r4,#1]
000098  ea416102          ORR      r1,r1,r2,LSL #24
00009c  78a2              LDRB     r2,[r4,#2]
00009e  0412              LSLS     r2,r2,#16
0000a0  ea422203          ORR      r2,r2,r3,LSL #8
0000a4  4311              ORRS     r1,r1,r2
0000a6  0109              LSLS     r1,r1,#4
0000a8  d009              BEQ      |L20.190|
0000aa  e009              B        |L20.192|
                  |L20.172|
0000ac  7821              LDRB     r1,[r4,#0]            ;3447
0000ae  7862              LDRB     r2,[r4,#1]            ;3447
0000b0  ea512102          ORRS     r1,r1,r2,LSL #8       ;3447
0000b4  d100              BNE      |L20.184|
0000b6  1c6d              ADDS     r5,r5,#1              ;3447
                  |L20.184|
0000b8  1ca4              ADDS     r4,r4,#2              ;3448
0000ba  1e80              SUBS     r0,r0,#2              ;3448
0000bc  e002              B        |L20.196|
                  |L20.190|
0000be  1c6d              ADDS     r5,r5,#1
                  |L20.192|
;;;3451   						p += 4; i -= 4;
0000c0  1d24              ADDS     r4,r4,#4
0000c2  1f00              SUBS     r0,r0,#4
                  |L20.196|
;;;3452   					}
;;;3453   				} while (--clst);
0000c4  f1b90901          SUBS     r9,r9,#1
0000c8  d1ba              BNE      |L20.64|
                  |L20.202|
;;;3454   			}
;;;3455   			fs->free_clust = nfree;	/* free_clust is valid */
0000ca  6135              STR      r5,[r6,#0x10]
;;;3456   			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
0000cc  7970              LDRB     r0,[r6,#5]
0000ce  f0400001          ORR      r0,r0,#1
0000d2  7170              STRB     r0,[r6,#5]
;;;3457   			*nclst = nfree;			/* Return the free clusters */
0000d4  f8cb5000          STR      r5,[r11,#0]
                  |L20.216|
;;;3458   		}
;;;3459   	}
;;;3460   	LEAVE_FF(fs, res);
0000d8  4640              MOV      r0,r8
;;;3461   }
0000da  e8bd8ffe          POP      {r1-r11,pc}
;;;3462   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;3028   
;;;3029   FRESULT f_lseek (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3030   	FIL* fp,		/* Pointer to the file object */
;;;3031   	DWORD ofs		/* File pointer from top of file */
;;;3032   )
;;;3033   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3034   	FRESULT res;
;;;3035   	DWORD clst, bcs, nsect, ifptr;
;;;3036   #if _USE_FASTSEEK
;;;3037   	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;3038   #endif
;;;3039   
;;;3040   
;;;3041   	res = validate(fp);					/* Check validity of the object */
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       validate
00000e  4680              MOV      r8,r0
;;;3042   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000010  ea5f0008          MOVS     r0,r8
000014  d001              BEQ      |L21.26|
                  |L21.22|
;;;3043   	if (fp->err)						/* Check error */
;;;3044   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;3045   
;;;3046   #if _USE_FASTSEEK
;;;3047   	if (fp->cltbl) {	/* Fast seek */
;;;3048   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;3049   			tbl = fp->cltbl;
;;;3050   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;3051   			cl = fp->sclust;			/* Top of the chain */
;;;3052   			if (cl) {
;;;3053   				do {
;;;3054   					/* Get a fragment */
;;;3055   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;3056   					do {
;;;3057   						pcl = cl; ncl++;
;;;3058   						cl = get_fat(fp->fs, cl);
;;;3059   						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;3060   						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3061   					} while (cl == pcl + 1);
;;;3062   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;3063   						*tbl++ = ncl; *tbl++ = tcl;
;;;3064   					}
;;;3065   				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;;;3066   			}
;;;3067   			*fp->cltbl = ulen;	/* Number of items used */
;;;3068   			if (ulen <= tlen)
;;;3069   				*tbl = 0;		/* Terminate table */
;;;3070   			else
;;;3071   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;3072   
;;;3073   		} else {						/* Fast seek */
;;;3074   			if (ofs > fp->fsize)		/* Clip offset at the file size */
;;;3075   				ofs = fp->fsize;
;;;3076   			fp->fptr = ofs;				/* Set file pointer */
;;;3077   			if (ofs) {
;;;3078   				fp->clust = clmt_clust(fp, ofs - 1);
;;;3079   				dsc = clust2sect(fp->fs, fp->clust);
;;;3080   				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;;;3081   				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;;;3082   				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;;;3083   #if !_FS_TINY
;;;3084   #if !_FS_READONLY
;;;3085   					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;3086   						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;3087   							ABORT(fp->fs, FR_DISK_ERR);
;;;3088   						fp->flag &= ~FA__DIRTY;
;;;3089   					}
;;;3090   #endif
;;;3091   					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
;;;3092   						ABORT(fp->fs, FR_DISK_ERR);
;;;3093   #endif
;;;3094   					fp->dsect = dsc;
;;;3095   				}
;;;3096   			}
;;;3097   		}
;;;3098   	} else
;;;3099   #endif
;;;3100   
;;;3101   	/* Normal Seek */
;;;3102   	{
;;;3103   		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
;;;3104   #if !_FS_READONLY
;;;3105   			 && !(fp->flag & FA_WRITE)
;;;3106   #endif
;;;3107   			) ofs = fp->fsize;
;;;3108   
;;;3109   		ifptr = fp->fptr;
;;;3110   		fp->fptr = nsect = 0;
;;;3111   		if (ofs) {
;;;3112   			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
;;;3113   			if (ifptr > 0 &&
;;;3114   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;3115   				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;3116   				ofs -= fp->fptr;
;;;3117   				clst = fp->clust;
;;;3118   			} else {									/* When seek to back cluster, */
;;;3119   				clst = fp->sclust;						/* start from the first cluster */
;;;3120   #if !_FS_READONLY
;;;3121   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;3122   					clst = create_chain(fp->fs, 0);
;;;3123   					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;3124   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3125   					fp->sclust = clst;
;;;3126   				}
;;;3127   #endif
;;;3128   				fp->clust = clst;
;;;3129   			}
;;;3130   			if (clst != 0) {
;;;3131   				while (ofs > bcs) {						/* Cluster following loop */
;;;3132   #if !_FS_READONLY
;;;3133   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;;;3134   						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
;;;3135   						if (clst == 0) {				/* When disk gets full, clip file size */
;;;3136   							ofs = bcs; break;
;;;3137   						}
;;;3138   					} else
;;;3139   #endif
;;;3140   						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
;;;3141   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3142   					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
;;;3143   					fp->clust = clst;
;;;3144   					fp->fptr += bcs;
;;;3145   					ofs -= bcs;
;;;3146   				}
;;;3147   				fp->fptr += ofs;
;;;3148   				if (ofs % SS(fp->fs)) {
;;;3149   					nsect = clust2sect(fp->fs, clst);	/* Current sector */
;;;3150   					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
;;;3151   					nsect += ofs / SS(fp->fs);
;;;3152   				}
;;;3153   			}
;;;3154   		}
;;;3155   		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
;;;3156   #if !_FS_TINY
;;;3157   #if !_FS_READONLY
;;;3158   			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
;;;3159   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;3160   					ABORT(fp->fs, FR_DISK_ERR);
;;;3161   				fp->flag &= ~FA__DIRTY;
;;;3162   			}
;;;3163   #endif
;;;3164   			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
;;;3165   				ABORT(fp->fs, FR_DISK_ERR);
;;;3166   #endif
;;;3167   			fp->dsect = nsect;
;;;3168   		}
;;;3169   #if !_FS_READONLY
;;;3170   		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;;;3171   			fp->fsize = fp->fptr;
;;;3172   			fp->flag |= FA__WRITTEN;
;;;3173   		}
;;;3174   #endif
;;;3175   	}
;;;3176   
;;;3177   	LEAVE_FF(fp->fs, res);
;;;3178   }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L21.26|
00001a  79e0              LDRB     r0,[r4,#7]            ;3043
00001c  2800              CMP      r0,#0                 ;3043
00001e  d1fa              BNE      |L21.22|
000020  68e0              LDR      r0,[r4,#0xc]          ;3103
000022  42a8              CMP      r0,r5                 ;3103
000024  d203              BCS      |L21.46|
000026  79a1              LDRB     r1,[r4,#6]            ;3105
000028  0789              LSLS     r1,r1,#30             ;3105
00002a  d400              BMI      |L21.46|
00002c  4605              MOV      r5,r0                 ;3107
                  |L21.46|
00002e  68a0              LDR      r0,[r4,#8]            ;3109
000030  2700              MOVS     r7,#0                 ;3110
000032  60a7              STR      r7,[r4,#8]            ;3110
000034  f04f0901          MOV      r9,#1                 ;3035
000038  b30d              CBZ      r5,|L21.126|
00003a  6822              LDR      r2,[r4,#0]            ;3112
00003c  7891              LDRB     r1,[r2,#2]            ;3112
00003e  024e              LSLS     r6,r1,#9              ;3112
000040  f04f0a02          MOV      r10,#2                ;3123
000044  b168              CBZ      r0,|L21.98|
000046  1e69              SUBS     r1,r5,#1              ;3114
000048  1e40              SUBS     r0,r0,#1              ;3114
00004a  fbb1f1f6          UDIV     r1,r1,r6              ;3114
00004e  fbb0f3f6          UDIV     r3,r0,r6              ;3114
000052  4299              CMP      r1,r3                 ;3114
000054  d305              BCC      |L21.98|
000056  1e71              SUBS     r1,r6,#1              ;3115
000058  4388              BICS     r0,r0,r1              ;3115
00005a  60a0              STR      r0,[r4,#8]            ;3115
00005c  1a2d              SUBS     r5,r5,r0              ;3116
00005e  6961              LDR      r1,[r4,#0x14]         ;3117
000060  e00c              B        |L21.124|
                  |L21.98|
000062  6921              LDR      r1,[r4,#0x10]         ;3119
000064  b949              CBNZ     r1,|L21.122|
000066  2100              MOVS     r1,#0                 ;3122
000068  4610              MOV      r0,r2                 ;3122
00006a  f7fffffe          BL       create_chain
00006e  4601              MOV      r1,r0                 ;3122
000070  2901              CMP      r1,#1                 ;3123
000072  d005              BEQ      |L21.128|
000074  1c48              ADDS     r0,r1,#1              ;3124
000076  d007              BEQ      |L21.136|
000078  6121              STR      r1,[r4,#0x10]         ;3125
                  |L21.122|
00007a  6161              STR      r1,[r4,#0x14]         ;3128
                  |L21.124|
00007c  bb59              CBNZ     r1,|L21.214|
                  |L21.126|
00007e  e037              B        |L21.240|
                  |L21.128|
000080  f884a007          STRB     r10,[r4,#7]           ;3123
000084  2002              MOVS     r0,#2                 ;3123
000086  e7c6              B        |L21.22|
                  |L21.136|
000088  f8849007          STRB     r9,[r4,#7]            ;3124
00008c  2001              MOVS     r0,#1                 ;3124
00008e  e7c2              B        |L21.22|
                  |L21.144|
000090  79a0              LDRB     r0,[r4,#6]            ;3133
000092  0780              LSLS     r0,r0,#30             ;3133
000094  d506              BPL      |L21.164|
000096  6820              LDR      r0,[r4,#0]            ;3134
000098  f7fffffe          BL       create_chain
00009c  4601              MOV      r1,r0                 ;3134
00009e  b929              CBNZ     r1,|L21.172|
0000a0  4635              MOV      r5,r6                 ;3136
0000a2  e01a              B        |L21.218|
                  |L21.164|
0000a4  6820              LDR      r0,[r4,#0]            ;3140
0000a6  f7fffffe          BL       get_fat
0000aa  4601              MOV      r1,r0                 ;3140
                  |L21.172|
0000ac  1c48              ADDS     r0,r1,#1              ;3141
0000ae  d009              BEQ      |L21.196|
0000b0  2901              CMP      r1,#1                 ;3142
0000b2  d903              BLS      |L21.188|
0000b4  6820              LDR      r0,[r4,#0]            ;3142
0000b6  6940              LDR      r0,[r0,#0x14]         ;3142
0000b8  4288              CMP      r0,r1                 ;3142
0000ba  d807              BHI      |L21.204|
                  |L21.188|
0000bc  f884a007          STRB     r10,[r4,#7]           ;3142
0000c0  2002              MOVS     r0,#2                 ;3142
0000c2  e7a8              B        |L21.22|
                  |L21.196|
0000c4  f8849007          STRB     r9,[r4,#7]            ;3141
0000c8  2001              MOVS     r0,#1                 ;3141
0000ca  e7a4              B        |L21.22|
                  |L21.204|
0000cc  6161              STR      r1,[r4,#0x14]         ;3143
0000ce  68a0              LDR      r0,[r4,#8]            ;3144
0000d0  4430              ADD      r0,r0,r6              ;3144
0000d2  60a0              STR      r0,[r4,#8]            ;3144
0000d4  1bad              SUBS     r5,r5,r6              ;3145
                  |L21.214|
0000d6  42b5              CMP      r5,r6                 ;3131
0000d8  d8da              BHI      |L21.144|
                  |L21.218|
0000da  68a0              LDR      r0,[r4,#8]            ;3147
0000dc  4428              ADD      r0,r0,r5              ;3147
0000de  60a0              STR      r0,[r4,#8]            ;3147
0000e0  05e8              LSLS     r0,r5,#23             ;3148
0000e2  d005              BEQ      |L21.240|
0000e4  6820              LDR      r0,[r4,#0]            ;3149
0000e6  f7fffffe          BL       clust2sect
0000ea  b1b8              CBZ      r0,|L21.284|
0000ec  eb002755          ADD      r7,r0,r5,LSR #9       ;3151
                  |L21.240|
0000f0  8920              LDRH     r0,[r4,#8]            ;3155
0000f2  05c0              LSLS     r0,r0,#23             ;3155
0000f4  d027              BEQ      |L21.326|
0000f6  69a2              LDR      r2,[r4,#0x18]         ;3155
0000f8  42ba              CMP      r2,r7                 ;3155
0000fa  d024              BEQ      |L21.326|
0000fc  79a0              LDRB     r0,[r4,#6]            ;3158
0000fe  f1040528          ADD      r5,r4,#0x28           ;3159
000102  0640              LSLS     r0,r0,#25             ;3158
000104  d512              BPL      |L21.300|
000106  6820              LDR      r0,[r4,#0]            ;3159
000108  2301              MOVS     r3,#1                 ;3159
00010a  4629              MOV      r1,r5                 ;3159
00010c  7840              LDRB     r0,[r0,#1]            ;3159
00010e  f7fffffe          BL       disk_write
000112  b138              CBZ      r0,|L21.292|
000114  f8849007          STRB     r9,[r4,#7]            ;3160
000118  2001              MOVS     r0,#1                 ;3160
00011a  e77c              B        |L21.22|
                  |L21.284|
00011c  f884a007          STRB     r10,[r4,#7]           ;3150
000120  2002              MOVS     r0,#2                 ;3150
000122  e778              B        |L21.22|
                  |L21.292|
000124  79a0              LDRB     r0,[r4,#6]            ;3161
000126  f0200040          BIC      r0,r0,#0x40           ;3161
00012a  71a0              STRB     r0,[r4,#6]            ;3161
                  |L21.300|
00012c  6820              LDR      r0,[r4,#0]            ;3164
00012e  2301              MOVS     r3,#1                 ;3164
000130  463a              MOV      r2,r7                 ;3164
000132  7840              LDRB     r0,[r0,#1]            ;3164
000134  4629              MOV      r1,r5                 ;3164
000136  f7fffffe          BL       disk_read
00013a  b118              CBZ      r0,|L21.324|
00013c  f8849007          STRB     r9,[r4,#7]            ;3165
000140  2001              MOVS     r0,#1                 ;3165
000142  e768              B        |L21.22|
                  |L21.324|
000144  61a7              STR      r7,[r4,#0x18]         ;3167
                  |L21.326|
000146  e9d40102          LDRD     r0,r1,[r4,#8]         ;3170
00014a  4288              CMP      r0,r1                 ;3170
00014c  d904              BLS      |L21.344|
00014e  60e0              STR      r0,[r4,#0xc]          ;3171
000150  79a0              LDRB     r0,[r4,#6]            ;3172
000152  f0400020          ORR      r0,r0,#0x20           ;3172
000156  71a0              STRB     r0,[r4,#6]            ;3172
                  |L21.344|
000158  4640              MOV      r0,r8                 ;3177
00015a  e75c              B        |L21.22|
;;;3179   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=1

                  f_mkdir PROC
;;;3594   
;;;3595   FRESULT f_mkdir (
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;3596   	const TCHAR* path		/* Pointer to the directory path */
;;;3597   )
;;;3598   {
000004  b08c              SUB      sp,sp,#0x30
;;;3599   	FRESULT res;
;;;3600   	DIR dj;
;;;3601   	BYTE *dir, n;
;;;3602   	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
000006  f7fffffe          BL       get_fattime
00000a  4606              MOV      r6,r0
;;;3603   	DEFINE_NAMEBUF;
;;;3604   
;;;3605   
;;;3606   	/* Get logical drive number */
;;;3607   	res = find_volume(&dj.fs, &path, 1);
00000c  2201              MOVS     r2,#1
00000e  a90c              ADD      r1,sp,#0x30
000010  a803              ADD      r0,sp,#0xc
000012  f7fffffe          BL       find_volume
000016  4604              MOV      r4,r0
;;;3608   	if (res == FR_OK) {
000018  0020              MOVS     r0,r4
00001a  d17d              BNE      |L22.280|
;;;3609   		INIT_BUF(dj);
00001c  f8cdd024          STR      sp,[sp,#0x24]
;;;3610   		res = follow_path(&dj, path);			/* Follow the file path */
000020  a803              ADD      r0,sp,#0xc
000022  990c              LDR      r1,[sp,#0x30]
000024  f7fffffe          BL       follow_path
000028  4604              MOV      r4,r0
;;;3611   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
00002a  0020              MOVS     r0,r4
00002c  d100              BNE      |L22.48|
00002e  2408              MOVS     r4,#8
                  |L22.48|
;;;3612   		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
;;;3613   			res = FR_INVALID_NAME;
;;;3614   		if (res == FR_NO_FILE) {				/* Can create a new directory */
000030  2c04              CMP      r4,#4
000032  d171              BNE      |L22.280|
;;;3615   			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
000034  2100              MOVS     r1,#0
000036  9803              LDR      r0,[sp,#0xc]
000038  f7fffffe          BL       create_chain
00003c  4680              MOV      r8,r0
;;;3616   			res = FR_OK;
00003e  2400              MOVS     r4,#0
;;;3617   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
000040  f1b80f00          CMP      r8,#0
000044  d100              BNE      |L22.72|
000046  2407              MOVS     r4,#7
                  |L22.72|
;;;3618   			if (dcl == 1) res = FR_INT_ERR;
000048  f1b80f01          CMP      r8,#1
00004c  d100              BNE      |L22.80|
00004e  2402              MOVS     r4,#2
                  |L22.80|
;;;3619   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
000050  f1b83fff          CMP      r8,#0xffffffff
000054  d100              BNE      |L22.88|
000056  2401              MOVS     r4,#1
                  |L22.88|
;;;3620   			if (res == FR_OK)					/* Flush FAT */
000058  b91c              CBNZ     r4,|L22.98|
;;;3621   				res = sync_window(dj.fs);
00005a  9803              LDR      r0,[sp,#0xc]
00005c  f7fffffe          BL       sync_window
000060  4604              MOV      r4,r0
                  |L22.98|
;;;3622   			if (res == FR_OK) {					/* Initialize the new directory table */
;;;3623   				dsc = clust2sect(dj.fs, dcl);
;;;3624   				dir = dj.fs->win;
;;;3625   				mem_set(dir, 0, SS(dj.fs));
;;;3626   				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
;;;3627   				dir[DIR_Name] = '.';
;;;3628   				dir[DIR_Attr] = AM_DIR;
000062  f04f0a10          MOV      r10,#0x10
000066  f04f0901          MOV      r9,#1                 ;3607
00006a  bbcc              CBNZ     r4,|L22.224|
00006c  4641              MOV      r1,r8                 ;3623
00006e  9803              LDR      r0,[sp,#0xc]          ;3623
000070  f7fffffe          BL       clust2sect
000074  4683              MOV      r11,r0                ;3623
000076  9d03              LDR      r5,[sp,#0xc]          ;3624
000078  3530              ADDS     r5,r5,#0x30           ;3624
00007a  f44f7200          MOV      r2,#0x200             ;3625
00007e  2100              MOVS     r1,#0                 ;3625
000080  4628              MOV      r0,r5                 ;3625
000082  f7fffffe          BL       mem_set
000086  220b              MOVS     r2,#0xb               ;3626
000088  2120              MOVS     r1,#0x20              ;3626
00008a  4628              MOV      r0,r5                 ;3626
00008c  f7fffffe          BL       mem_set
000090  272e              MOVS     r7,#0x2e              ;3627
000092  702f              STRB     r7,[r5,#0]            ;3627
000094  f885a00b          STRB     r10,[r5,#0xb]
;;;3629   				ST_DWORD(dir + DIR_WrtTime, tm);
000098  75ae              STRB     r6,[r5,#0x16]
00009a  0a30              LSRS     r0,r6,#8
00009c  75e8              STRB     r0,[r5,#0x17]
00009e  0c30              LSRS     r0,r6,#16
0000a0  7628              STRB     r0,[r5,#0x18]
0000a2  0e30              LSRS     r0,r6,#24
0000a4  7668              STRB     r0,[r5,#0x19]
;;;3630   				st_clust(dir, dcl);
0000a6  4641              MOV      r1,r8
0000a8  4628              MOV      r0,r5
0000aa  f7fffffe          BL       st_clust
;;;3631   				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
0000ae  f1050020          ADD      r0,r5,#0x20
0000b2  2220              MOVS     r2,#0x20
0000b4  4629              MOV      r1,r5
0000b6  900b              STR      r0,[sp,#0x2c]
0000b8  f7fffffe          BL       mem_cpy
;;;3632   				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
0000bc  f8857021          STRB     r7,[r5,#0x21]
0000c0  9905              LDR      r1,[sp,#0x14]
;;;3633   				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
0000c2  9803              LDR      r0,[sp,#0xc]
0000c4  7800              LDRB     r0,[r0,#0]
0000c6  2803              CMP      r0,#3
0000c8  d104              BNE      |L22.212|
0000ca  9803              LDR      r0,[sp,#0xc]
0000cc  6a40              LDR      r0,[r0,#0x24]
0000ce  4288              CMP      r0,r1
0000d0  d100              BNE      |L22.212|
;;;3634   					pcl = 0;
0000d2  2100              MOVS     r1,#0
                  |L22.212|
;;;3635   				st_clust(dir + SZ_DIRE, pcl);
0000d4  980b              LDR      r0,[sp,#0x2c]
0000d6  f7fffffe          BL       st_clust
;;;3636   				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
0000da  9803              LDR      r0,[sp,#0xc]
0000dc  7887              LDRB     r7,[r0,#2]
0000de  e016              B        |L22.270|
                  |L22.224|
0000e0  e017              B        |L22.274|
                  |L22.226|
;;;3637   					dj.fs->winsect = dsc++;
0000e2  9803              LDR      r0,[sp,#0xc]
0000e4  f8c0b02c          STR      r11,[r0,#0x2c]
0000e8  f10b0b01          ADD      r11,r11,#1
;;;3638   					dj.fs->wflag = 1;
0000ec  9803              LDR      r0,[sp,#0xc]
0000ee  f8809004          STRB     r9,[r0,#4]
;;;3639   					res = sync_window(dj.fs);
0000f2  9803              LDR      r0,[sp,#0xc]
0000f4  f7fffffe          BL       sync_window
0000f8  4604              MOV      r4,r0
;;;3640   					if (res != FR_OK) break;
0000fa  0020              MOVS     r0,r4
0000fc  d109              BNE      |L22.274|
;;;3641   					mem_set(dir, 0, SS(dj.fs));
0000fe  f44f7200          MOV      r2,#0x200
000102  2100              MOVS     r1,#0
000104  4628              MOV      r0,r5
000106  f7fffffe          BL       mem_set
00010a  1e7f              SUBS     r7,r7,#1              ;3636
00010c  b2ff              UXTB     r7,r7                 ;3636
                  |L22.270|
00010e  2f00              CMP      r7,#0                 ;3636
000110  d1e7              BNE      |L22.226|
                  |L22.274|
;;;3642   				}
;;;3643   			}
;;;3644   			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
000112  b92c              CBNZ     r4,|L22.288|
000114  a803              ADD      r0,sp,#0xc
000116  e000              B        |L22.282|
                  |L22.280|
000118  e01c              B        |L22.340|
                  |L22.282|
00011a  f7fffffe          BL       dir_register
00011e  4604              MOV      r4,r0
                  |L22.288|
;;;3645   			if (res != FR_OK) {
000120  b124              CBZ      r4,|L22.300|
;;;3646   				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
000122  4641              MOV      r1,r8
000124  9803              LDR      r0,[sp,#0xc]
000126  f7fffffe          BL       remove_chain
00012a  e013              B        |L22.340|
                  |L22.300|
;;;3647   			} else {
;;;3648   				dir = dj.dir;
00012c  9808              LDR      r0,[sp,#0x20]
;;;3649   				dir[DIR_Attr] = AM_DIR;				/* Attribute */
00012e  f880a00b          STRB     r10,[r0,#0xb]
;;;3650   				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
000132  7586              STRB     r6,[r0,#0x16]
000134  0a31              LSRS     r1,r6,#8
000136  75c1              STRB     r1,[r0,#0x17]
000138  0c31              LSRS     r1,r6,#16
00013a  7601              STRB     r1,[r0,#0x18]
00013c  0e31              LSRS     r1,r6,#24
00013e  7641              STRB     r1,[r0,#0x19]
;;;3651   				st_clust(dir, dcl);					/* Table start cluster */
000140  4641              MOV      r1,r8
000142  f7fffffe          BL       st_clust
;;;3652   				dj.fs->wflag = 1;
000146  9803              LDR      r0,[sp,#0xc]
000148  f8809004          STRB     r9,[r0,#4]
;;;3653   				res = sync_fs(dj.fs);
00014c  9803              LDR      r0,[sp,#0xc]
00014e  f7fffffe          BL       sync_fs
000152  4604              MOV      r4,r0
                  |L22.340|
;;;3654   			}
;;;3655   		}
;;;3656   		FREE_BUF();
;;;3657   	}
;;;3658   
;;;3659   	LEAVE_FF(dj.fs, res);
;;;3660   }
000154  b00d              ADD      sp,sp,#0x34
000156  4620              MOV      r0,r4                 ;3659
000158  e8bd8ff0          POP      {r4-r11,pc}
;;;3661   
                          ENDP


                          AREA ||i.f_mkfs||, CODE, READONLY, ALIGN=2

                  f_mkfs PROC
;;;4062   
;;;4063   FRESULT f_mkfs (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;4064   	const TCHAR* path,	/* Logical drive number */
;;;4065   	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
;;;4066   	UINT au				/* Size of allocation unit in unit of byte or sector */
;;;4067   )
;;;4068   {
000004  b088              SUB      sp,sp,#0x20
000006  4617              MOV      r7,r2
;;;4069   	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
;;;4070   	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
;;;4071   	int vol;
;;;4072   	BYTE fmt, md, sys, *tbl, pdrv, part;
;;;4073   	DWORD n_clst, vs, n, wsect;
;;;4074   	UINT i;
;;;4075   	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
;;;4076   	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
;;;4077   	FATFS *fs;
;;;4078   	DSTATUS stat;
;;;4079   #if _USE_TRIM
;;;4080   	DWORD eb[2];
;;;4081   #endif
;;;4082   
;;;4083   
;;;4084   	/* Check mounted drive and clear work area */
;;;4085   	if (sfd > 1) return FR_INVALID_PARAMETER;
000008  9809              LDR      r0,[sp,#0x24]
00000a  2801              CMP      r0,#1
00000c  d903              BLS      |L23.22|
00000e  2013              MOVS     r0,#0x13
                  |L23.16|
;;;4086   	vol = get_ldnumber(&path);
;;;4087   	if (vol < 0) return FR_INVALID_DRIVE;
;;;4088   	fs = FatFs[vol];
;;;4089   	if (!fs) return FR_NOT_ENABLED;
;;;4090   	fs->fs_type = 0;
;;;4091   	pdrv = LD2PD(vol);	/* Physical drive */
;;;4092   	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
;;;4093   
;;;4094   	/* Get disk statics */
;;;4095   	stat = disk_initialize(pdrv);
;;;4096   	if (stat & STA_NOINIT) return FR_NOT_READY;
;;;4097   	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
;;;4098   #if _MAX_SS != _MIN_SS		/* Get disk sector size */
;;;4099   	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS)
;;;4100   		return FR_DISK_ERR;
;;;4101   #endif
;;;4102   	if (_MULTI_PARTITION && part) {
;;;4103   		/* Get partition information from partition table in the MBR */
;;;4104   		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
;;;4105   		if (LD_WORD(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
;;;4106   		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;;;4107   		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
;;;4108   		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
;;;4109   		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
;;;4110   	} else {
;;;4111   		/* Create a partition in this function */
;;;4112   		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
;;;4113   			return FR_DISK_ERR;
;;;4114   		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
;;;4115   		n_vol -= b_vol;				/* Volume size */
;;;4116   	}
;;;4117   
;;;4118   	if (au & (au - 1)) au = 0;
;;;4119   	if (!au) {						/* AU auto selection */
;;;4120   		vs = n_vol / (2000 / (SS(fs) / 512));
;;;4121   		for (i = 0; vs < vst[i]; i++) ;
;;;4122   		au = cst[i];
;;;4123   	}
;;;4124   	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
;;;4125   	if (!au) au = 1;
;;;4126   	if (au > 128) au = 128;
;;;4127   
;;;4128   	/* Pre-compute number of clusters and FAT sub-type */
;;;4129   	n_clst = n_vol / au;
;;;4130   	fmt = FS_FAT12;
;;;4131   	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
;;;4132   	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
;;;4133   
;;;4134   	/* Determine offset and size of FAT structure */
;;;4135   	if (fmt == FS_FAT32) {
;;;4136   		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
;;;4137   		n_rsv = 32;
;;;4138   		n_dir = 0;
;;;4139   	} else {
;;;4140   		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
;;;4141   		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
;;;4142   		n_rsv = 1;
;;;4143   		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
;;;4144   	}
;;;4145   	b_fat = b_vol + n_rsv;				/* FAT area start sector */
;;;4146   	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
;;;4147   	b_data = b_dir + n_dir;				/* Data area start sector */
;;;4148   	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
;;;4149   
;;;4150   	/* Align data start sector to erase block boundary (for flash memory media) */
;;;4151   	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
;;;4152   	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
;;;4153   	n = (n - b_data) / N_FATS;
;;;4154   	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
;;;4155   		n_rsv += n;
;;;4156   		b_fat += n;
;;;4157   	} else {					/* FAT12/16: Expand FAT size */
;;;4158   		n_fat += n;
;;;4159   	}
;;;4160   
;;;4161   	/* Determine number of clusters and final check of validity of the FAT sub-type */
;;;4162   	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
;;;4163   	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
;;;4164   		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
;;;4165   		return FR_MKFS_ABORTED;
;;;4166   
;;;4167   	/* Determine system ID in the partition table */
;;;4168   	if (fmt == FS_FAT32) {
;;;4169   		sys = 0x0C;		/* FAT32X */
;;;4170   	} else {
;;;4171   		if (fmt == FS_FAT12 && n_vol < 0x10000) {
;;;4172   			sys = 0x01;	/* FAT12(<65536) */
;;;4173   		} else {
;;;4174   			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
;;;4175   		}
;;;4176   	}
;;;4177   
;;;4178   	if (_MULTI_PARTITION && part) {
;;;4179   		/* Update system ID in the partition table */
;;;4180   		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;;;4181   		tbl[4] = sys;
;;;4182   		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
;;;4183   			return FR_DISK_ERR;
;;;4184   		md = 0xF8;
;;;4185   	} else {
;;;4186   		if (sfd) {	/* No partition table (SFD) */
;;;4187   			md = 0xF0;
;;;4188   		} else {	/* Create partition table (FDISK) */
;;;4189   			mem_set(fs->win, 0, SS(fs));
;;;4190   			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
;;;4191   			tbl[1] = 1;						/* Partition start head */
;;;4192   			tbl[2] = 1;						/* Partition start sector */
;;;4193   			tbl[3] = 0;						/* Partition start cylinder */
;;;4194   			tbl[4] = sys;					/* System type */
;;;4195   			tbl[5] = 254;					/* Partition end head */
;;;4196   			n = (b_vol + n_vol) / 63 / 255;
;;;4197   			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
;;;4198   			tbl[7] = (BYTE)n;				/* End cylinder */
;;;4199   			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
;;;4200   			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
;;;4201   			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
;;;4202   			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
;;;4203   				return FR_DISK_ERR;
;;;4204   			md = 0xF8;
;;;4205   		}
;;;4206   	}
;;;4207   
;;;4208   	/* Create BPB in the VBR */
;;;4209   	tbl = fs->win;							/* Clear sector */
;;;4210   	mem_set(tbl, 0, SS(fs));
;;;4211   	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
;;;4212   	i = SS(fs);								/* Sector size */
;;;4213   	ST_WORD(tbl + BPB_BytsPerSec, i);
;;;4214   	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
;;;4215   	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
;;;4216   	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
;;;4217   	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
;;;4218   	ST_WORD(tbl + BPB_RootEntCnt, i);
;;;4219   	if (n_vol < 0x10000) {					/* Number of total sectors */
;;;4220   		ST_WORD(tbl + BPB_TotSec16, n_vol);
;;;4221   	} else {
;;;4222   		ST_DWORD(tbl + BPB_TotSec32, n_vol);
;;;4223   	}
;;;4224   	tbl[BPB_Media] = md;					/* Media descriptor */
;;;4225   	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
;;;4226   	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
;;;4227   	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
;;;4228   	n = GET_FATTIME();						/* Use current time as VSN */
;;;4229   	if (fmt == FS_FAT32) {
;;;4230   		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
;;;4231   		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
;;;4232   		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
;;;4233   		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
;;;4234   		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
;;;4235   		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
;;;4236   		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
;;;4237   		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
;;;4238   	} else {
;;;4239   		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
;;;4240   		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
;;;4241   		tbl[BS_DrvNum] = 0x80;				/* Drive number */
;;;4242   		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
;;;4243   		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
;;;4244   	}
;;;4245   	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
;;;4246   	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
;;;4247   		return FR_DISK_ERR;
;;;4248   	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
;;;4249   		disk_write(pdrv, tbl, b_vol + 6, 1);
;;;4250   
;;;4251   	/* Initialize FAT area */
;;;4252   	wsect = b_fat;
;;;4253   	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
;;;4254   		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
;;;4255   		n = md;								/* Media descriptor byte */
;;;4256   		if (fmt != FS_FAT32) {
;;;4257   			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
;;;4258   			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
;;;4259   		} else {
;;;4260   			n |= 0xFFFFFF00;
;;;4261   			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
;;;4262   			ST_DWORD(tbl + 4, 0xFFFFFFFF);
;;;4263   			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
;;;4264   		}
;;;4265   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4266   			return FR_DISK_ERR;
;;;4267   		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
;;;4268   		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
;;;4269   			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4270   				return FR_DISK_ERR;
;;;4271   		}
;;;4272   	}
;;;4273   
;;;4274   	/* Initialize root directory */
;;;4275   	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
;;;4276   	do {
;;;4277   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4278   			return FR_DISK_ERR;
;;;4279   	} while (--i);
;;;4280   
;;;4281   #if _USE_TRIM	/* Erase data area if needed */
;;;4282   	{
;;;4283   		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
;;;4284   		disk_ioctl(pdrv, CTRL_TRIM, eb);
;;;4285   	}
;;;4286   #endif
;;;4287   
;;;4288   	/* Create FSINFO if needed */
;;;4289   	if (fmt == FS_FAT32) {
;;;4290   		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
;;;4291   		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
;;;4292   		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
;;;4293   		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
;;;4294   		ST_WORD(tbl + BS_55AA, 0xAA55);
;;;4295   		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
;;;4296   		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
;;;4297   	}
;;;4298   
;;;4299   	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
;;;4300   }
000010  b00b              ADD      sp,sp,#0x2c
000012  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.22|
000016  a808              ADD      r0,sp,#0x20           ;4086
000018  f7fffffe          BL       get_ldnumber
00001c  2800              CMP      r0,#0                 ;4087
00001e  da01              BGE      |L23.36|
000020  200b              MOVS     r0,#0xb               ;4087
000022  e7f5              B        |L23.16|
                  |L23.36|
000024  49f8              LDR      r1,|L23.1032|
000026  f8514020          LDR      r4,[r1,r0,LSL #2]     ;4088
00002a  b154              CBZ      r4,|L23.66|
00002c  2100              MOVS     r1,#0                 ;4090
00002e  7021              STRB     r1,[r4,#0]            ;4090
000030  b2c0              UXTB     r0,r0                 ;4091
000032  9004              STR      r0,[sp,#0x10]         ;4091
000034  9804              LDR      r0,[sp,#0x10]         ;4095
000036  f7fffffe          BL       disk_initialize
00003a  07c1              LSLS     r1,r0,#31             ;4096
00003c  d003              BEQ      |L23.70|
00003e  2003              MOVS     r0,#3                 ;4096
000040  e7e6              B        |L23.16|
                  |L23.66|
000042  200c              MOVS     r0,#0xc               ;4089
000044  e7e4              B        |L23.16|
                  |L23.70|
000046  0740              LSLS     r0,r0,#29             ;4097
000048  d501              BPL      |L23.78|
00004a  200a              MOVS     r0,#0xa               ;4097
00004c  e7e0              B        |L23.16|
                  |L23.78|
00004e  466a              MOV      r2,sp                 ;4112
000050  2101              MOVS     r1,#1                 ;4112
000052  9804              LDR      r0,[sp,#0x10]         ;4112
000054  f7fffffe          BL       disk_ioctl
000058  b910              CBNZ     r0,|L23.96|
00005a  9800              LDR      r0,[sp,#0]            ;4112
00005c  2880              CMP      r0,#0x80              ;4112
00005e  d201              BCS      |L23.100|
                  |L23.96|
000060  2001              MOVS     r0,#1                 ;4113
000062  e7d5              B        |L23.16|
                  |L23.100|
000064  9909              LDR      r1,[sp,#0x24]         ;4114
000066  b111              CBZ      r1,|L23.110|
000068  f04f0900          MOV      r9,#0                 ;4114
00006c  e001              B        |L23.114|
                  |L23.110|
00006e  f04f093f          MOV      r9,#0x3f              ;4114
                  |L23.114|
000072  eba00109          SUB      r1,r0,r9              ;4115
000076  9100              STR      r1,[sp,#0]            ;4115
000078  1e78              SUBS     r0,r7,#1              ;4118
00007a  4207              TST      r7,r0                 ;4118
00007c  d000              BEQ      |L23.128|
00007e  2700              MOVS     r7,#0                 ;4118
                  |L23.128|
000080  b97f              CBNZ     r7,|L23.162|
000082  f44f60fa          MOV      r0,#0x7d0             ;4120
000086  fbb1f2f0          UDIV     r2,r1,r0              ;4120
00008a  2000              MOVS     r0,#0                 ;4121
00008c  4bdf              LDR      r3,|L23.1036|
00008e  e000              B        |L23.146|
                  |L23.144|
000090  1c40              ADDS     r0,r0,#1              ;4121
                  |L23.146|
000092  f8335010          LDRH     r5,[r3,r0,LSL #1]     ;4121
000096  4295              CMP      r5,r2                 ;4121
000098  d8fa              BHI      |L23.144|
00009a  4adc              LDR      r2,|L23.1036|
00009c  3216              ADDS     r2,r2,#0x16           ;4122
00009e  f8327010          LDRH     r7,[r2,r0,LSL #1]     ;4122
                  |L23.162|
0000a2  f5b77f00          CMP      r7,#0x200             ;4124
0000a6  d300              BCC      |L23.170|
0000a8  0a7f              LSRS     r7,r7,#9              ;4124
                  |L23.170|
0000aa  b907              CBNZ     r7,|L23.174|
0000ac  2701              MOVS     r7,#1                 ;4125
                  |L23.174|
0000ae  2f80              CMP      r7,#0x80              ;4126
0000b0  d900              BLS      |L23.180|
0000b2  2780              MOVS     r7,#0x80              ;4126
                  |L23.180|
0000b4  fbb1f0f7          UDIV     r0,r1,r7              ;4129
0000b8  2601              MOVS     r6,#1                 ;4130
0000ba  f64072f6          MOV      r2,#0xff6             ;4131
0000be  4290              CMP      r0,r2                 ;4131
0000c0  d300              BCC      |L23.196|
0000c2  2602              MOVS     r6,#2                 ;4131
                  |L23.196|
0000c4  f64f72f6          MOV      r2,#0xfff6            ;4132
0000c8  4290              CMP      r0,r2                 ;4132
0000ca  d300              BCC      |L23.206|
0000cc  2603              MOVS     r6,#3                 ;4132
                  |L23.206|
0000ce  2e03              CMP      r6,#3                 ;4135
0000d0  d018              BEQ      |L23.260|
0000d2  2e01              CMP      r6,#1                 ;4140
0000d4  d020              BEQ      |L23.280|
0000d6  0040              LSLS     r0,r0,#1              ;4140
0000d8  1d00              ADDS     r0,r0,#4              ;4140
                  |L23.218|
0000da  f20010ff          ADD      r0,r0,#0x1ff          ;4141
0000de  ea4f2850          LSR      r8,r0,#9              ;4141
0000e2  2501              MOVS     r5,#1                 ;4142
0000e4  f04f0a20          MOV      r10,#0x20             ;4143
                  |L23.232|
0000e8  eb090b05          ADD      r11,r9,r5             ;4145
0000ec  eb0b0008          ADD      r0,r11,r8             ;4146
0000f0  4450              ADD      r0,r0,r10             ;4147
0000f2  9001              STR      r0,[sp,#4]            ;4147
0000f4  9801              LDR      r0,[sp,#4]            ;4148
0000f6  4438              ADD      r0,r0,r7              ;4148
0000f8  eba00009          SUB      r0,r0,r9              ;4148
0000fc  4288              CMP      r0,r1                 ;4148
0000fe  d911              BLS      |L23.292|
000100  200e              MOVS     r0,#0xe               ;4148
000102  e785              B        |L23.16|
                  |L23.260|
000104  f2402207          MOV      r2,#0x207             ;4136
000108  eb020080          ADD      r0,r2,r0,LSL #2       ;4136
00010c  ea4f2850          LSR      r8,r0,#9              ;4136
000110  2520              MOVS     r5,#0x20              ;4137
000112  f04f0a00          MOV      r10,#0                ;4138
000116  e7e7              B        |L23.232|
                  |L23.280|
000118  eb000040          ADD      r0,r0,r0,LSL #1       ;4140
00011c  1c40              ADDS     r0,r0,#1              ;4140
00011e  0840              LSRS     r0,r0,#1              ;4140
000120  1cc0              ADDS     r0,r0,#3              ;4140
000122  e7da              B        |L23.218|
                  |L23.292|
000124  aa02              ADD      r2,sp,#8              ;4151
000126  2103              MOVS     r1,#3                 ;4151
000128  9804              LDR      r0,[sp,#0x10]         ;4151
00012a  f7fffffe          BL       disk_ioctl
00012e  b920              CBNZ     r0,|L23.314|
000130  9802              LDR      r0,[sp,#8]            ;4151
000132  b110              CBZ      r0,|L23.314|
000134  f5b04f00          CMP      r0,#0x8000            ;4151
000138  d901              BLS      |L23.318|
                  |L23.314|
00013a  2001              MOVS     r0,#1                 ;4151
00013c  9002              STR      r0,[sp,#8]            ;4151
                  |L23.318|
00013e  e9dd1001          LDRD     r1,r0,[sp,#4]         ;4152
000142  4401              ADD      r1,r1,r0              ;4152
000144  1e49              SUBS     r1,r1,#1              ;4152
000146  1e40              SUBS     r0,r0,#1              ;4152
000148  4381              BICS     r1,r1,r0              ;4152
00014a  9801              LDR      r0,[sp,#4]            ;4153
00014c  1a08              SUBS     r0,r1,r0              ;4153
00014e  9002              STR      r0,[sp,#8]            ;4153
000150  2e03              CMP      r6,#3                 ;4154
000152  d00c              BEQ      |L23.366|
000154  4480              ADD      r8,r8,r0              ;4158
                  |L23.342|
000156  9800              LDR      r0,[sp,#0]            ;4162
000158  1b41              SUBS     r1,r0,r5              ;4162
00015a  eba10108          SUB      r1,r1,r8              ;4162
00015e  eba1010a          SUB      r1,r1,r10             ;4162
000162  fbb1f1f7          UDIV     r1,r1,r7              ;4162
000166  9103              STR      r1,[sp,#0xc]          ;4162
000168  2e02              CMP      r6,#2                 ;4163
00016a  d003              BEQ      |L23.372|
00016c  e007              B        |L23.382|
                  |L23.366|
00016e  4405              ADD      r5,r5,r0              ;4155
000170  4483              ADD      r11,r11,r0            ;4156
000172  e7f0              B        |L23.342|
                  |L23.372|
000174  9903              LDR      r1,[sp,#0xc]          ;4163
000176  f64072f6          MOV      r2,#0xff6             ;4163
00017a  4291              CMP      r1,r2                 ;4163
00017c  d306              BCC      |L23.396|
                  |L23.382|
00017e  2e03              CMP      r6,#3                 ;4164
000180  d106              BNE      |L23.400|
000182  9903              LDR      r1,[sp,#0xc]          ;4164
000184  f64f72f6          MOV      r2,#0xfff6            ;4164
000188  4291              CMP      r1,r2                 ;4164
00018a  d201              BCS      |L23.400|
                  |L23.396|
00018c  200e              MOVS     r0,#0xe               ;4165
00018e  e73f              B        |L23.16|
                  |L23.400|
000190  2e03              CMP      r6,#3                 ;4168
000192  d002              BEQ      |L23.410|
000194  2e01              CMP      r6,#1                 ;4171
000196  d003              BEQ      |L23.416|
000198  e008              B        |L23.428|
                  |L23.410|
00019a  200c              MOVS     r0,#0xc               ;4169
00019c  9005              STR      r0,[sp,#0x14]         ;4169
00019e  e00c              B        |L23.442|
                  |L23.416|
0001a0  f5b03f80          CMP      r0,#0x10000           ;4171
0001a4  d202              BCS      |L23.428|
0001a6  2001              MOVS     r0,#1                 ;4172
0001a8  9005              STR      r0,[sp,#0x14]         ;4172
0001aa  e006              B        |L23.442|
                  |L23.428|
0001ac  f5b03f80          CMP      r0,#0x10000           ;4174
0001b0  d201              BCS      |L23.438|
0001b2  2004              MOVS     r0,#4                 ;4174
0001b4  e000              B        |L23.440|
                  |L23.438|
0001b6  2006              MOVS     r0,#6                 ;4174
                  |L23.440|
0001b8  9005              STR      r0,[sp,#0x14]         ;4174
                  |L23.442|
0001ba  9809              LDR      r0,[sp,#0x24]         ;4186
0001bc  b110              CBZ      r0,|L23.452|
0001be  20f0              MOVS     r0,#0xf0              ;4187
0001c0  9006              STR      r0,[sp,#0x18]         ;4187
0001c2  e03c              B        |L23.574|
                  |L23.452|
0001c4  f1040030          ADD      r0,r4,#0x30           ;4189
0001c8  f44f7200          MOV      r2,#0x200             ;4189
0001cc  2100              MOVS     r1,#0                 ;4189
0001ce  9007              STR      r0,[sp,#0x1c]         ;4189
0001d0  f7fffffe          BL       mem_set
0001d4  f50470f7          ADD      r0,r4,#0x1ee          ;4190
0001d8  2101              MOVS     r1,#1                 ;4191
0001da  7041              STRB     r1,[r0,#1]            ;4191
0001dc  7081              STRB     r1,[r0,#2]            ;4192
0001de  2200              MOVS     r2,#0                 ;4193
0001e0  70c2              STRB     r2,[r0,#3]            ;4193
0001e2  9905              LDR      r1,[sp,#0x14]         ;4194
0001e4  7101              STRB     r1,[r0,#4]            ;4194
0001e6  21fe              MOVS     r1,#0xfe              ;4195
0001e8  7141              STRB     r1,[r0,#5]            ;4195
0001ea  9900              LDR      r1,[sp,#0]            ;4196
0001ec  f64363c1          MOV      r3,#0x3ec1            ;4196
0001f0  4449              ADD      r1,r1,r9              ;4196
0001f2  fbb1f1f3          UDIV     r1,r1,r3              ;4196
0001f6  9102              STR      r1,[sp,#8]            ;4196
0001f8  233f              MOVS     r3,#0x3f              ;4197
0001fa  ea430c91          ORR      r12,r3,r1,LSR #2      ;4197
0001fe  f880c006          STRB     r12,[r0,#6]           ;4197
000202  71c1              STRB     r1,[r0,#7]            ;4198
000204  7203              STRB     r3,[r0,#8]            ;4199
000206  7242              STRB     r2,[r0,#9]            ;4199
000208  7282              STRB     r2,[r0,#0xa]          ;4199
00020a  72c2              STRB     r2,[r0,#0xb]          ;4199
00020c  9900              LDR      r1,[sp,#0]            ;4200
00020e  7301              STRB     r1,[r0,#0xc]          ;4200
000210  0a0a              LSRS     r2,r1,#8              ;4200
000212  7342              STRB     r2,[r0,#0xd]          ;4200
000214  0c0a              LSRS     r2,r1,#16             ;4200
000216  7382              STRB     r2,[r0,#0xe]          ;4200
000218  0e09              LSRS     r1,r1,#24             ;4200
00021a  73c1              STRB     r1,[r0,#0xf]          ;4200
00021c  2055              MOVS     r0,#0x55              ;4201
00021e  f884022e          STRB     r0,[r4,#0x22e]        ;4201
000222  20aa              MOVS     r0,#0xaa              ;4201
000224  f884022f          STRB     r0,[r4,#0x22f]        ;4201
000228  2301              MOVS     r3,#1                 ;4202
00022a  2200              MOVS     r2,#0                 ;4202
00022c  9907              LDR      r1,[sp,#0x1c]         ;4202
00022e  9804              LDR      r0,[sp,#0x10]         ;4202
000230  f7fffffe          BL       disk_write
000234  b108              CBZ      r0,|L23.570|
000236  2001              MOVS     r0,#1                 ;4203
000238  e6ea              B        |L23.16|
                  |L23.570|
00023a  20f8              MOVS     r0,#0xf8              ;4204
00023c  9006              STR      r0,[sp,#0x18]         ;4204
                  |L23.574|
00023e  3430              ADDS     r4,r4,#0x30           ;4209
000240  f44f7200          MOV      r2,#0x200             ;4210
000244  2100              MOVS     r1,#0                 ;4210
000246  4620              MOV      r0,r4                 ;4210
000248  f7fffffe          BL       mem_set
00024c  220b              MOVS     r2,#0xb               ;4211
00024e  a170              ADR      r1,|L23.1040|
000250  4620              MOV      r0,r4                 ;4211
000252  f7fffffe          BL       mem_cpy
000256  2100              MOVS     r1,#0                 ;4213
000258  72e1              STRB     r1,[r4,#0xb]          ;4213
00025a  2002              MOVS     r0,#2                 ;4213
00025c  7320              STRB     r0,[r4,#0xc]          ;4213
00025e  7367              STRB     r7,[r4,#0xd]          ;4214
000260  73a5              STRB     r5,[r4,#0xe]          ;4215
000262  0a28              LSRS     r0,r5,#8              ;4215
000264  73e0              STRB     r0,[r4,#0xf]          ;4215
000266  2001              MOVS     r0,#1                 ;4216
000268  7420              STRB     r0,[r4,#0x10]         ;4216
00026a  2e03              CMP      r6,#3                 ;4217
00026c  d00b              BEQ      |L23.646|
00026e  0240              LSLS     r0,r0,#9              ;4217
                  |L23.624|
000270  7460              STRB     r0,[r4,#0x11]         ;4218
000272  0a00              LSRS     r0,r0,#8              ;4218
000274  74a0              STRB     r0,[r4,#0x12]         ;4218
000276  9800              LDR      r0,[sp,#0]            ;4219
000278  f5b03f80          CMP      r0,#0x10000           ;4219
00027c  d205              BCS      |L23.650|
00027e  74e0              STRB     r0,[r4,#0x13]         ;4220
000280  0a00              LSRS     r0,r0,#8              ;4220
000282  7520              STRB     r0,[r4,#0x14]         ;4220
000284  e00a              B        |L23.668|
                  |L23.646|
000286  2000              MOVS     r0,#0                 ;4217
000288  e7f2              B        |L23.624|
                  |L23.650|
00028a  f8040f20          STRB     r0,[r4,#0x20]!        ;4222
00028e  0a02              LSRS     r2,r0,#8              ;4222
000290  7062              STRB     r2,[r4,#1]            ;4222
000292  0c02              LSRS     r2,r0,#16             ;4222
000294  70a2              STRB     r2,[r4,#2]            ;4222
000296  0e00              LSRS     r0,r0,#24             ;4222
000298  70e0              STRB     r0,[r4,#3]            ;4222
00029a  3c20              SUBS     r4,r4,#0x20           ;4222
                  |L23.668|
00029c  9806              LDR      r0,[sp,#0x18]         ;4224
00029e  7560              STRB     r0,[r4,#0x15]         ;4224
0002a0  203f              MOVS     r0,#0x3f              ;4225
0002a2  7620              STRB     r0,[r4,#0x18]         ;4225
0002a4  2000              MOVS     r0,#0                 ;4225
0002a6  7660              STRB     r0,[r4,#0x19]         ;4225
0002a8  21ff              MOVS     r1,#0xff              ;4226
0002aa  76a1              STRB     r1,[r4,#0x1a]         ;4226
0002ac  76e0              STRB     r0,[r4,#0x1b]         ;4226
0002ae  f884901c          STRB     r9,[r4,#0x1c]         ;4227
0002b2  ea4f2019          LSR      r0,r9,#8              ;4227
0002b6  7760              STRB     r0,[r4,#0x1d]         ;4227
0002b8  ea4f4019          LSR      r0,r9,#16             ;4227
0002bc  77a0              STRB     r0,[r4,#0x1e]         ;4227
0002be  ea4f6019          LSR      r0,r9,#24             ;4227
0002c2  77e0              STRB     r0,[r4,#0x1f]         ;4227
0002c4  f7fffffe          BL       get_fattime
0002c8  9002              STR      r0,[sp,#8]            ;4228
0002ca  2180              MOVS     r1,#0x80              ;4126
0002cc  2229              MOVS     r2,#0x29              ;4236
0002ce  2e03              CMP      r6,#3                 ;4229
0002d0  d024              BEQ      |L23.796|
0002d2  3416              ADDS     r4,r4,#0x16           ;4239
0002d4  7460              STRB     r0,[r4,#0x11]         ;4239
0002d6  0a03              LSRS     r3,r0,#8              ;4239
0002d8  74a3              STRB     r3,[r4,#0x12]         ;4239
0002da  0c03              LSRS     r3,r0,#16             ;4239
0002dc  74e3              STRB     r3,[r4,#0x13]         ;4239
0002de  0e00              LSRS     r0,r0,#24             ;4239
0002e0  7520              STRB     r0,[r4,#0x14]         ;4239
0002e2  f8848000          STRB     r8,[r4,#0]            ;4240
0002e6  ea4f2018          LSR      r0,r8,#8              ;4240
0002ea  7060              STRB     r0,[r4,#1]            ;4240
0002ec  73a1              STRB     r1,[r4,#0xe]          ;4241
0002ee  7422              STRB     r2,[r4,#0x10]         ;4242
0002f0  3c16              SUBS     r4,r4,#0x16           ;4242
0002f2  2213              MOVS     r2,#0x13              ;4243
0002f4  a149              ADR      r1,|L23.1052|
0002f6  f104002b          ADD      r0,r4,#0x2b           ;4243
0002fa  f7fffffe          BL       mem_cpy
                  |L23.766|
0002fe  2055              MOVS     r0,#0x55              ;4245
000300  f88401fe          STRB     r0,[r4,#0x1fe]        ;4245
000304  20aa              MOVS     r0,#0xaa              ;4245
000306  f88401ff          STRB     r0,[r4,#0x1ff]        ;4245
00030a  2301              MOVS     r3,#1                 ;4246
00030c  464a              MOV      r2,r9                 ;4246
00030e  4621              MOV      r1,r4                 ;4246
000310  9804              LDR      r0,[sp,#0x10]         ;4246
000312  f7fffffe          BL       disk_write
000316  b360              CBZ      r0,|L23.882|
000318  2001              MOVS     r0,#1                 ;4247
00031a  e679              B        |L23.16|
                  |L23.796|
00031c  3425              ADDS     r4,r4,#0x25           ;4230
00031e  77a0              STRB     r0,[r4,#0x1e]         ;4230
000320  0a03              LSRS     r3,r0,#8              ;4230
000322  77e3              STRB     r3,[r4,#0x1f]         ;4230
000324  0c03              LSRS     r3,r0,#16             ;4230
000326  f8843020          STRB     r3,[r4,#0x20]         ;4230
00032a  0e00              LSRS     r0,r0,#24             ;4230
00032c  f8840021          STRB     r0,[r4,#0x21]         ;4230
000330  f8048c01          STRB     r8,[r4,#-1]           ;4231
000334  ea4f2018          LSR      r0,r8,#8              ;4231
000338  7020              STRB     r0,[r4,#0]            ;4231
00033a  ea4f4018          LSR      r0,r8,#16             ;4231
00033e  7060              STRB     r0,[r4,#1]            ;4231
000340  ea4f6018          LSR      r0,r8,#24             ;4231
000344  70a0              STRB     r0,[r4,#2]            ;4231
000346  2002              MOVS     r0,#2                 ;4232
000348  71e0              STRB     r0,[r4,#7]            ;4232
00034a  2000              MOVS     r0,#0                 ;4232
00034c  7220              STRB     r0,[r4,#8]            ;4232
00034e  7260              STRB     r0,[r4,#9]            ;4232
000350  72a0              STRB     r0,[r4,#0xa]          ;4232
000352  2301              MOVS     r3,#1                 ;4233
000354  72e3              STRB     r3,[r4,#0xb]          ;4233
000356  7320              STRB     r0,[r4,#0xc]          ;4233
000358  2306              MOVS     r3,#6                 ;4234
00035a  7363              STRB     r3,[r4,#0xd]          ;4234
00035c  73a0              STRB     r0,[r4,#0xe]          ;4234
00035e  76e1              STRB     r1,[r4,#0x1b]         ;4235
000360  7762              STRB     r2,[r4,#0x1d]         ;4236
000362  3c25              SUBS     r4,r4,#0x25           ;4236
000364  2213              MOVS     r2,#0x13              ;4237
000366  a132              ADR      r1,|L23.1072|
000368  f1040047          ADD      r0,r4,#0x47           ;4237
00036c  f7fffffe          BL       mem_cpy
000370  e7c5              B        |L23.766|
                  |L23.882|
000372  2e03              CMP      r6,#3                 ;4248
000374  d106              BNE      |L23.900|
000376  2301              MOVS     r3,#1                 ;4249
000378  f1090206          ADD      r2,r9,#6              ;4249
00037c  4621              MOV      r1,r4                 ;4249
00037e  9804              LDR      r0,[sp,#0x10]         ;4249
000380  f7fffffe          BL       disk_write
                  |L23.900|
000384  465d              MOV      r5,r11                ;4252
000386  f04f0b00          MOV      r11,#0                ;4253
                  |L23.906|
00038a  f44f7200          MOV      r2,#0x200             ;4254
00038e  2100              MOVS     r1,#0                 ;4254
000390  4620              MOV      r0,r4                 ;4254
000392  f7fffffe          BL       mem_set
000396  9806              LDR      r0,[sp,#0x18]         ;4255
000398  9002              STR      r0,[sp,#8]            ;4255
00039a  2e03              CMP      r6,#3                 ;4256
00039c  d012              BEQ      |L23.964|
00039e  2e01              CMP      r6,#1                 ;4257
0003a0  d00e              BEQ      |L23.960|
0003a2  f06f01ff          MVN      r1,#0xff              ;4257
                  |L23.934|
0003a6  4301              ORRS     r1,r1,r0              ;4257
0003a8  9102              STR      r1,[sp,#8]            ;4257
0003aa  7021              STRB     r1,[r4,#0]            ;4258
0003ac  9802              LDR      r0,[sp,#8]            ;4258
0003ae  0a00              LSRS     r0,r0,#8              ;4258
0003b0  7060              STRB     r0,[r4,#1]            ;4258
0003b2  9802              LDR      r0,[sp,#8]            ;4258
0003b4  0c00              LSRS     r0,r0,#16             ;4258
0003b6  70a0              STRB     r0,[r4,#2]            ;4258
0003b8  9802              LDR      r0,[sp,#8]            ;4258
0003ba  0e00              LSRS     r0,r0,#24             ;4258
0003bc  70e0              STRB     r0,[r4,#3]            ;4258
0003be  e018              B        |L23.1010|
                  |L23.960|
0003c0  4920              LDR      r1,|L23.1092|
0003c2  e7f0              B        |L23.934|
                  |L23.964|
0003c4  f06000ff          ORN      r0,r0,#0xff           ;4260
0003c8  9002              STR      r0,[sp,#8]            ;4260
0003ca  7020              STRB     r0,[r4,#0]            ;4261
0003cc  9802              LDR      r0,[sp,#8]            ;4261
0003ce  0a00              LSRS     r0,r0,#8              ;4261
0003d0  7060              STRB     r0,[r4,#1]            ;4261
0003d2  9802              LDR      r0,[sp,#8]            ;4261
0003d4  0c00              LSRS     r0,r0,#16             ;4261
0003d6  70a0              STRB     r0,[r4,#2]            ;4261
0003d8  9802              LDR      r0,[sp,#8]            ;4261
0003da  0e00              LSRS     r0,r0,#24             ;4261
0003dc  70e0              STRB     r0,[r4,#3]            ;4261
0003de  20ff              MOVS     r0,#0xff              ;4262
0003e0  7120              STRB     r0,[r4,#4]            ;4262
0003e2  7160              STRB     r0,[r4,#5]            ;4262
0003e4  71a0              STRB     r0,[r4,#6]            ;4262
0003e6  71e0              STRB     r0,[r4,#7]            ;4262
0003e8  7220              STRB     r0,[r4,#8]            ;4263
0003ea  7260              STRB     r0,[r4,#9]            ;4263
0003ec  72a0              STRB     r0,[r4,#0xa]          ;4263
0003ee  200f              MOVS     r0,#0xf               ;4263
0003f0  72e0              STRB     r0,[r4,#0xb]          ;4263
                  |L23.1010|
0003f2  462a              MOV      r2,r5                 ;4265
0003f4  1c6d              ADDS     r5,r5,#1              ;4265
0003f6  2301              MOVS     r3,#1                 ;4265
0003f8  4621              MOV      r1,r4                 ;4265
0003fa  9804              LDR      r0,[sp,#0x10]         ;4265
0003fc  f7fffffe          BL       disk_write
000400  b108              CBZ      r0,|L23.1030|
000402  2001              MOVS     r0,#1                 ;4266
000404  e604              B        |L23.16|
                  |L23.1030|
000406  e01f              B        |L23.1096|
                  |L23.1032|
                          DCD      ||.bss||
                  |L23.1036|
                          DCD      ||.constdata||
                  |L23.1040|
000410  ebfe904d          DCB      235,254,144,"MSDOS5.0",0
000414  53444f53
000418  352e3000
                  |L23.1052|
00041c  4e4f204e          DCB      "NO NAME    FAT     ",0
000420  414d4520
000424  20202046
000428  41542020
00042c  20202000
                  |L23.1072|
000430  4e4f204e          DCB      "NO NAME    FAT32   ",0
000434  414d4520
000438  20202046
00043c  41543332
000440  20202000
                  |L23.1092|
                          DCD      0x00ffff00
                  |L23.1096|
000448  f44f7200          MOV      r2,#0x200             ;4267
00044c  2100              MOVS     r1,#0                 ;4267
00044e  4620              MOV      r0,r4                 ;4267
000450  f7fffffe          BL       mem_set
000454  2001              MOVS     r0,#1                 ;4268
000456  9002              STR      r0,[sp,#8]            ;4268
000458  e00c              B        |L23.1140|
                  |L23.1114|
00045a  462a              MOV      r2,r5                 ;4269
00045c  1c6d              ADDS     r5,r5,#1              ;4269
00045e  2301              MOVS     r3,#1                 ;4269
000460  4621              MOV      r1,r4                 ;4269
000462  9804              LDR      r0,[sp,#0x10]         ;4269
000464  f7fffffe          BL       disk_write
000468  b108              CBZ      r0,|L23.1134|
00046a  2001              MOVS     r0,#1                 ;4270
00046c  e5d0              B        |L23.16|
                  |L23.1134|
00046e  9802              LDR      r0,[sp,#8]            ;4268
000470  1c40              ADDS     r0,r0,#1              ;4268
000472  9002              STR      r0,[sp,#8]            ;4268
                  |L23.1140|
000474  9802              LDR      r0,[sp,#8]            ;4268
000476  4540              CMP      r0,r8                 ;4268
000478  d3ef              BCC      |L23.1114|
00047a  f10b0b01          ADD      r11,r11,#1            ;4253
00047e  f1bb0f00          CMP      r11,#0                ;4253
000482  d082              BEQ      |L23.906|
000484  2e03              CMP      r6,#3                 ;4275
000486  d000              BEQ      |L23.1162|
000488  4657              MOV      r7,r10                ;4275
                  |L23.1162|
00048a  462a              MOV      r2,r5                 ;4277
00048c  1c6d              ADDS     r5,r5,#1              ;4277
00048e  2301              MOVS     r3,#1                 ;4277
000490  4621              MOV      r1,r4                 ;4277
000492  9804              LDR      r0,[sp,#0x10]         ;4277
000494  f7fffffe          BL       disk_write
000498  b108              CBZ      r0,|L23.1182|
00049a  2001              MOVS     r0,#1                 ;4278
00049c  e5b8              B        |L23.16|
                  |L23.1182|
00049e  1e7f              SUBS     r7,r7,#1              ;4279
0004a0  d1f3              BNE      |L23.1162|
0004a2  2e03              CMP      r6,#3                 ;4289
0004a4  d13a              BNE      |L23.1308|
0004a6  2052              MOVS     r0,#0x52              ;4290
0004a8  7020              STRB     r0,[r4,#0]            ;4290
0004aa  7060              STRB     r0,[r4,#1]            ;4290
0004ac  2061              MOVS     r0,#0x61              ;4290
0004ae  70a0              STRB     r0,[r4,#2]            ;4290
0004b0  2141              MOVS     r1,#0x41              ;4290
0004b2  70e1              STRB     r1,[r4,#3]            ;4290
0004b4  2272              MOVS     r2,#0x72              ;4291
0004b6  f88421e4          STRB     r2,[r4,#0x1e4]        ;4291
0004ba  f88421e5          STRB     r2,[r4,#0x1e5]        ;4291
0004be  f88411e6          STRB     r1,[r4,#0x1e6]        ;4291
0004c2  f88401e7          STRB     r0,[r4,#0x1e7]        ;4291
0004c6  9803              LDR      r0,[sp,#0xc]          ;4292
0004c8  1e40              SUBS     r0,r0,#1              ;4292
0004ca  f88401e8          STRB     r0,[r4,#0x1e8]        ;4292
0004ce  0a01              LSRS     r1,r0,#8              ;4292
0004d0  f88411e9          STRB     r1,[r4,#0x1e9]        ;4292
0004d4  0c01              LSRS     r1,r0,#16             ;4292
0004d6  f88411ea          STRB     r1,[r4,#0x1ea]        ;4292
0004da  0e00              LSRS     r0,r0,#24             ;4292
0004dc  f88401eb          STRB     r0,[r4,#0x1eb]        ;4292
0004e0  2002              MOVS     r0,#2                 ;4293
0004e2  f88401ec          STRB     r0,[r4,#0x1ec]        ;4293
0004e6  2000              MOVS     r0,#0                 ;4293
0004e8  f88401ed          STRB     r0,[r4,#0x1ed]        ;4293
0004ec  f88401ee          STRB     r0,[r4,#0x1ee]        ;4293
0004f0  f88401ef          STRB     r0,[r4,#0x1ef]        ;4293
0004f4  2055              MOVS     r0,#0x55              ;4294
0004f6  f88401fe          STRB     r0,[r4,#0x1fe]        ;4294
0004fa  20aa              MOVS     r0,#0xaa              ;4294
0004fc  f88401ff          STRB     r0,[r4,#0x1ff]        ;4294
000500  2301              MOVS     r3,#1                 ;4295
000502  f1090201          ADD      r2,r9,#1              ;4295
000506  4621              MOV      r1,r4                 ;4295
000508  9804              LDR      r0,[sp,#0x10]         ;4295
00050a  f7fffffe          BL       disk_write
00050e  2301              MOVS     r3,#1                 ;4296
000510  f1090207          ADD      r2,r9,#7              ;4296
000514  4621              MOV      r1,r4                 ;4296
000516  9804              LDR      r0,[sp,#0x10]         ;4296
000518  f7fffffe          BL       disk_write
                  |L23.1308|
00051c  2200              MOVS     r2,#0                 ;4299
00051e  4611              MOV      r1,r2                 ;4299
000520  9804              LDR      r0,[sp,#0x10]         ;4299
000522  f7fffffe          BL       disk_ioctl
000526  b108              CBZ      r0,|L23.1324|
000528  2001              MOVS     r0,#1                 ;4299
00052a  e571              B        |L23.16|
                  |L23.1324|
00052c  2000              MOVS     r0,#0                 ;4299
00052e  e56f              B        |L23.16|
;;;4301   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;2401   
;;;2402   FRESULT f_mount (
000000  e92d41f7          PUSH     {r0-r2,r4-r8,lr}
;;;2403   	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
;;;2404   	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
;;;2405   	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
;;;2406   )
;;;2407   {
000004  b081              SUB      sp,sp,#4
000006  4616              MOV      r6,r2
;;;2408   	FATFS *cfs;
;;;2409   	int vol;
;;;2410   	FRESULT res;
;;;2411   	const TCHAR *rp = path;
000008  9802              LDR      r0,[sp,#8]
00000a  9000              STR      r0,[sp,#0]
;;;2412   
;;;2413   
;;;2414   	vol = get_ldnumber(&rp);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       get_ldnumber
000012  4604              MOV      r4,r0
;;;2415   	if (vol < 0) return FR_INVALID_DRIVE;
000014  2c00              CMP      r4,#0
000016  da03              BGE      |L24.32|
000018  200b              MOVS     r0,#0xb
                  |L24.26|
;;;2416   	cfs = FatFs[vol];					/* Pointer to fs object */
;;;2417   
;;;2418   	if (cfs) {
;;;2419   #if _FS_LOCK
;;;2420   		clear_lock(cfs);
;;;2421   #endif
;;;2422   #if _FS_REENTRANT						/* Discard sync object of the current volume */
;;;2423   		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
;;;2424   #endif
;;;2425   		cfs->fs_type = 0;				/* Clear old fs object */
;;;2426   	}
;;;2427   
;;;2428   	if (fs) {
;;;2429   		fs->fs_type = 0;				/* Clear new fs object */
;;;2430   #if _FS_REENTRANT						/* Create sync object for the new volume */
;;;2431   		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
;;;2432   #endif
;;;2433   	}
;;;2434   	FatFs[vol] = fs;					/* Register new fs object */
;;;2435   
;;;2436   	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
;;;2437   
;;;2438   	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
;;;2439   	LEAVE_FF(fs, res);
;;;2440   }
00001a  b004              ADD      sp,sp,#0x10
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L24.32|
000020  4f0e              LDR      r7,|L24.92|
000022  f8575024          LDR      r5,[r7,r4,LSL #2]     ;2416
000026  f04f0800          MOV      r8,#0                 ;2418
00002a  b125              CBZ      r5,|L24.54|
00002c  4628              MOV      r0,r5                 ;2420
00002e  f7fffffe          BL       clear_lock
000032  f8858000          STRB     r8,[r5,#0]            ;2425
                  |L24.54|
000036  9801              LDR      r0,[sp,#4]            ;2428
000038  2800              CMP      r0,#0                 ;2428
00003a  d001              BEQ      |L24.64|
00003c  f8808000          STRB     r8,[r0,#0]            ;2429
                  |L24.64|
000040  f8470024          STR      r0,[r7,r4,LSL #2]     ;2434
000044  d001              BEQ      |L24.74|
000046  2e01              CMP      r6,#1                 ;2436
000048  d001              BEQ      |L24.78|
                  |L24.74|
00004a  2000              MOVS     r0,#0                 ;2436
00004c  e7e5              B        |L24.26|
                  |L24.78|
00004e  2200              MOVS     r2,#0                 ;2438
000050  a902              ADD      r1,sp,#8              ;2438
000052  a801              ADD      r0,sp,#4              ;2438
000054  f7fffffe          BL       find_volume
000058  e7df              B        |L24.26|
;;;2441   
                          ENDP

00005a  0000              DCW      0x0000
                  |L24.92|
                          DCD      ||.bss||

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;2448   
;;;2449   FRESULT f_open (
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;2450   	FIL* fp,			/* Pointer to the blank file object */
;;;2451   	const TCHAR* path,	/* Pointer to the file name */
;;;2452   	BYTE mode			/* Access mode and file open mode flags */
;;;2453   )
;;;2454   {
000004  b08b              SUB      sp,sp,#0x2c
000006  4607              MOV      r7,r0
;;;2455   	FRESULT res;
;;;2456   	DIR dj;
;;;2457   	BYTE *dir;
;;;2458   	DEFINE_NAMEBUF;
;;;2459   #if !_FS_READONLY
;;;2460   	DWORD dw, cl;
;;;2461   #endif
;;;2462   
;;;2463   
;;;2464   	if (!fp) return FR_INVALID_OBJECT;
000008  2f00              CMP      r7,#0
00000a  d00f              BEQ      |L25.44|
;;;2465   	fp->fs = 0;			/* Clear file object */
00000c  f04f0800          MOV      r8,#0
000010  f8c78000          STR      r8,[r7,#0]
;;;2466   
;;;2467   	/* Get logical drive number */
;;;2468   #if !_FS_READONLY
;;;2469   	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
000014  f002061f          AND      r6,r2,#0x1f
;;;2470   	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
000018  f0260201          BIC      r2,r6,#1
00001c  a90c              ADD      r1,sp,#0x30
00001e  a803              ADD      r0,sp,#0xc
000020  f7fffffe          BL       find_volume
000024  4605              MOV      r5,r0
;;;2471   #else
;;;2472   	mode &= FA_READ;
;;;2473   	res = find_volume(&dj.fs, &path, 0);
;;;2474   #endif
;;;2475   	if (res == FR_OK) {
000026  0028              MOVS     r0,r5
000028  d004              BEQ      |L25.52|
00002a  e0ad              B        |L25.392|
                  |L25.44|
00002c  2009              MOVS     r0,#9                 ;2464
                  |L25.46|
;;;2476   		INIT_BUF(dj);
;;;2477   		res = follow_path(&dj, path);	/* Follow the file path */
;;;2478   		dir = dj.dir;
;;;2479   #if !_FS_READONLY	/* R/W configuration */
;;;2480   		if (res == FR_OK) {
;;;2481   			if (!dir)	/* Default directory itself */
;;;2482   				res = FR_INVALID_NAME;
;;;2483   #if _FS_LOCK
;;;2484   			else
;;;2485   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2486   #endif
;;;2487   		}
;;;2488   		/* Create or Open a file */
;;;2489   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;;;2490   			if (res != FR_OK) {					/* No file, create new */
;;;2491   				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
;;;2492   #if _FS_LOCK
;;;2493   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;2494   #else
;;;2495   					res = dir_register(&dj);
;;;2496   #endif
;;;2497   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;2498   				dir = dj.dir;					/* New entry */
;;;2499   			}
;;;2500   			else {								/* Any object is already existing */
;;;2501   				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;2502   					res = FR_DENIED;
;;;2503   				} else {
;;;2504   					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
;;;2505   						res = FR_EXIST;
;;;2506   				}
;;;2507   			}
;;;2508   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;;;2509   				dw = GET_FATTIME();
;;;2510   				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
;;;2511   				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
;;;2512   				dir[DIR_Attr] = 0;				/* Reset attribute */
;;;2513   				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
;;;2514   				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
;;;2515   				st_clust(dir, 0);				/* Reset cluster */
;;;2516   				dj.fs->wflag = 1;
;;;2517   				if (cl) {						/* Remove the cluster chain if exist */
;;;2518   					dw = dj.fs->winsect;
;;;2519   					res = remove_chain(dj.fs, cl);
;;;2520   					if (res == FR_OK) {
;;;2521   						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
;;;2522   						res = move_window(dj.fs, dw);
;;;2523   					}
;;;2524   				}
;;;2525   			}
;;;2526   		}
;;;2527   		else {	/* Open an existing file */
;;;2528   			if (res == FR_OK) {					/* Following succeeded */
;;;2529   				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
;;;2530   					res = FR_NO_FILE;
;;;2531   				} else {
;;;2532   					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;2533   						res = FR_DENIED;
;;;2534   				}
;;;2535   			}
;;;2536   		}
;;;2537   		if (res == FR_OK) {
;;;2538   			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
;;;2539   				mode |= FA__WRITTEN;
;;;2540   			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
;;;2541   			fp->dir_ptr = dir;
;;;2542   #if _FS_LOCK
;;;2543   			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2544   			if (!fp->lockid) res = FR_INT_ERR;
;;;2545   #endif
;;;2546   		}
;;;2547   
;;;2548   #else				/* R/O configuration */
;;;2549   		if (res == FR_OK) {					/* Follow succeeded */
;;;2550   			dir = dj.dir;
;;;2551   			if (!dir) {						/* Current directory itself */
;;;2552   				res = FR_INVALID_NAME;
;;;2553   			} else {
;;;2554   				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;;;2555   					res = FR_NO_FILE;
;;;2556   			}
;;;2557   		}
;;;2558   #endif
;;;2559   		FREE_BUF();
;;;2560   
;;;2561   		if (res == FR_OK) {
;;;2562   			fp->flag = mode;					/* File access mode */
;;;2563   			fp->err = 0;						/* Clear error flag */
;;;2564   			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
;;;2565   			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
;;;2566   			fp->fptr = 0;						/* File pointer */
;;;2567   			fp->dsect = 0;
;;;2568   #if _USE_FASTSEEK
;;;2569   			fp->cltbl = 0;						/* Normal seek mode */
;;;2570   #endif
;;;2571   			fp->fs = dj.fs;	 					/* Validate file object */
;;;2572   			fp->id = fp->fs->id;
;;;2573   		}
;;;2574   	}
;;;2575   
;;;2576   	LEAVE_FF(dj.fs, res);
;;;2577   }
00002e  b00e              ADD      sp,sp,#0x38
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L25.52|
000034  f8cdd024          STR      sp,[sp,#0x24]         ;2476
000038  a803              ADD      r0,sp,#0xc            ;2477
00003a  990c              LDR      r1,[sp,#0x30]         ;2477
00003c  f7fffffe          BL       follow_path
000040  4605              MOV      r5,r0                 ;2477
000042  9c08              LDR      r4,[sp,#0x20]         ;2478
000044  b95d              CBNZ     r5,|L25.94|
000046  b11c              CBZ      r4,|L25.80|
000048  0870              LSRS     r0,r6,#1              ;2485
00004a  d003              BEQ      |L25.84|
00004c  2101              MOVS     r1,#1                 ;2485
00004e  e002              B        |L25.86|
                  |L25.80|
000050  2506              MOVS     r5,#6                 ;2482
000052  e004              B        |L25.94|
                  |L25.84|
000054  2100              MOVS     r1,#0                 ;2485
                  |L25.86|
000056  a803              ADD      r0,sp,#0xc            ;2485
000058  f7fffffe          BL       chk_lock
00005c  4605              MOV      r5,r0                 ;2485
                  |L25.94|
00005e  f0160f1c          TST      r6,#0x1c              ;2489
000062  d056              BEQ      |L25.274|
000064  b175              CBZ      r5,|L25.132|
000066  2d04              CMP      r5,#4                 ;2491
000068  d108              BNE      |L25.124|
00006a  f7fffffe          BL       enq_lock
00006e  b120              CBZ      r0,|L25.122|
000070  a803              ADD      r0,sp,#0xc            ;2493
000072  f7fffffe          BL       dir_register
000076  4605              MOV      r5,r0                 ;2493
000078  e000              B        |L25.124|
                  |L25.122|
00007a  2512              MOVS     r5,#0x12              ;2493
                  |L25.124|
00007c  f0460608          ORR      r6,r6,#8              ;2497
000080  9c08              LDR      r4,[sp,#0x20]         ;2498
000082  e008              B        |L25.150|
                  |L25.132|
000084  7ae0              LDRB     r0,[r4,#0xb]          ;2501
000086  f0100f11          TST      r0,#0x11              ;2501
00008a  d001              BEQ      |L25.144|
00008c  2507              MOVS     r5,#7                 ;2502
00008e  e002              B        |L25.150|
                  |L25.144|
000090  0770              LSLS     r0,r6,#29             ;2504
000092  d500              BPL      |L25.150|
000094  2508              MOVS     r5,#8                 ;2505
                  |L25.150|
000096  bbdd              CBNZ     r5,|L25.272|
000098  0730              LSLS     r0,r6,#28             ;2508
00009a  d545              BPL      |L25.296|
00009c  f7fffffe          BL       get_fattime
0000a0  73a0              STRB     r0,[r4,#0xe]          ;2510
0000a2  0a01              LSRS     r1,r0,#8              ;2510
0000a4  73e1              STRB     r1,[r4,#0xf]          ;2510
0000a6  0c02              LSRS     r2,r0,#16             ;2510
0000a8  7422              STRB     r2,[r4,#0x10]         ;2510
0000aa  0e03              LSRS     r3,r0,#24             ;2510
0000ac  7463              STRB     r3,[r4,#0x11]         ;2510
0000ae  75a0              STRB     r0,[r4,#0x16]         ;2511
0000b0  75e1              STRB     r1,[r4,#0x17]         ;2511
0000b2  7622              STRB     r2,[r4,#0x18]         ;2511
0000b4  7663              STRB     r3,[r4,#0x19]         ;2511
0000b6  f884800b          STRB     r8,[r4,#0xb]          ;2512
0000ba  f884801c          STRB     r8,[r4,#0x1c]         ;2513
0000be  f884801d          STRB     r8,[r4,#0x1d]         ;2513
0000c2  f884801e          STRB     r8,[r4,#0x1e]         ;2513
0000c6  f884801f          STRB     r8,[r4,#0x1f]         ;2513
0000ca  4621              MOV      r1,r4                 ;2514
0000cc  9803              LDR      r0,[sp,#0xc]          ;2514
0000ce  f7fffffe          BL       ld_clust
0000d2  4681              MOV      r9,r0                 ;2514
0000d4  2100              MOVS     r1,#0                 ;2515
0000d6  4620              MOV      r0,r4                 ;2515
0000d8  f7fffffe          BL       st_clust
0000dc  9903              LDR      r1,[sp,#0xc]          ;2516
0000de  2001              MOVS     r0,#1                 ;2516
0000e0  7108              STRB     r0,[r1,#4]            ;2516
0000e2  f1b90f00          CMP      r9,#0                 ;2517
0000e6  d01f              BEQ      |L25.296|
0000e8  9803              LDR      r0,[sp,#0xc]          ;2518
0000ea  f8d0a02c          LDR      r10,[r0,#0x2c]        ;2518
0000ee  4649              MOV      r1,r9                 ;2519
0000f0  9803              LDR      r0,[sp,#0xc]          ;2519
0000f2  f7fffffe          BL       remove_chain
0000f6  4605              MOV      r5,r0                 ;2519
0000f8  0028              MOVS     r0,r5                 ;2520
0000fa  d115              BNE      |L25.296|
0000fc  9803              LDR      r0,[sp,#0xc]          ;2521
0000fe  f1a90901          SUB      r9,r9,#1              ;2521
000102  f8c0900c          STR      r9,[r0,#0xc]          ;2521
000106  4651              MOV      r1,r10                ;2522
000108  9803              LDR      r0,[sp,#0xc]          ;2522
00010a  f7fffffe          BL       move_window
00010e  4605              MOV      r5,r0                 ;2522
                  |L25.272|
000110  e00a              B        |L25.296|
                  |L25.274|
000112  b94d              CBNZ     r5,|L25.296|
000114  7ae0              LDRB     r0,[r4,#0xb]          ;2529
000116  06c1              LSLS     r1,r0,#27             ;2529
000118  d501              BPL      |L25.286|
00011a  2504              MOVS     r5,#4                 ;2530
00011c  e004              B        |L25.296|
                  |L25.286|
00011e  07b1              LSLS     r1,r6,#30             ;2532
000120  d502              BPL      |L25.296|
000122  07c0              LSLS     r0,r0,#31             ;2532
000124  d000              BEQ      |L25.296|
000126  2507              MOVS     r5,#7                 ;2533
                  |L25.296|
000128  b995              CBNZ     r5,|L25.336|
00012a  0730              LSLS     r0,r6,#28             ;2538
00012c  d501              BPL      |L25.306|
00012e  f0460620          ORR      r6,r6,#0x20           ;2539
                  |L25.306|
000132  9803              LDR      r0,[sp,#0xc]          ;2540
000134  6ac0              LDR      r0,[r0,#0x2c]         ;2540
000136  61f8              STR      r0,[r7,#0x1c]         ;2540
000138  623c              STR      r4,[r7,#0x20]         ;2541
00013a  0870              LSRS     r0,r6,#1              ;2543
00013c  d001              BEQ      |L25.322|
00013e  2101              MOVS     r1,#1                 ;2543
000140  e000              B        |L25.324|
                  |L25.322|
000142  2100              MOVS     r1,#0                 ;2543
                  |L25.324|
000144  a803              ADD      r0,sp,#0xc            ;2543
000146  f7fffffe          BL       inc_lock
00014a  6278              STR      r0,[r7,#0x24]         ;2543
00014c  b900              CBNZ     r0,|L25.336|
00014e  2502              MOVS     r5,#2                 ;2544
                  |L25.336|
000150  b9d5              CBNZ     r5,|L25.392|
000152  71be              STRB     r6,[r7,#6]            ;2562
000154  f8878007          STRB     r8,[r7,#7]            ;2563
000158  4621              MOV      r1,r4                 ;2564
00015a  9803              LDR      r0,[sp,#0xc]          ;2564
00015c  f7fffffe          BL       ld_clust
000160  6138              STR      r0,[r7,#0x10]         ;2564
000162  7f20              LDRB     r0,[r4,#0x1c]         ;2565
000164  7fe1              LDRB     r1,[r4,#0x1f]         ;2565
000166  7f62              LDRB     r2,[r4,#0x1d]         ;2565
000168  ea406001          ORR      r0,r0,r1,LSL #24      ;2565
00016c  7fa1              LDRB     r1,[r4,#0x1e]         ;2565
00016e  0409              LSLS     r1,r1,#16             ;2565
000170  ea412102          ORR      r1,r1,r2,LSL #8       ;2565
000174  4308              ORRS     r0,r0,r1              ;2565
000176  60f8              STR      r0,[r7,#0xc]          ;2565
000178  f8c78008          STR      r8,[r7,#8]            ;2566
00017c  f8c78018          STR      r8,[r7,#0x18]         ;2567
000180  9803              LDR      r0,[sp,#0xc]          ;2571
000182  6038              STR      r0,[r7,#0]            ;2571
000184  88c0              LDRH     r0,[r0,#6]            ;2572
000186  80b8              STRH     r0,[r7,#4]            ;2572
                  |L25.392|
000188  4628              MOV      r0,r5                 ;2576
00018a  e750              B        |L25.46|
;;;2578   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;3186   
;;;3187   FRESULT f_opendir (
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;3188   	DIR* dp,			/* Pointer to directory object to create */
;;;3189   	const TCHAR* path	/* Pointer to the directory path */
;;;3190   )
;;;3191   {
000002  b084              SUB      sp,sp,#0x10
000004  4605              MOV      r5,r0
;;;3192   	FRESULT res;
;;;3193   	FATFS* fs;
;;;3194   	DEFINE_NAMEBUF;
;;;3195   
;;;3196   
;;;3197   	if (!dp) return FR_INVALID_OBJECT;
000006  2d00              CMP      r5,#0
000008  d008              BEQ      |L26.28|
;;;3198   
;;;3199   	/* Get logical drive number */
;;;3200   	res = find_volume(&fs, &path, 0);
00000a  2200              MOVS     r2,#0
00000c  a905              ADD      r1,sp,#0x14
00000e  a803              ADD      r0,sp,#0xc
000010  f7fffffe          BL       find_volume
000014  4604              MOV      r4,r0
;;;3201   	if (res == FR_OK) {
000016  2600              MOVS     r6,#0
000018  b11c              CBZ      r4,|L26.34|
00001a  e02f              B        |L26.124|
                  |L26.28|
00001c  2009              MOVS     r0,#9                 ;3197
                  |L26.30|
;;;3202   		dp->fs = fs;
;;;3203   		INIT_BUF(*dp);
;;;3204   		res = follow_path(dp, path);			/* Follow the path to the directory */
;;;3205   		FREE_BUF();
;;;3206   		if (res == FR_OK) {						/* Follow completed */
;;;3207   			if (dp->dir) {						/* It is not the origin directory itself */
;;;3208   				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
;;;3209   					dp->sclust = ld_clust(fs, dp->dir);
;;;3210   				else							/* The object is a file */
;;;3211   					res = FR_NO_PATH;
;;;3212   			}
;;;3213   			if (res == FR_OK) {
;;;3214   				dp->id = fs->id;
;;;3215   				res = dir_sdi(dp, 0);			/* Rewind directory */
;;;3216   #if _FS_LOCK
;;;3217   				if (res == FR_OK) {
;;;3218   					if (dp->sclust) {
;;;3219   						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;;;3220   						if (!dp->lockid)
;;;3221   							res = FR_TOO_MANY_OPEN_FILES;
;;;3222   					} else {
;;;3223   						dp->lockid = 0;	/* Root directory need not to be locked */
;;;3224   					}
;;;3225   				}
;;;3226   #endif
;;;3227   			}
;;;3228   		}
;;;3229   		if (res == FR_NO_FILE) res = FR_NO_PATH;
;;;3230   	}
;;;3231   	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
;;;3232   
;;;3233   	LEAVE_FF(fs, res);
;;;3234   }
00001e  b006              ADD      sp,sp,#0x18
000020  bd70              POP      {r4-r6,pc}
                  |L26.34|
000022  9803              LDR      r0,[sp,#0xc]          ;3202
000024  6028              STR      r0,[r5,#0]            ;3202
000026  f8c5d018          STR      sp,[r5,#0x18]         ;3203
00002a  4628              MOV      r0,r5                 ;3204
00002c  9905              LDR      r1,[sp,#0x14]         ;3204
00002e  f7fffffe          BL       follow_path
000032  4604              MOV      r4,r0                 ;3204
000034  b9fc              CBNZ     r4,|L26.118|
000036  6969              LDR      r1,[r5,#0x14]         ;3207
000038  b141              CBZ      r1,|L26.76|
00003a  7ac8              LDRB     r0,[r1,#0xb]          ;3208
00003c  06c0              LSLS     r0,r0,#27             ;3208
00003e  d504              BPL      |L26.74|
000040  9803              LDR      r0,[sp,#0xc]          ;3209
000042  f7fffffe          BL       ld_clust
000046  60a8              STR      r0,[r5,#8]            ;3209
000048  e000              B        |L26.76|
                  |L26.74|
00004a  2405              MOVS     r4,#5                 ;3211
                  |L26.76|
00004c  b99c              CBNZ     r4,|L26.118|
00004e  9803              LDR      r0,[sp,#0xc]          ;3214
000050  88c0              LDRH     r0,[r0,#6]            ;3214
000052  80a8              STRH     r0,[r5,#4]            ;3214
000054  2100              MOVS     r1,#0                 ;3215
000056  4628              MOV      r0,r5                 ;3215
000058  f7fffffe          BL       dir_sdi
00005c  4604              MOV      r4,r0                 ;3215
00005e  b954              CBNZ     r4,|L26.118|
000060  68a8              LDR      r0,[r5,#8]            ;3218
000062  b138              CBZ      r0,|L26.116|
000064  2100              MOVS     r1,#0                 ;3219
000066  4628              MOV      r0,r5                 ;3219
000068  f7fffffe          BL       inc_lock
00006c  61e8              STR      r0,[r5,#0x1c]         ;3219
00006e  b910              CBNZ     r0,|L26.118|
000070  2412              MOVS     r4,#0x12              ;3221
000072  e000              B        |L26.118|
                  |L26.116|
000074  61ee              STR      r6,[r5,#0x1c]         ;3223
                  |L26.118|
000076  2c04              CMP      r4,#4                 ;3229
000078  d100              BNE      |L26.124|
00007a  2405              MOVS     r4,#5                 ;3229
                  |L26.124|
00007c  b104              CBZ      r4,|L26.128|
00007e  602e              STR      r6,[r5,#0]            ;3231
                  |L26.128|
000080  4620              MOV      r0,r4                 ;3233
000082  e7cc              B        |L26.30|
;;;3235   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;2585   
;;;2586   FRESULT f_read (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2587   	FIL* fp, 		/* Pointer to the file object */
;;;2588   	void* buff,		/* Pointer to data buffer */
;;;2589   	UINT btr,		/* Number of bytes to read */
;;;2590   	UINT* br		/* Pointer to number of bytes read */
;;;2591   )
;;;2592   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;2593   	FRESULT res;
;;;2594   	DWORD clst, sect, remain;
;;;2595   	UINT rcnt, cc;
;;;2596   	BYTE csect, *rbuff = (BYTE*)buff;
;;;2597   
;;;2598   
;;;2599   	*br = 0;	/* Clear read byte counter */
00000c  2000              MOVS     r0,#0
00000e  f8c80000          STR      r0,[r8,#0]
;;;2600   
;;;2601   	res = validate(fp);							/* Check validity */
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       validate
;;;2602   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000018  2800              CMP      r0,#0
00001a  d112              BNE      |L27.66|
;;;2603   	if (fp->err)								/* Check error */
00001c  79e0              LDRB     r0,[r4,#7]
00001e  2800              CMP      r0,#0
000020  d10f              BNE      |L27.66|
;;;2604   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2605   	if (!(fp->flag & FA_READ)) 					/* Check access mode */
000022  79a0              LDRB     r0,[r4,#6]
000024  07c0              LSLS     r0,r0,#31
000026  d00b              BEQ      |L27.64|
;;;2606   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2607   	remain = fp->fsize - fp->fptr;
000028  e9d41002          LDRD     r1,r0,[r4,#8]
00002c  1a40              SUBS     r0,r0,r1
;;;2608   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
00002e  4286              CMP      r6,r0
000030  d900              BLS      |L27.52|
000032  4606              MOV      r6,r0
                  |L27.52|
;;;2609   
;;;2610   	for ( ;  btr;								/* Repeat until all data read */
;;;2611   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;2612   		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;;;2613   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2614   			if (!csect) {						/* On the cluster boundary? */
;;;2615   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;2616   					clst = fp->sclust;			/* Follow from the origin */
;;;2617   				} else {						/* Middle or end of the file */
;;;2618   #if _USE_FASTSEEK
;;;2619   					if (fp->cltbl)
;;;2620   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2621   					else
;;;2622   #endif
;;;2623   						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;;;2624   				}
;;;2625   				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;;;2626   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2627   				fp->clust = clst;				/* Update current cluster */
;;;2628   			}
;;;2629   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2630   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2631   			sect += csect;
;;;2632   			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;;;2633   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;2634   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2635   					cc = fp->fs->csize - csect;
;;;2636   				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
;;;2637   					ABORT(fp->fs, FR_DISK_ERR);
;;;2638   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;2639   #if _FS_TINY
;;;2640   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;;;2641   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;;;2642   #else
;;;2643   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;;;2644   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
000034  f1040028          ADD      r0,r4,#0x28
000038  f04f0901          MOV      r9,#1                 ;2626
00003c  9000              STR      r0,[sp,#0]            ;2610
00003e  e08d              B        |L27.348|
                  |L27.64|
000040  2007              MOVS     r0,#7                 ;2606
                  |L27.66|
;;;2645   #endif
;;;2646   #endif
;;;2647   				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;;;2648   				continue;
;;;2649   			}
;;;2650   #if !_FS_TINY
;;;2651   			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;;;2652   #if !_FS_READONLY
;;;2653   				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2654   					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2655   						ABORT(fp->fs, FR_DISK_ERR);
;;;2656   					fp->flag &= ~FA__DIRTY;
;;;2657   				}
;;;2658   #endif
;;;2659   				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
;;;2660   					ABORT(fp->fs, FR_DISK_ERR);
;;;2661   			}
;;;2662   #endif
;;;2663   			fp->dsect = sect;
;;;2664   		}
;;;2665   		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;2666   		if (rcnt > btr) rcnt = btr;
;;;2667   #if _FS_TINY
;;;2668   		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
;;;2669   			ABORT(fp->fs, FR_DISK_ERR);
;;;2670   		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2671   #else
;;;2672   		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2673   #endif
;;;2674   	}
;;;2675   
;;;2676   	LEAVE_FF(fp->fs, FR_OK);
;;;2677   }
000042  e8bd8ff8          POP      {r3-r11,pc}
                  |L27.70|
000046  68a0              LDR      r0,[r4,#8]            ;2612
000048  05c1              LSLS     r1,r0,#23             ;2612
00004a  d16f              BNE      |L27.300|
00004c  6822              LDR      r2,[r4,#0]            ;2613
00004e  7891              LDRB     r1,[r2,#2]            ;2613
000050  1e49              SUBS     r1,r1,#1              ;2613
000052  ea012150          AND      r1,r1,r0,LSR #9       ;2613
000056  f0010aff          AND      r10,r1,#0xff          ;2613
00005a  f1ba0f00          CMP      r10,#0                ;2614
00005e  d10e              BNE      |L27.126|
000060  b140              CBZ      r0,|L27.116|
000062  4610              MOV      r0,r2                 ;2623
000064  6961              LDR      r1,[r4,#0x14]         ;2623
000066  f7fffffe          BL       get_fat
                  |L27.106|
00006a  2802              CMP      r0,#2                 ;2625
00006c  d204              BCS      |L27.120|
00006e  2002              MOVS     r0,#2                 ;2625
000070  71e0              STRB     r0,[r4,#7]            ;2625
000072  e7e6              B        |L27.66|
                  |L27.116|
000074  6920              LDR      r0,[r4,#0x10]         ;2616
000076  e7f8              B        |L27.106|
                  |L27.120|
000078  1c41              ADDS     r1,r0,#1              ;2626
00007a  d01c              BEQ      |L27.182|
00007c  6160              STR      r0,[r4,#0x14]         ;2627
                  |L27.126|
00007e  6961              LDR      r1,[r4,#0x14]         ;2629
000080  6820              LDR      r0,[r4,#0]            ;2629
000082  f7fffffe          BL       clust2sect
000086  b1d0              CBZ      r0,|L27.190|
000088  eb000b0a          ADD      r11,r0,r10            ;2631
00008c  0a75              LSRS     r5,r6,#9              ;2632
00008e  b355              CBZ      r5,|L27.230|
000090  6821              LDR      r1,[r4,#0]            ;2634
000092  eb0a0205          ADD      r2,r10,r5             ;2634
000096  7888              LDRB     r0,[r1,#2]            ;2634
000098  4282              CMP      r2,r0                 ;2634
00009a  d901              BLS      |L27.160|
00009c  eba0050a          SUB      r5,r0,r10             ;2635
                  |L27.160|
0000a0  7848              LDRB     r0,[r1,#1]            ;2636
0000a2  462b              MOV      r3,r5                 ;2636
0000a4  465a              MOV      r2,r11                ;2636
0000a6  4639              MOV      r1,r7                 ;2636
0000a8  f7fffffe          BL       disk_read
0000ac  b150              CBZ      r0,|L27.196|
0000ae  f8849007          STRB     r9,[r4,#7]            ;2637
0000b2  2001              MOVS     r0,#1                 ;2637
0000b4  e7c5              B        |L27.66|
                  |L27.182|
0000b6  f8849007          STRB     r9,[r4,#7]            ;2626
0000ba  2001              MOVS     r0,#1                 ;2626
0000bc  e7c1              B        |L27.66|
                  |L27.190|
0000be  2002              MOVS     r0,#2                 ;2630
0000c0  71e0              STRB     r0,[r4,#7]            ;2630
0000c2  e7be              B        |L27.66|
                  |L27.196|
0000c4  79a0              LDRB     r0,[r4,#6]            ;2643
0000c6  0640              LSLS     r0,r0,#25             ;2643
0000c8  d50b              BPL      |L27.226|
0000ca  69a0              LDR      r0,[r4,#0x18]         ;2643
0000cc  eba0000b          SUB      r0,r0,r11             ;2643
0000d0  42a8              CMP      r0,r5                 ;2643
0000d2  d206              BCS      |L27.226|
0000d4  eb072040          ADD      r0,r7,r0,LSL #9       ;2644
0000d8  f44f7200          MOV      r2,#0x200             ;2644
0000dc  9900              LDR      r1,[sp,#0]            ;2644
0000de  f7fffffe          BL       mem_cpy
                  |L27.226|
0000e2  026d              LSLS     r5,r5,#9              ;2647
0000e4  e030              B        |L27.328|
                  |L27.230|
0000e6  69a2              LDR      r2,[r4,#0x18]         ;2651
0000e8  455a              CMP      r2,r11                ;2651
0000ea  d01d              BEQ      |L27.296|
0000ec  79a0              LDRB     r0,[r4,#6]            ;2653
0000ee  0640              LSLS     r0,r0,#25             ;2653
0000f0  d50e              BPL      |L27.272|
0000f2  6820              LDR      r0,[r4,#0]            ;2654
0000f4  2301              MOVS     r3,#1                 ;2654
0000f6  9900              LDR      r1,[sp,#0]            ;2654
0000f8  7840              LDRB     r0,[r0,#1]            ;2654
0000fa  f7fffffe          BL       disk_write
0000fe  b118              CBZ      r0,|L27.264|
000100  f8849007          STRB     r9,[r4,#7]            ;2655
000104  2001              MOVS     r0,#1                 ;2655
000106  e79c              B        |L27.66|
                  |L27.264|
000108  79a0              LDRB     r0,[r4,#6]            ;2656
00010a  f0200040          BIC      r0,r0,#0x40           ;2656
00010e  71a0              STRB     r0,[r4,#6]            ;2656
                  |L27.272|
000110  6820              LDR      r0,[r4,#0]            ;2659
000112  2301              MOVS     r3,#1                 ;2659
000114  465a              MOV      r2,r11                ;2659
000116  7840              LDRB     r0,[r0,#1]            ;2659
000118  9900              LDR      r1,[sp,#0]            ;2659
00011a  f7fffffe          BL       disk_read
00011e  b118              CBZ      r0,|L27.296|
000120  f8849007          STRB     r9,[r4,#7]            ;2660
000124  2001              MOVS     r0,#1                 ;2660
000126  e78c              B        |L27.66|
                  |L27.296|
000128  f8c4b018          STR      r11,[r4,#0x18]        ;2663
                  |L27.300|
00012c  8920              LDRH     r0,[r4,#8]            ;2665
00012e  f3c00008          UBFX     r0,r0,#0,#9           ;2665
000132  f5c07500          RSB      r5,r0,#0x200          ;2665
000136  42b5              CMP      r5,r6                 ;2666
000138  d900              BLS      |L27.316|
00013a  4635              MOV      r5,r6                 ;2666
                  |L27.316|
00013c  1901              ADDS     r1,r0,r4              ;2672
00013e  3128              ADDS     r1,r1,#0x28           ;2672
000140  462a              MOV      r2,r5                 ;2672
000142  4638              MOV      r0,r7                 ;2672
000144  f7fffffe          BL       mem_cpy
                  |L27.328|
000148  442f              ADD      r7,r7,r5              ;2611
00014a  68a0              LDR      r0,[r4,#8]            ;2611
00014c  4428              ADD      r0,r0,r5              ;2611
00014e  60a0              STR      r0,[r4,#8]            ;2611
000150  f8d80000          LDR      r0,[r8,#0]            ;2611
000154  4428              ADD      r0,r0,r5              ;2611
000156  f8c80000          STR      r0,[r8,#0]            ;2611
00015a  1b76              SUBS     r6,r6,r5              ;2611
                  |L27.348|
00015c  2e00              CMP      r6,#0                 ;2610
00015e  f47faf72          BNE      |L27.70|
000162  2000              MOVS     r0,#0                 ;2676
000164  e76d              B        |L27.66|
;;;2678   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;3274   
;;;3275   FRESULT f_readdir (
000000  b5fe              PUSH     {r1-r7,lr}
;;;3276   	DIR* dp,			/* Pointer to the open directory object */
;;;3277   	FILINFO* fno		/* Pointer to file information to return */
;;;3278   )
;;;3279   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;3280   	FRESULT res;
;;;3281   	DEFINE_NAMEBUF;
;;;3282   
;;;3283   
;;;3284   	res = validate(dp);						/* Check validity of the object */
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       validate
;;;3285   	if (res == FR_OK) {
00000c  2800              CMP      r0,#0
00000e  d10e              BNE      |L28.46|
;;;3286   		if (!fno) {
000010  b14e              CBZ      r6,|L28.38|
;;;3287   			res = dir_sdi(dp, 0);			/* Rewind the directory object */
;;;3288   		} else {
;;;3289   			INIT_BUF(*dp);
000012  f8c4d018          STR      sp,[r4,#0x18]
;;;3290   			res = dir_read(dp, 0);			/* Read an item */
000016  2100              MOVS     r1,#0
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       dir_read
;;;3291   			if (res == FR_NO_FILE) {		/* Reached end of directory */
00001e  2500              MOVS     r5,#0
000020  2804              CMP      r0,#4
000022  d005              BEQ      |L28.48|
000024  e006              B        |L28.52|
                  |L28.38|
000026  2100              MOVS     r1,#0                 ;3287
000028  4620              MOV      r0,r4                 ;3287
00002a  f7fffffe          BL       dir_sdi
                  |L28.46|
;;;3292   				dp->sect = 0;
;;;3293   				res = FR_OK;
;;;3294   			}
;;;3295   			if (res == FR_OK) {				/* A valid entry is found */
;;;3296   				get_fileinfo(dp, fno);		/* Get the object information */
;;;3297   				res = dir_next(dp, 0);		/* Increment index for next */
;;;3298   				if (res == FR_NO_FILE) {
;;;3299   					dp->sect = 0;
;;;3300   					res = FR_OK;
;;;3301   				}
;;;3302   			}
;;;3303   			FREE_BUF();
;;;3304   		}
;;;3305   	}
;;;3306   
;;;3307   	LEAVE_FF(dp->fs, res);
;;;3308   }
00002e  bdfe              POP      {r1-r7,pc}
                  |L28.48|
000030  6125              STR      r5,[r4,#0x10]         ;3292
000032  2000              MOVS     r0,#0                 ;3293
                  |L28.52|
000034  2800              CMP      r0,#0                 ;3295
000036  d1fa              BNE      |L28.46|
000038  4631              MOV      r1,r6                 ;3296
00003a  4620              MOV      r0,r4                 ;3296
00003c  f7fffffe          BL       get_fileinfo
000040  2100              MOVS     r1,#0                 ;3297
000042  4620              MOV      r0,r4                 ;3297
000044  f7fffffe          BL       dir_next
000048  2804              CMP      r0,#4                 ;3298
00004a  d1f0              BNE      |L28.46|
00004c  6125              STR      r5,[r4,#0x10]         ;3299
00004e  2000              MOVS     r0,#0                 ;3300
000050  bdfe              POP      {r1-r7,pc}
;;;3309   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;3710   
;;;3711   FRESULT f_rename (
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;3712   	const TCHAR* path_old,	/* Pointer to the object to be renamed */
;;;3713   	const TCHAR* path_new	/* Pointer to the new name */
;;;3714   )
;;;3715   {
000002  b09a              SUB      sp,sp,#0x68
;;;3716   	FRESULT res;
;;;3717   	DIR djo, djn;
;;;3718   	BYTE buf[21], *dir;
;;;3719   	DWORD dw;
;;;3720   	DEFINE_NAMEBUF;
;;;3721   
;;;3722   
;;;3723   	/* Get logical drive number of the source object */
;;;3724   	res = find_volume(&djo.fs, &path_old, 1);
000004  2201              MOVS     r2,#1
000006  a91a              ADD      r1,sp,#0x68
000008  a812              ADD      r0,sp,#0x48
00000a  f7fffffe          BL       find_volume
00000e  4604              MOV      r4,r0
;;;3725   	if (res == FR_OK) {
000010  2c00              CMP      r4,#0
000012  d171              BNE      |L29.248|
;;;3726   		djn.fs = djo.fs;
000014  9812              LDR      r0,[sp,#0x48]
000016  900a              STR      r0,[sp,#0x28]
;;;3727   		INIT_BUF(djo);
000018  a801              ADD      r0,sp,#4
00001a  9018              STR      r0,[sp,#0x60]
;;;3728   		res = follow_path(&djo, path_old);		/* Check old object */
00001c  a812              ADD      r0,sp,#0x48
00001e  991a              LDR      r1,[sp,#0x68]
000020  f7fffffe          BL       follow_path
000024  4604              MOV      r4,r0
;;;3729   		if (_FS_RPATH && res == FR_OK && (djo.fn[NSFLAG] & NS_DOT))
;;;3730   			res = FR_INVALID_NAME;
;;;3731   #if _FS_LOCK
;;;3732   		if (res == FR_OK) res = chk_lock(&djo, 2);
000026  b924              CBNZ     r4,|L29.50|
000028  2102              MOVS     r1,#2
00002a  a812              ADD      r0,sp,#0x48
00002c  f7fffffe          BL       chk_lock
000030  4604              MOV      r4,r0
                  |L29.50|
;;;3733   #endif
;;;3734   		if (res == FR_OK) {						/* Old object is found */
000032  2c00              CMP      r4,#0
000034  d160              BNE      |L29.248|
;;;3735   			if (!djo.dir) {						/* Is root dir? */
000036  9817              LDR      r0,[sp,#0x5c]
000038  b1a8              CBZ      r0,|L29.102|
;;;3736   				res = FR_NO_FILE;
;;;3737   			} else {
;;;3738   				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about object except name */
00003a  9917              LDR      r1,[sp,#0x5c]
00003c  2215              MOVS     r2,#0x15
00003e  310b              ADDS     r1,r1,#0xb
000040  a804              ADD      r0,sp,#0x10
000042  f7fffffe          BL       mem_cpy
;;;3739   				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
000046  2220              MOVS     r2,#0x20
000048  a912              ADD      r1,sp,#0x48
00004a  a80a              ADD      r0,sp,#0x28
00004c  f7fffffe          BL       mem_cpy
;;;3740   				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
000050  a81b              ADD      r0,sp,#0x6c
000052  f7fffffe          BL       get_ldnumber
000056  2800              CMP      r0,#0
000058  db07              BLT      |L29.106|
;;;3741   					res = follow_path(&djn, path_new);	/* and make sure if new object name is not conflicting */
00005a  a80a              ADD      r0,sp,#0x28
00005c  991b              LDR      r1,[sp,#0x6c]
00005e  f7fffffe          BL       follow_path
000062  4604              MOV      r4,r0
000064  e002              B        |L29.108|
                  |L29.102|
000066  2404              MOVS     r4,#4                 ;3736
000068  e046              B        |L29.248|
                  |L29.106|
;;;3742   				else
;;;3743   					res = FR_INVALID_DRIVE;
00006a  240b              MOVS     r4,#0xb
                  |L29.108|
;;;3744   				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
00006c  b904              CBNZ     r4,|L29.112|
00006e  2408              MOVS     r4,#8
                  |L29.112|
;;;3745   				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
000070  2c04              CMP      r4,#4
000072  d141              BNE      |L29.248|
;;;3746   					res = dir_register(&djn);			/* Register the new entry */
000074  a80a              ADD      r0,sp,#0x28
000076  f7fffffe          BL       dir_register
00007a  4604              MOV      r4,r0
;;;3747   					if (res == FR_OK) {
00007c  bbe4              CBNZ     r4,|L29.248|
;;;3748   /* Start of critical section where any interruption can cause a cross-link */
;;;3749   						dir = djn.dir;					/* Copy information about object except name */
00007e  9d0f              LDR      r5,[sp,#0x3c]
;;;3750   						mem_cpy(dir + 13, buf + 2, 19);
000080  2213              MOVS     r2,#0x13
000082  f10d0112          ADD      r1,sp,#0x12
000086  f105000d          ADD      r0,r5,#0xd
00008a  f7fffffe          BL       mem_cpy
;;;3751   						dir[DIR_Attr] = buf[0] | AM_ARC;
00008e  f89d0010          LDRB     r0,[sp,#0x10]
000092  f0400020          ORR      r0,r0,#0x20
000096  72e8              STRB     r0,[r5,#0xb]
;;;3752   						djo.fs->wflag = 1;
000098  9812              LDR      r0,[sp,#0x48]
00009a  2601              MOVS     r6,#1
00009c  7106              STRB     r6,[r0,#4]
;;;3753   						if ((dir[DIR_Attr] & AM_DIR) && djo.sclust != djn.sclust) {	/* Update .. entry in the sub-directory if needed */
00009e  7ae8              LDRB     r0,[r5,#0xb]
0000a0  06c0              LSLS     r0,r0,#27
0000a2  d51f              BPL      |L29.228|
0000a4  990c              LDR      r1,[sp,#0x30]
0000a6  9814              LDR      r0,[sp,#0x50]
0000a8  4288              CMP      r0,r1
0000aa  d01b              BEQ      |L29.228|
;;;3754   							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
0000ac  4629              MOV      r1,r5
0000ae  9812              LDR      r0,[sp,#0x48]
0000b0  f7fffffe          BL       ld_clust
0000b4  4601              MOV      r1,r0
0000b6  9812              LDR      r0,[sp,#0x48]
0000b8  f7fffffe          BL       clust2sect
0000bc  4601              MOV      r1,r0
;;;3755   							if (!dw) {
0000be  b139              CBZ      r1,|L29.208|
;;;3756   								res = FR_INT_ERR;
;;;3757   							} else {
;;;3758   								res = move_window(djo.fs, dw);
0000c0  9812              LDR      r0,[sp,#0x48]
0000c2  f7fffffe          BL       move_window
0000c6  4604              MOV      r4,r0
;;;3759   								dir = djo.fs->win + SZ_DIRE * 1;	/* Ptr to .. entry */
0000c8  9812              LDR      r0,[sp,#0x48]
0000ca  3050              ADDS     r0,r0,#0x50
;;;3760   								if (res == FR_OK && dir[1] == '.') {
0000cc  b114              CBZ      r4,|L29.212|
0000ce  e009              B        |L29.228|
                  |L29.208|
0000d0  2402              MOVS     r4,#2                 ;3756
0000d2  e007              B        |L29.228|
                  |L29.212|
0000d4  7841              LDRB     r1,[r0,#1]
0000d6  292e              CMP      r1,#0x2e
0000d8  d104              BNE      |L29.228|
;;;3761   									st_clust(dir, djn.sclust);
0000da  990c              LDR      r1,[sp,#0x30]
0000dc  f7fffffe          BL       st_clust
;;;3762   									djo.fs->wflag = 1;
0000e0  9812              LDR      r0,[sp,#0x48]
0000e2  7106              STRB     r6,[r0,#4]
                  |L29.228|
;;;3763   								}
;;;3764   							}
;;;3765   						}
;;;3766   						if (res == FR_OK) {
0000e4  b944              CBNZ     r4,|L29.248|
;;;3767   							res = dir_remove(&djo);		/* Remove old entry */
0000e6  a812              ADD      r0,sp,#0x48
0000e8  f7fffffe          BL       dir_remove
0000ec  4604              MOV      r4,r0
;;;3768   							if (res == FR_OK)
0000ee  b91c              CBNZ     r4,|L29.248|
;;;3769   								res = sync_fs(djo.fs);
0000f0  9812              LDR      r0,[sp,#0x48]
0000f2  f7fffffe          BL       sync_fs
0000f6  4604              MOV      r4,r0
                  |L29.248|
;;;3770   						}
;;;3771   /* End of critical section */
;;;3772   					}
;;;3773   				}
;;;3774   			}
;;;3775   		}
;;;3776   		FREE_BUF();
;;;3777   	}
;;;3778   
;;;3779   	LEAVE_FF(djo.fs, res);
;;;3780   }
0000f8  b01c              ADD      sp,sp,#0x70
0000fa  4620              MOV      r0,r4                 ;3779
0000fc  bd70              POP      {r4-r6,pc}
;;;3781   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;3368   
;;;3369   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3370   	const TCHAR* path,	/* Pointer to the file path */
;;;3371   	FILINFO* fno		/* Pointer to file information to return */
;;;3372   )
;;;3373   {
000002  b08b              SUB      sp,sp,#0x2c
000004  460d              MOV      r5,r1
;;;3374   	FRESULT res;
;;;3375   	DIR dj;
;;;3376   	DEFINE_NAMEBUF;
;;;3377   
;;;3378   
;;;3379   	/* Get logical drive number */
;;;3380   	res = find_volume(&dj.fs, &path, 0);
000006  2200              MOVS     r2,#0
000008  a90b              ADD      r1,sp,#0x2c
00000a  a803              ADD      r0,sp,#0xc
00000c  f7fffffe          BL       find_volume
000010  4604              MOV      r4,r0
;;;3381   	if (res == FR_OK) {
000012  b984              CBNZ     r4,|L30.54|
;;;3382   		INIT_BUF(dj);
000014  f8cdd024          STR      sp,[sp,#0x24]
;;;3383   		res = follow_path(&dj, path);	/* Follow the file path */
000018  a803              ADD      r0,sp,#0xc
00001a  990b              LDR      r1,[sp,#0x2c]
00001c  f7fffffe          BL       follow_path
000020  4604              MOV      r4,r0
;;;3384   		if (res == FR_OK) {				/* Follow completed */
000022  b944              CBNZ     r4,|L30.54|
;;;3385   			if (dj.dir) {		/* Found an object */
000024  9808              LDR      r0,[sp,#0x20]
000026  b128              CBZ      r0,|L30.52|
;;;3386   				if (fno) get_fileinfo(&dj, fno);
000028  b12d              CBZ      r5,|L30.54|
00002a  4629              MOV      r1,r5
00002c  a803              ADD      r0,sp,#0xc
00002e  f7fffffe          BL       get_fileinfo
000032  e000              B        |L30.54|
                  |L30.52|
;;;3387   			} else {			/* It is root directory */
;;;3388   				res = FR_INVALID_NAME;
000034  2406              MOVS     r4,#6
                  |L30.54|
;;;3389   			}
;;;3390   		}
;;;3391   		FREE_BUF();
;;;3392   	}
;;;3393   
;;;3394   	LEAVE_FF(dj.fs, res);
;;;3395   }
000036  b00d              ADD      sp,sp,#0x34
000038  4620              MOV      r0,r4                 ;3394
00003a  bd30              POP      {r4,r5,pc}
;;;3396   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;2808   
;;;2809   FRESULT f_sync (
000000  b570              PUSH     {r4-r6,lr}
;;;2810   	FIL* fp		/* Pointer to the file object */
;;;2811   )
;;;2812   {
000002  4604              MOV      r4,r0
;;;2813   	FRESULT res;
;;;2814   	DWORD tm;
;;;2815   	BYTE *dir;
;;;2816   
;;;2817   
;;;2818   	res = validate(fp);					/* Check validity of the object */
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       validate
;;;2819   	if (res == FR_OK) {
00000a  2800              CMP      r0,#0
00000c  d10e              BNE      |L31.44|
;;;2820   		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
00000e  79a1              LDRB     r1,[r4,#6]
000010  068a              LSLS     r2,r1,#26
000012  d50b              BPL      |L31.44|
;;;2821   #if !_FS_TINY
;;;2822   			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
000014  0648              LSLS     r0,r1,#25
000016  d50e              BPL      |L31.54|
;;;2823   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
000018  6820              LDR      r0,[r4,#0]
00001a  2301              MOVS     r3,#1
00001c  f1040128          ADD      r1,r4,#0x28
000020  7840              LDRB     r0,[r0,#1]
000022  69a2              LDR      r2,[r4,#0x18]
000024  f7fffffe          BL       disk_write
000028  b108              CBZ      r0,|L31.46|
;;;2824   					LEAVE_FF(fp->fs, FR_DISK_ERR);
00002a  2001              MOVS     r0,#1
                  |L31.44|
;;;2825   				fp->flag &= ~FA__DIRTY;
;;;2826   			}
;;;2827   #endif
;;;2828   			/* Update the directory entry */
;;;2829   			res = move_window(fp->fs, fp->dir_sect);
;;;2830   			if (res == FR_OK) {
;;;2831   				dir = fp->dir_ptr;
;;;2832   				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;;;2833   				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
;;;2834   				st_clust(dir, fp->sclust);					/* Update start cluster */
;;;2835   				tm = GET_FATTIME();							/* Update modified time */
;;;2836   				ST_DWORD(dir + DIR_WrtTime, tm);
;;;2837   				ST_WORD(dir + DIR_LstAccDate, 0);
;;;2838   				fp->flag &= ~FA__WRITTEN;
;;;2839   				fp->fs->wflag = 1;
;;;2840   				res = sync_fs(fp->fs);
;;;2841   			}
;;;2842   		}
;;;2843   	}
;;;2844   
;;;2845   	LEAVE_FF(fp->fs, res);
;;;2846   }
00002c  bd70              POP      {r4-r6,pc}
                  |L31.46|
00002e  79a0              LDRB     r0,[r4,#6]            ;2825
000030  f0200040          BIC      r0,r0,#0x40           ;2825
000034  71a0              STRB     r0,[r4,#6]            ;2825
                  |L31.54|
000036  69e1              LDR      r1,[r4,#0x1c]         ;2829
000038  6820              LDR      r0,[r4,#0]            ;2829
00003a  f7fffffe          BL       move_window
00003e  2800              CMP      r0,#0                 ;2830
000040  d1f4              BNE      |L31.44|
000042  6a25              LDR      r5,[r4,#0x20]         ;2831
000044  7ae8              LDRB     r0,[r5,#0xb]          ;2832
000046  f0400020          ORR      r0,r0,#0x20           ;2832
00004a  72e8              STRB     r0,[r5,#0xb]          ;2832
00004c  7b20              LDRB     r0,[r4,#0xc]          ;2833
00004e  7728              STRB     r0,[r5,#0x1c]         ;2833
000050  89a0              LDRH     r0,[r4,#0xc]          ;2833
000052  0a00              LSRS     r0,r0,#8              ;2833
000054  7768              STRB     r0,[r5,#0x1d]         ;2833
000056  68e0              LDR      r0,[r4,#0xc]          ;2833
000058  0c00              LSRS     r0,r0,#16             ;2833
00005a  77a8              STRB     r0,[r5,#0x1e]         ;2833
00005c  68e0              LDR      r0,[r4,#0xc]          ;2833
00005e  0e00              LSRS     r0,r0,#24             ;2833
000060  77e8              STRB     r0,[r5,#0x1f]         ;2833
000062  4628              MOV      r0,r5                 ;2834
000064  6921              LDR      r1,[r4,#0x10]         ;2834
000066  f7fffffe          BL       st_clust
00006a  f7fffffe          BL       get_fattime
00006e  75a8              STRB     r0,[r5,#0x16]         ;2836
000070  0a01              LSRS     r1,r0,#8              ;2836
000072  75e9              STRB     r1,[r5,#0x17]         ;2836
000074  0c01              LSRS     r1,r0,#16             ;2836
000076  7629              STRB     r1,[r5,#0x18]         ;2836
000078  0e00              LSRS     r0,r0,#24             ;2836
00007a  7668              STRB     r0,[r5,#0x19]         ;2836
00007c  2000              MOVS     r0,#0                 ;2837
00007e  74a8              STRB     r0,[r5,#0x12]         ;2837
000080  74e8              STRB     r0,[r5,#0x13]         ;2837
000082  79a0              LDRB     r0,[r4,#6]            ;2838
000084  f0200020          BIC      r0,r0,#0x20           ;2838
000088  71a0              STRB     r0,[r4,#6]            ;2838
00008a  6821              LDR      r1,[r4,#0]            ;2839
00008c  2001              MOVS     r0,#1                 ;2839
00008e  7108              STRB     r0,[r1,#4]            ;2839
000090  6820              LDR      r0,[r4,#0]            ;2840
000092  e8bd4070          POP      {r4-r6,lr}            ;2840
000096  f7ffbffe          B.W      sync_fs
;;;2847   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;3469   
;;;3470   FRESULT f_truncate (
000000  b570              PUSH     {r4-r6,lr}
;;;3471   	FIL* fp		/* Pointer to the file object */
;;;3472   )
;;;3473   {
000002  4604              MOV      r4,r0
;;;3474   	FRESULT res;
;;;3475   	DWORD ncl;
;;;3476   
;;;3477   
;;;3478   	res = validate(fp);						/* Check validity of the object */
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       validate
00000a  4605              MOV      r5,r0
;;;3479   	if (res == FR_OK) {
00000c  0028              MOVS     r0,r5
00000e  d107              BNE      |L32.32|
;;;3480   		if (fp->err) {						/* Check error */
000010  79e0              LDRB     r0,[r4,#7]
000012  b108              CBZ      r0,|L32.24|
;;;3481   			res = (FRESULT)fp->err;
000014  4605              MOV      r5,r0
000016  e003              B        |L32.32|
                  |L32.24|
;;;3482   		} else {
;;;3483   			if (!(fp->flag & FA_WRITE))		/* Check access mode */
000018  79a0              LDRB     r0,[r4,#6]
00001a  0780              LSLS     r0,r0,#30
00001c  d400              BMI      |L32.32|
;;;3484   				res = FR_DENIED;
00001e  2507              MOVS     r5,#7
                  |L32.32|
;;;3485   		}
;;;3486   	}
;;;3487   	if (res == FR_OK) {
000020  bbf5              CBNZ     r5,|L32.160|
;;;3488   		if (fp->fsize > fp->fptr) {
000022  e9d40102          LDRD     r0,r1,[r4,#8]
000026  4281              CMP      r1,r0
000028  d93f              BLS      |L32.170|
;;;3489   			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
00002a  60e0              STR      r0,[r4,#0xc]
;;;3490   			fp->flag |= FA__WRITTEN;
00002c  79a1              LDRB     r1,[r4,#6]
00002e  f0410120          ORR      r1,r1,#0x20
000032  71a1              STRB     r1,[r4,#6]
;;;3491   			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
000034  b138              CBZ      r0,|L32.70|
;;;3492   				res = remove_chain(fp->fs, fp->sclust);
;;;3493   				fp->sclust = 0;
;;;3494   			} else {				/* When truncate a part of the file, remove remaining clusters */
;;;3495   				ncl = get_fat(fp->fs, fp->clust);
000036  6961              LDR      r1,[r4,#0x14]
000038  6820              LDR      r0,[r4,#0]
00003a  f7fffffe          BL       get_fat
00003e  4606              MOV      r6,r0
;;;3496   				res = FR_OK;
;;;3497   				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
000040  1c70              ADDS     r0,r6,#1
000042  d008              BEQ      |L32.86|
000044  e008              B        |L32.88|
                  |L32.70|
000046  6921              LDR      r1,[r4,#0x10]         ;3492
000048  6820              LDR      r0,[r4,#0]            ;3492
00004a  f7fffffe          BL       remove_chain
00004e  4605              MOV      r5,r0                 ;3492
000050  2000              MOVS     r0,#0                 ;3493
000052  6120              STR      r0,[r4,#0x10]         ;3493
000054  e015              B        |L32.130|
                  |L32.86|
000056  2501              MOVS     r5,#1
                  |L32.88|
;;;3498   				if (ncl == 1) res = FR_INT_ERR;
000058  2e01              CMP      r6,#1
00005a  d100              BNE      |L32.94|
00005c  2502              MOVS     r5,#2
                  |L32.94|
;;;3499   				if (res == FR_OK && ncl < fp->fs->n_fatent) {
00005e  b985              CBNZ     r5,|L32.130|
000060  6820              LDR      r0,[r4,#0]
000062  6941              LDR      r1,[r0,#0x14]
000064  42b1              CMP      r1,r6
000066  d90c              BLS      |L32.130|
;;;3500   					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
000068  f06f4270          MVN      r2,#0xf0000000
00006c  6961              LDR      r1,[r4,#0x14]
00006e  f7fffffe          BL       put_fat
000072  4605              MOV      r5,r0
;;;3501   					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
000074  0028              MOVS     r0,r5
000076  d104              BNE      |L32.130|
000078  4631              MOV      r1,r6
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       remove_chain
000080  4605              MOV      r5,r0
                  |L32.130|
;;;3502   				}
;;;3503   			}
;;;3504   #if !_FS_TINY
;;;3505   			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
000082  b995              CBNZ     r5,|L32.170|
000084  79a0              LDRB     r0,[r4,#6]
000086  0640              LSLS     r0,r0,#25
000088  d50f              BPL      |L32.170|
;;;3506   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
00008a  6820              LDR      r0,[r4,#0]
00008c  2301              MOVS     r3,#1
00008e  f1040128          ADD      r1,r4,#0x28
000092  7840              LDRB     r0,[r0,#1]
000094  69a2              LDR      r2,[r4,#0x18]
000096  f7fffffe          BL       disk_write
00009a  b110              CBZ      r0,|L32.162|
;;;3507   					res = FR_DISK_ERR;
00009c  2501              MOVS     r5,#1
00009e  e004              B        |L32.170|
                  |L32.160|
0000a0  e005              B        |L32.174|
                  |L32.162|
;;;3508   				else
;;;3509   					fp->flag &= ~FA__DIRTY;
0000a2  79a0              LDRB     r0,[r4,#6]
0000a4  f0200040          BIC      r0,r0,#0x40
0000a8  71a0              STRB     r0,[r4,#6]
                  |L32.170|
;;;3510   			}
;;;3511   #endif
;;;3512   		}
;;;3513   		if (res != FR_OK) fp->err = (FRESULT)res;
0000aa  b105              CBZ      r5,|L32.174|
0000ac  71e5              STRB     r5,[r4,#7]
                  |L32.174|
;;;3514   	}
;;;3515   
;;;3516   	LEAVE_FF(fp->fs, res);
0000ae  4628              MOV      r0,r5
;;;3517   }
0000b0  bd70              POP      {r4-r6,pc}
;;;3518   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;3525   
;;;3526   FRESULT f_unlink (
000000  b571              PUSH     {r0,r4-r6,lr}
;;;3527   	const TCHAR* path		/* Pointer to the file or directory path */
;;;3528   )
;;;3529   {
000002  b093              SUB      sp,sp,#0x4c
;;;3530   	FRESULT res;
;;;3531   	DIR dj, sdj;
;;;3532   	BYTE *dir;
;;;3533   	DWORD dclst = 0;
000004  2500              MOVS     r5,#0
;;;3534   	DEFINE_NAMEBUF;
;;;3535   
;;;3536   
;;;3537   	/* Get logical drive number */
;;;3538   	res = find_volume(&dj.fs, &path, 1);
000006  2201              MOVS     r2,#1
000008  a913              ADD      r1,sp,#0x4c
00000a  a80b              ADD      r0,sp,#0x2c
00000c  f7fffffe          BL       find_volume
000010  4604              MOV      r4,r0
;;;3539   	if (res == FR_OK) {
000012  2c00              CMP      r4,#0
000014  d147              BNE      |L33.166|
;;;3540   		INIT_BUF(dj);
000016  f8cdd044          STR      sp,[sp,#0x44]
;;;3541   		res = follow_path(&dj, path);		/* Follow the file path */
00001a  a80b              ADD      r0,sp,#0x2c
00001c  9913              LDR      r1,[sp,#0x4c]
00001e  f7fffffe          BL       follow_path
000022  4604              MOV      r4,r0
;;;3542   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3543   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;3544   #if _FS_LOCK
;;;3545   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
000024  b924              CBNZ     r4,|L33.48|
000026  2102              MOVS     r1,#2
000028  a80b              ADD      r0,sp,#0x2c
00002a  f7fffffe          BL       chk_lock
00002e  4604              MOV      r4,r0
                  |L33.48|
;;;3546   #endif
;;;3547   		if (res == FR_OK) {					/* The object is accessible */
000030  bbcc              CBNZ     r4,|L33.166|
;;;3548   			dir = dj.dir;
000032  9e10              LDR      r6,[sp,#0x40]
;;;3549   			if (!dir) {
000034  b12e              CBZ      r6,|L33.66|
;;;3550   				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
;;;3551   			} else {
;;;3552   				if (dir[DIR_Attr] & AM_RDO)
000036  7af0              LDRB     r0,[r6,#0xb]
000038  07c0              LSLS     r0,r0,#31
00003a  d000              BEQ      |L33.62|
;;;3553   					res = FR_DENIED;		/* Cannot remove R/O object */
00003c  2407              MOVS     r4,#7
                  |L33.62|
;;;3554   			}
;;;3555   			if (res == FR_OK) {
00003e  b114              CBZ      r4,|L33.70|
000040  e020              B        |L33.132|
                  |L33.66|
000042  2406              MOVS     r4,#6                 ;3550
000044  e7fb              B        |L33.62|
                  |L33.70|
;;;3556   				dclst = ld_clust(dj.fs, dir);
000046  4631              MOV      r1,r6
000048  980b              LDR      r0,[sp,#0x2c]
00004a  f7fffffe          BL       ld_clust
00004e  4605              MOV      r5,r0
;;;3557   				if (dclst && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-directory ? */
000050  b1c5              CBZ      r5,|L33.132|
000052  7af0              LDRB     r0,[r6,#0xb]
000054  06c0              LSLS     r0,r0,#27
000056  d515              BPL      |L33.132|
;;;3558   #if _FS_RPATH
;;;3559   					if (dclst == dj.fs->cdir) {		 		/* Is it the current directory? */
;;;3560   						res = FR_DENIED;
;;;3561   					} else
;;;3562   #endif
;;;3563   					{
;;;3564   						mem_cpy(&sdj, &dj, sizeof (DIR));	/* Open the sub-directory */
000058  2220              MOVS     r2,#0x20
00005a  a90b              ADD      r1,sp,#0x2c
00005c  a803              ADD      r0,sp,#0xc
00005e  f7fffffe          BL       mem_cpy
;;;3565   						sdj.sclust = dclst;
000062  9505              STR      r5,[sp,#0x14]
;;;3566   						res = dir_sdi(&sdj, 2);
000064  2102              MOVS     r1,#2
000066  a803              ADD      r0,sp,#0xc
000068  f7fffffe          BL       dir_sdi
00006c  4604              MOV      r4,r0
;;;3567   						if (res == FR_OK) {
00006e  b94c              CBNZ     r4,|L33.132|
;;;3568   							res = dir_read(&sdj, 0);			/* Read an item (excluding dot entries) */
000070  2100              MOVS     r1,#0
000072  a803              ADD      r0,sp,#0xc
000074  f7fffffe          BL       dir_read
000078  4604              MOV      r4,r0
;;;3569   							if (res == FR_OK) res = FR_DENIED;	/* Not empty? (cannot remove) */
00007a  b904              CBNZ     r4,|L33.126|
00007c  2407              MOVS     r4,#7
                  |L33.126|
;;;3570   							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? (can remove) */
00007e  2c04              CMP      r4,#4
000080  d100              BNE      |L33.132|
000082  2400              MOVS     r4,#0
                  |L33.132|
;;;3571   						}
;;;3572   					}
;;;3573   				}
;;;3574   			}
;;;3575   			if (res == FR_OK) {
000084  b97c              CBNZ     r4,|L33.166|
;;;3576   				res = dir_remove(&dj);		/* Remove the directory entry */
000086  a80b              ADD      r0,sp,#0x2c
000088  f7fffffe          BL       dir_remove
00008c  4604              MOV      r4,r0
;;;3577   				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
00008e  b92c              CBNZ     r4,|L33.156|
000090  b125              CBZ      r5,|L33.156|
;;;3578   					res = remove_chain(dj.fs, dclst);
000092  4629              MOV      r1,r5
000094  980b              LDR      r0,[sp,#0x2c]
000096  f7fffffe          BL       remove_chain
00009a  4604              MOV      r4,r0
                  |L33.156|
;;;3579   				if (res == FR_OK) res = sync_fs(dj.fs);
00009c  b91c              CBNZ     r4,|L33.166|
00009e  980b              LDR      r0,[sp,#0x2c]
0000a0  f7fffffe          BL       sync_fs
0000a4  4604              MOV      r4,r0
                  |L33.166|
;;;3580   			}
;;;3581   		}
;;;3582   		FREE_BUF();
;;;3583   	}
;;;3584   
;;;3585   	LEAVE_FF(dj.fs, res);
;;;3586   }
0000a6  b014              ADD      sp,sp,#0x50
0000a8  4620              MOV      r0,r4                 ;3585
0000aa  bd70              POP      {r4-r6,pc}
;;;3587   
                          ENDP


                          AREA ||i.f_utime||, CODE, READONLY, ALIGN=1

                  f_utime PROC
;;;3788   
;;;3789   FRESULT f_utime (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3790   	const TCHAR* path,	/* Pointer to the file/directory name */
;;;3791   	const FILINFO* fno	/* Pointer to the time stamp to be set */
;;;3792   )
;;;3793   {
000002  b08c              SUB      sp,sp,#0x30
000004  460c              MOV      r4,r1
;;;3794   	FRESULT res;
;;;3795   	DIR dj;
;;;3796   	BYTE *dir;
;;;3797   	DEFINE_NAMEBUF;
;;;3798   
;;;3799   
;;;3800   	/* Get logical drive number */
;;;3801   	res = find_volume(&dj.fs, &path, 1);
000006  2201              MOVS     r2,#1
000008  a90c              ADD      r1,sp,#0x30
00000a  a804              ADD      r0,sp,#0x10
00000c  f7fffffe          BL       find_volume
;;;3802   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d119              BNE      |L34.72|
;;;3803   		INIT_BUF(dj);
000014  a801              ADD      r0,sp,#4
000016  900a              STR      r0,[sp,#0x28]
;;;3804   		res = follow_path(&dj, path);	/* Follow the file path */
000018  a804              ADD      r0,sp,#0x10
00001a  990c              LDR      r1,[sp,#0x30]
00001c  f7fffffe          BL       follow_path
;;;3805   		FREE_BUF();
;;;3806   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
;;;3807   			res = FR_INVALID_NAME;
;;;3808   		if (res == FR_OK) {
000020  2800              CMP      r0,#0
000022  d111              BNE      |L34.72|
;;;3809   			dir = dj.dir;
000024  9809              LDR      r0,[sp,#0x24]
;;;3810   			if (!dir) {					/* Root directory */
000026  b188              CBZ      r0,|L34.76|
;;;3811   				res = FR_INVALID_NAME;
;;;3812   			} else {					/* File or sub-directory */
;;;3813   				ST_WORD(dir + DIR_WrtTime, fno->ftime);
000028  79a1              LDRB     r1,[r4,#6]
00002a  7581              STRB     r1,[r0,#0x16]
00002c  88e1              LDRH     r1,[r4,#6]
00002e  0a09              LSRS     r1,r1,#8
000030  75c1              STRB     r1,[r0,#0x17]
;;;3814   				ST_WORD(dir + DIR_WrtDate, fno->fdate);
000032  7921              LDRB     r1,[r4,#4]
000034  7601              STRB     r1,[r0,#0x18]
000036  88a1              LDRH     r1,[r4,#4]
000038  0a09              LSRS     r1,r1,#8
00003a  7641              STRB     r1,[r0,#0x19]
;;;3815   				dj.fs->wflag = 1;
00003c  9904              LDR      r1,[sp,#0x10]
00003e  2001              MOVS     r0,#1
000040  7108              STRB     r0,[r1,#4]
;;;3816   				res = sync_fs(dj.fs);
000042  9804              LDR      r0,[sp,#0x10]
000044  f7fffffe          BL       sync_fs
                  |L34.72|
;;;3817   			}
;;;3818   		}
;;;3819   	}
;;;3820   
;;;3821   	LEAVE_FF(dj.fs, res);
;;;3822   }
000048  b00e              ADD      sp,sp,#0x38
00004a  bd10              POP      {r4,pc}
                  |L34.76|
00004c  2006              MOVS     r0,#6                 ;3811
00004e  e7fb              B        |L34.72|
;;;3823   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;2686   
;;;2687   FRESULT f_write (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2688   	FIL* fp,			/* Pointer to the file object */
;;;2689   	const void *buff,	/* Pointer to the data to be written */
;;;2690   	UINT btw,			/* Number of bytes to write */
;;;2691   	UINT* bw			/* Pointer to number of bytes written */
;;;2692   )
;;;2693   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;2694   	FRESULT res;
;;;2695   	DWORD clst, sect;
;;;2696   	UINT wcnt, cc;
;;;2697   	const BYTE *wbuff = (const BYTE*)buff;
;;;2698   	BYTE csect;
;;;2699   
;;;2700   
;;;2701   	*bw = 0;	/* Clear write byte counter */
00000c  2000              MOVS     r0,#0
00000e  f8c80000          STR      r0,[r8,#0]
;;;2702   
;;;2703   	res = validate(fp);						/* Check validity */
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       validate
;;;2704   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000018  2800              CMP      r0,#0
00001a  d106              BNE      |L35.42|
;;;2705   	if (fp->err)							/* Check error */
00001c  79e0              LDRB     r0,[r4,#7]
00001e  2800              CMP      r0,#0
000020  d103              BNE      |L35.42|
;;;2706   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2707   	if (!(fp->flag & FA_WRITE))				/* Check access mode */
000022  79a0              LDRB     r0,[r4,#6]
000024  0780              LSLS     r0,r0,#30
000026  d402              BMI      |L35.46|
;;;2708   		LEAVE_FF(fp->fs, FR_DENIED);
000028  2007              MOVS     r0,#7
                  |L35.42|
;;;2709   	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
;;;2710   
;;;2711   	for ( ;  btw;							/* Repeat until all data written */
;;;2712   		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;;;2713   		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
;;;2714   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2715   			if (!csect) {					/* On the cluster boundary? */
;;;2716   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;2717   					clst = fp->sclust;		/* Follow from the origin */
;;;2718   					if (clst == 0)			/* When no cluster is allocated, */
;;;2719   						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;;;2720   				} else {					/* Middle or end of the file */
;;;2721   #if _USE_FASTSEEK
;;;2722   					if (fp->cltbl)
;;;2723   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2724   					else
;;;2725   #endif
;;;2726   						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;2727   				}
;;;2728   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;2729   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2730   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2731   				fp->clust = clst;			/* Update current cluster */
;;;2732   				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
;;;2733   			}
;;;2734   #if _FS_TINY
;;;2735   			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
;;;2736   				ABORT(fp->fs, FR_DISK_ERR);
;;;2737   #else
;;;2738   			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
;;;2739   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2740   					ABORT(fp->fs, FR_DISK_ERR);
;;;2741   				fp->flag &= ~FA__DIRTY;
;;;2742   			}
;;;2743   #endif
;;;2744   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2745   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2746   			sect += csect;
;;;2747   			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
;;;2748   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;2749   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2750   					cc = fp->fs->csize - csect;
;;;2751   				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
;;;2752   					ABORT(fp->fs, FR_DISK_ERR);
;;;2753   #if _FS_MINIMIZE <= 2
;;;2754   #if _FS_TINY
;;;2755   				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;2756   					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2757   					fp->fs->wflag = 0;
;;;2758   				}
;;;2759   #else
;;;2760   				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;2761   					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2762   					fp->flag &= ~FA__DIRTY;
;;;2763   				}
;;;2764   #endif
;;;2765   #endif
;;;2766   				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
;;;2767   				continue;
;;;2768   			}
;;;2769   #if _FS_TINY
;;;2770   			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
;;;2771   				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
;;;2772   				fp->fs->winsect = sect;
;;;2773   			}
;;;2774   #else
;;;2775   			if (fp->dsect != sect) {		/* Fill sector cache with file data */
;;;2776   				if (fp->fptr < fp->fsize &&
;;;2777   					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
;;;2778   						ABORT(fp->fs, FR_DISK_ERR);
;;;2779   			}
;;;2780   #endif
;;;2781   			fp->dsect = sect;
;;;2782   		}
;;;2783   		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
;;;2784   		if (wcnt > btw) wcnt = btw;
;;;2785   #if _FS_TINY
;;;2786   		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
;;;2787   			ABORT(fp->fs, FR_DISK_ERR);
;;;2788   		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2789   		fp->fs->wflag = 1;
;;;2790   #else
;;;2791   		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2792   		fp->flag |= FA__DIRTY;
;;;2793   #endif
;;;2794   	}
;;;2795   
;;;2796   	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;;;2797   	fp->flag |= FA__WRITTEN;						/* Set file change flag */
;;;2798   
;;;2799   	LEAVE_FF(fp->fs, FR_OK);
;;;2800   }
00002a  e8bd8ff8          POP      {r3-r11,pc}
                  |L35.46|
00002e  68a0              LDR      r0,[r4,#8]            ;2709
000030  1981              ADDS     r1,r0,r6              ;2709
000032  d300              BCC      |L35.54|
000034  2600              MOVS     r6,#0                 ;2709
                  |L35.54|
000036  f1040028          ADD      r0,r4,#0x28           ;2739
00003a  f04f0901          MOV      r9,#1                 ;2695
00003e  9000              STR      r0,[sp,#0]            ;2711
000040  e0a3              B        |L35.394|
                  |L35.66|
000042  68a0              LDR      r0,[r4,#8]            ;2713
000044  05c1              LSLS     r1,r0,#23             ;2713
000046  d17c              BNE      |L35.322|
000048  6822              LDR      r2,[r4,#0]            ;2714
00004a  7891              LDRB     r1,[r2,#2]            ;2714
00004c  1e49              SUBS     r1,r1,#1              ;2714
00004e  ea012150          AND      r1,r1,r0,LSR #9       ;2714
000052  f0010aff          AND      r10,r1,#0xff          ;2714
000056  f1ba0f00          CMP      r10,#0                ;2715
00005a  d11e              BNE      |L35.154|
00005c  b168              CBZ      r0,|L35.122|
00005e  4610              MOV      r0,r2                 ;2726
000060  6961              LDR      r1,[r4,#0x14]         ;2726
000062  f7fffffe          BL       create_chain
                  |L35.102|
000066  2800              CMP      r0,#0                 ;2728
000068  d06c              BEQ      |L35.324|
00006a  2801              CMP      r0,#1                 ;2729
00006c  d00d              BEQ      |L35.138|
00006e  1c41              ADDS     r1,r0,#1              ;2730
000070  d00e              BEQ      |L35.144|
000072  6160              STR      r0,[r4,#0x14]         ;2731
000074  6921              LDR      r1,[r4,#0x10]         ;2732
000076  b179              CBZ      r1,|L35.152|
000078  e00f              B        |L35.154|
                  |L35.122|
00007a  6920              LDR      r0,[r4,#0x10]         ;2717
00007c  2800              CMP      r0,#0                 ;2718
00007e  d1f2              BNE      |L35.102|
000080  2100              MOVS     r1,#0                 ;2719
000082  4610              MOV      r0,r2                 ;2719
000084  f7fffffe          BL       create_chain
000088  e7ed              B        |L35.102|
                  |L35.138|
00008a  2002              MOVS     r0,#2                 ;2729
00008c  71e0              STRB     r0,[r4,#7]            ;2729
00008e  e7cc              B        |L35.42|
                  |L35.144|
000090  f8849007          STRB     r9,[r4,#7]            ;2730
000094  2001              MOVS     r0,#1                 ;2730
000096  e7c8              B        |L35.42|
                  |L35.152|
000098  6120              STR      r0,[r4,#0x10]         ;2732
                  |L35.154|
00009a  79a0              LDRB     r0,[r4,#6]            ;2738
00009c  0640              LSLS     r0,r0,#25             ;2738
00009e  d50f              BPL      |L35.192|
0000a0  6820              LDR      r0,[r4,#0]            ;2739
0000a2  2301              MOVS     r3,#1                 ;2739
0000a4  69a2              LDR      r2,[r4,#0x18]         ;2739
0000a6  7840              LDRB     r0,[r0,#1]            ;2739
0000a8  9900              LDR      r1,[sp,#0]            ;2739
0000aa  f7fffffe          BL       disk_write
0000ae  b118              CBZ      r0,|L35.184|
0000b0  f8849007          STRB     r9,[r4,#7]            ;2740
0000b4  2001              MOVS     r0,#1                 ;2740
0000b6  e7b8              B        |L35.42|
                  |L35.184|
0000b8  79a0              LDRB     r0,[r4,#6]            ;2741
0000ba  f0200040          BIC      r0,r0,#0x40           ;2741
0000be  71a0              STRB     r0,[r4,#6]            ;2741
                  |L35.192|
0000c0  6961              LDR      r1,[r4,#0x14]         ;2744
0000c2  6820              LDR      r0,[r4,#0]            ;2744
0000c4  f7fffffe          BL       clust2sect
0000c8  b1b0              CBZ      r0,|L35.248|
0000ca  eb000b0a          ADD      r11,r0,r10            ;2746
0000ce  0a75              LSRS     r5,r6,#9              ;2747
0000d0  b33d              CBZ      r5,|L35.290|
0000d2  6820              LDR      r0,[r4,#0]            ;2749
0000d4  eb0a0205          ADD      r2,r10,r5             ;2749
0000d8  7881              LDRB     r1,[r0,#2]            ;2749
0000da  428a              CMP      r2,r1                 ;2749
0000dc  d901              BLS      |L35.226|
0000de  eba1050a          SUB      r5,r1,r10             ;2750
                  |L35.226|
0000e2  7840              LDRB     r0,[r0,#1]            ;2751
0000e4  462b              MOV      r3,r5                 ;2751
0000e6  465a              MOV      r2,r11                ;2751
0000e8  4639              MOV      r1,r7                 ;2751
0000ea  f7fffffe          BL       disk_write
0000ee  b130              CBZ      r0,|L35.254|
0000f0  f8849007          STRB     r9,[r4,#7]            ;2752
0000f4  2001              MOVS     r0,#1                 ;2752
0000f6  e798              B        |L35.42|
                  |L35.248|
0000f8  2002              MOVS     r0,#2                 ;2745
0000fa  71e0              STRB     r0,[r4,#7]            ;2745
0000fc  e795              B        |L35.42|
                  |L35.254|
0000fe  69a0              LDR      r0,[r4,#0x18]         ;2760
000100  eba0000b          SUB      r0,r0,r11             ;2760
000104  42a8              CMP      r0,r5                 ;2760
000106  d20a              BCS      |L35.286|
000108  eb072140          ADD      r1,r7,r0,LSL #9       ;2761
00010c  f44f7200          MOV      r2,#0x200             ;2761
000110  9800              LDR      r0,[sp,#0]            ;2761
000112  f7fffffe          BL       mem_cpy
000116  79a0              LDRB     r0,[r4,#6]            ;2762
000118  f0200040          BIC      r0,r0,#0x40           ;2762
00011c  71a0              STRB     r0,[r4,#6]            ;2762
                  |L35.286|
00011e  026d              LSLS     r5,r5,#9              ;2766
000120  e029              B        |L35.374|
                  |L35.290|
000122  69a0              LDR      r0,[r4,#0x18]         ;2775
000124  4558              CMP      r0,r11                ;2775
000126  d012              BEQ      |L35.334|
000128  e9d40102          LDRD     r0,r1,[r4,#8]         ;2776
00012c  4288              CMP      r0,r1                 ;2776
00012e  d20e              BCS      |L35.334|
000130  6820              LDR      r0,[r4,#0]            ;2777
000132  2301              MOVS     r3,#1                 ;2777
000134  465a              MOV      r2,r11                ;2777
000136  7840              LDRB     r0,[r0,#1]            ;2777
000138  9900              LDR      r1,[sp,#0]            ;2777
00013a  f7fffffe          BL       disk_read
00013e  b130              CBZ      r0,|L35.334|
000140  e001              B        |L35.326|
                  |L35.322|
000142  e006              B        |L35.338|
                  |L35.324|
000144  e024              B        |L35.400|
                  |L35.326|
000146  f8849007          STRB     r9,[r4,#7]            ;2778
00014a  2001              MOVS     r0,#1                 ;2778
00014c  e76d              B        |L35.42|
                  |L35.334|
00014e  f8c4b018          STR      r11,[r4,#0x18]        ;2781
                  |L35.338|
000152  8920              LDRH     r0,[r4,#8]            ;2783
000154  f3c00008          UBFX     r0,r0,#0,#9           ;2783
000158  f5c07500          RSB      r5,r0,#0x200          ;2783
00015c  42b5              CMP      r5,r6                 ;2784
00015e  d900              BLS      |L35.354|
000160  4635              MOV      r5,r6                 ;2784
                  |L35.354|
000162  4420              ADD      r0,r0,r4              ;2791
000164  3028              ADDS     r0,r0,#0x28           ;2791
000166  462a              MOV      r2,r5                 ;2791
000168  4639              MOV      r1,r7                 ;2791
00016a  f7fffffe          BL       mem_cpy
00016e  79a0              LDRB     r0,[r4,#6]            ;2792
000170  f0400040          ORR      r0,r0,#0x40           ;2792
000174  71a0              STRB     r0,[r4,#6]            ;2792
                  |L35.374|
000176  442f              ADD      r7,r7,r5              ;2712
000178  68a0              LDR      r0,[r4,#8]            ;2712
00017a  4428              ADD      r0,r0,r5              ;2712
00017c  60a0              STR      r0,[r4,#8]            ;2712
00017e  f8d80000          LDR      r0,[r8,#0]            ;2712
000182  4428              ADD      r0,r0,r5              ;2712
000184  f8c80000          STR      r0,[r8,#0]            ;2712
000188  1b76              SUBS     r6,r6,r5              ;2712
                  |L35.394|
00018a  2e00              CMP      r6,#0                 ;2711
00018c  f47faf59          BNE      |L35.66|
                  |L35.400|
000190  e9d40102          LDRD     r0,r1,[r4,#8]         ;2796
000194  4288              CMP      r0,r1                 ;2796
000196  d900              BLS      |L35.410|
000198  60e0              STR      r0,[r4,#0xc]          ;2796
                  |L35.410|
00019a  79a0              LDRB     r0,[r4,#6]            ;2797
00019c  f0400020          ORR      r0,r0,#0x20           ;2797
0001a0  71a0              STRB     r0,[r4,#6]            ;2797
0001a2  2000              MOVS     r0,#0                 ;2799
0001a4  e741              B        |L35.42|
;;;2801   
                          ENDP


                          AREA ||i.find_volume||, CODE, READONLY, ALIGN=2

                  find_volume PROC
;;;2202   static
;;;2203   FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;2204   	FATFS** rfs,		/* Pointer to pointer to the found file system object */
;;;2205   	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
;;;2206   	BYTE wmode			/* !=0: Check write protection for write access */
;;;2207   )
;;;2208   {
000004  4680              MOV      r8,r0
000006  4608              MOV      r0,r1
000008  4616              MOV      r6,r2
;;;2209   	BYTE fmt, *pt;
;;;2210   	int vol;
;;;2211   	DSTATUS stat;
;;;2212   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
;;;2213   	WORD nrsv;
;;;2214   	FATFS *fs;
;;;2215   	UINT i;
;;;2216   
;;;2217   
;;;2218   	/* Get logical drive number from the path name */
;;;2219   	*rfs = 0;
00000a  2700              MOVS     r7,#0
00000c  f8c87000          STR      r7,[r8,#0]
;;;2220   	vol = get_ldnumber(path);
000010  f7fffffe          BL       get_ldnumber
000014  4605              MOV      r5,r0
;;;2221   	if (vol < 0) return FR_INVALID_DRIVE;
000016  0028              MOVS     r0,r5
000018  d503              BPL      |L36.34|
00001a  200b              MOVS     r0,#0xb
                  |L36.28|
;;;2222   
;;;2223   	/* Check if the file system object is valid or not */
;;;2224   	fs = FatFs[vol];					/* Get pointer to the file system object */
;;;2225   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;2226   
;;;2227   	ENTER_FF(fs);						/* Lock the volume */
;;;2228   	*rfs = fs;							/* Return pointer to the file system object */
;;;2229   
;;;2230   	if (fs->fs_type) {					/* If the volume has been mounted */
;;;2231   		stat = disk_status(fs->drv);
;;;2232   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
;;;2233   			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;2234   				return FR_WRITE_PROTECTED;
;;;2235   			return FR_OK;				/* The file system object is valid */
;;;2236   		}
;;;2237   	}
;;;2238   
;;;2239   	/* The file system object is not valid. */
;;;2240   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2241   
;;;2242   	fs->fs_type = 0;					/* Clear the file system object */
;;;2243   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2244   	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;;;2245   	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;;;2246   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;2247   	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;2248   		return FR_WRITE_PROTECTED;
;;;2249   #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
;;;2250   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
;;;2251   		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
;;;2252   #endif
;;;2253   	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
;;;2254   	bsect = 0;
;;;2255   	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
;;;2256   	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
;;;2257   		for (i = 0; i < 4; i++) {			/* Get partition offset */
;;;2258   			pt = fs->win + MBR_Table + i * SZ_PTE;
;;;2259   			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
;;;2260   		}
;;;2261   		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
;;;2262   		if (i) i--;
;;;2263   		do {								/* Find an FAT volume */
;;;2264   			bsect = br[i];
;;;2265   			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
;;;2266   		} while (!LD2PT(vol) && fmt && ++i < 4);
;;;2267   	}
;;;2268   	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;;;2269   	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;;;2270   
;;;2271   	/* An FAT volume is found. Following code initializes the file system object */
;;;2272   
;;;2273   	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;2274   		return FR_NO_FILESYSTEM;
;;;2275   
;;;2276   	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
;;;2277   	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
;;;2278   	fs->fsize = fasize;
;;;2279   
;;;2280   	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
;;;2281   	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
;;;2282   		return FR_NO_FILESYSTEM;
;;;2283   	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
;;;2284   
;;;2285   	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
;;;2286   	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
;;;2287   		return FR_NO_FILESYSTEM;
;;;2288   
;;;2289   	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
;;;2290   	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
;;;2291   		return FR_NO_FILESYSTEM;
;;;2292   
;;;2293   	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
;;;2294   	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
;;;2295   
;;;2296   	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
;;;2297   	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
;;;2298   
;;;2299   	/* Determine the FAT sub type */
;;;2300   	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
;;;2301   	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;2302   	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;2303   	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;;;2304   	fmt = FS_FAT12;
;;;2305   	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;;;2306   	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;;;2307   
;;;2308   	/* Boundaries and Limits */
;;;2309   	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;2310   	fs->volbase = bsect;								/* Volume start sector */
;;;2311   	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;2312   	fs->database = bsect + sysect;						/* Data start sector */
;;;2313   	if (fmt == FS_FAT32) {
;;;2314   		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;2315   		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
;;;2316   		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
;;;2317   	} else {
;;;2318   		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;2319   		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;2320   		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
;;;2321   			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;2322   	}
;;;2323   	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
;;;2324   		return FR_NO_FILESYSTEM;
;;;2325   
;;;2326   #if !_FS_READONLY
;;;2327   	/* Initialize cluster allocation information */
;;;2328   	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
;;;2329   
;;;2330   	/* Get fsinfo if available */
;;;2331   	fs->fsi_flag = 0x80;
;;;2332   #if (_FS_NOFSINFO & 3) != 3
;;;2333   	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
;;;2334   		&& LD_WORD(fs->win + BPB_FSInfo) == 1
;;;2335   		&& move_window(fs, bsect + 1) == FR_OK)
;;;2336   	{
;;;2337   		fs->fsi_flag = 0;
;;;2338   		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
;;;2339   			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
;;;2340   			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
;;;2341   		{
;;;2342   #if (_FS_NOFSINFO & 1) == 0
;;;2343   			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
;;;2344   #endif
;;;2345   #if (_FS_NOFSINFO & 2) == 0
;;;2346   			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
;;;2347   #endif
;;;2348   		}
;;;2349   	}
;;;2350   #endif
;;;2351   #endif
;;;2352   	fs->fs_type = fmt;	/* FAT sub-type */
;;;2353   	fs->id = ++Fsid;	/* File system mount ID */
;;;2354   #if _FS_RPATH
;;;2355   	fs->cdir = 0;		/* Set current directory to root */
;;;2356   #endif
;;;2357   #if _FS_LOCK			/* Clear file lock semaphores */
;;;2358   	clear_lock(fs);
;;;2359   #endif
;;;2360   
;;;2361   	return FR_OK;
;;;2362   }
00001c  b004              ADD      sp,sp,#0x10
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L36.34|
000022  48b9              LDR      r0,|L36.776|
000024  f8504025          LDR      r4,[r0,r5,LSL #2]     ;2224
000028  b18c              CBZ      r4,|L36.78|
00002a  f8c84000          STR      r4,[r8,#0]            ;2228
00002e  7820              LDRB     r0,[r4,#0]            ;2230
000030  b120              CBZ      r0,|L36.60|
000032  7860              LDRB     r0,[r4,#1]            ;2231
000034  f7fffffe          BL       disk_status
000038  07c1              LSLS     r1,r0,#31             ;2232
00003a  d00a              BEQ      |L36.82|
                  |L36.60|
00003c  7027              STRB     r7,[r4,#0]            ;2242
00003e  b2e8              UXTB     r0,r5                 ;2243
000040  7060              STRB     r0,[r4,#1]            ;2243
000042  f7fffffe          BL       disk_initialize
000046  07c1              LSLS     r1,r0,#31             ;2245
000048  d00a              BEQ      |L36.96|
00004a  2003              MOVS     r0,#3                 ;2246
00004c  e7e6              B        |L36.28|
                  |L36.78|
00004e  200c              MOVS     r0,#0xc               ;2225
000050  e7e4              B        |L36.28|
                  |L36.82|
000052  b11e              CBZ      r6,|L36.92|
000054  0740              LSLS     r0,r0,#29             ;2233
000056  d501              BPL      |L36.92|
000058  200a              MOVS     r0,#0xa               ;2234
00005a  e7df              B        |L36.28|
                  |L36.92|
00005c  2000              MOVS     r0,#0                 ;2235
00005e  e7dd              B        |L36.28|
                  |L36.96|
000060  b11e              CBZ      r6,|L36.106|
000062  0740              LSLS     r0,r0,#29             ;2247
000064  d501              BPL      |L36.106|
000066  200a              MOVS     r0,#0xa               ;2248
000068  e7d8              B        |L36.28|
                  |L36.106|
00006a  2500              MOVS     r5,#0                 ;2254
00006c  4629              MOV      r1,r5                 ;2255
00006e  4620              MOV      r0,r4                 ;2255
000070  f7fffffe          BL       check_fs
000074  2801              CMP      r0,#1                 ;2256
000076  d126              BNE      |L36.198|
000078  2100              MOVS     r1,#0                 ;2257
00007a  46e8              MOV      r8,sp                 ;2212
                  |L36.124|
00007c  eb041001          ADD      r0,r4,r1,LSL #4       ;2258
000080  f50070f7          ADD      r0,r0,#0x1ee          ;2258
000084  7902              LDRB     r2,[r0,#4]            ;2259
000086  b152              CBZ      r2,|L36.158|
000088  7a02              LDRB     r2,[r0,#8]            ;2259
00008a  7ac3              LDRB     r3,[r0,#0xb]          ;2259
00008c  ea426203          ORR      r2,r2,r3,LSL #24      ;2259
000090  7a83              LDRB     r3,[r0,#0xa]          ;2259
000092  7a40              LDRB     r0,[r0,#9]            ;2259
000094  041b              LSLS     r3,r3,#16             ;2259
000096  ea432000          ORR      r0,r3,r0,LSL #8       ;2259
00009a  4302              ORRS     r2,r2,r0              ;2259
00009c  e000              B        |L36.160|
                  |L36.158|
00009e  2200              MOVS     r2,#0                 ;2259
                  |L36.160|
0000a0  f8482021          STR      r2,[r8,r1,LSL #2]     ;2259
0000a4  1c49              ADDS     r1,r1,#1              ;2257
0000a6  2904              CMP      r1,#4                 ;2257
0000a8  d3e8              BCC      |L36.124|
0000aa  2600              MOVS     r6,#0                 ;2261
                  |L36.172|
0000ac  f8585026          LDR      r5,[r8,r6,LSL #2]     ;2264
0000b0  b125              CBZ      r5,|L36.188|
0000b2  4629              MOV      r1,r5                 ;2265
0000b4  4620              MOV      r0,r4                 ;2265
0000b6  f7fffffe          BL       check_fs
0000ba  e000              B        |L36.190|
                  |L36.188|
0000bc  2002              MOVS     r0,#2                 ;2265
                  |L36.190|
0000be  b110              CBZ      r0,|L36.198|
0000c0  1c76              ADDS     r6,r6,#1              ;2266
0000c2  2e04              CMP      r6,#4                 ;2266
0000c4  d3f2              BCC      |L36.172|
                  |L36.198|
0000c6  2803              CMP      r0,#3                 ;2268
0000c8  d002              BEQ      |L36.208|
0000ca  b118              CBZ      r0,|L36.212|
0000cc  200d              MOVS     r0,#0xd               ;2269
0000ce  e7a5              B        |L36.28|
                  |L36.208|
0000d0  2001              MOVS     r0,#1                 ;2268
0000d2  e7a3              B        |L36.28|
                  |L36.212|
0000d4  f894003b          LDRB     r0,[r4,#0x3b]         ;2273
0000d8  f894103c          LDRB     r1,[r4,#0x3c]         ;2273
0000dc  ea402001          ORR      r0,r0,r1,LSL #8       ;2273
0000e0  f5b07f00          CMP      r0,#0x200             ;2273
0000e4  d001              BEQ      |L36.234|
0000e6  200d              MOVS     r0,#0xd               ;2274
0000e8  e798              B        |L36.28|
                  |L36.234|
0000ea  f8940046          LDRB     r0,[r4,#0x46]         ;2276
0000ee  f8941047          LDRB     r1,[r4,#0x47]         ;2276
0000f2  ea402101          ORR      r1,r0,r1,LSL #8       ;2276
0000f6  b959              CBNZ     r1,|L36.272|
0000f8  f8140f54          LDRB     r0,[r4,#0x54]!        ;2277
0000fc  78e1              LDRB     r1,[r4,#3]            ;2277
0000fe  7862              LDRB     r2,[r4,#1]            ;2277
000100  ea406101          ORR      r1,r0,r1,LSL #24      ;2277
000104  78a0              LDRB     r0,[r4,#2]            ;2277
000106  0400              LSLS     r0,r0,#16             ;2277
000108  3c54              SUBS     r4,r4,#0x54           ;2277
00010a  ea402002          ORR      r0,r0,r2,LSL #8       ;2277
00010e  4301              ORRS     r1,r1,r0              ;2277
                  |L36.272|
000110  61a1              STR      r1,[r4,#0x18]         ;2278
000112  f8949040          LDRB     r9,[r4,#0x40]         ;2280
000116  f8849003          STRB     r9,[r4,#3]            ;2280
00011a  f1b90f01          CMP      r9,#1                 ;2281
00011e  d004              BEQ      |L36.298|
000120  f1b90f02          CMP      r9,#2                 ;2281
000124  d001              BEQ      |L36.298|
000126  200d              MOVS     r0,#0xd               ;2282
000128  e778              B        |L36.28|
                  |L36.298|
00012a  fb09f901          MUL      r9,r9,r1              ;2283
00012e  f894203d          LDRB     r2,[r4,#0x3d]         ;2285
000132  70a2              STRB     r2,[r4,#2]            ;2285
000134  b112              CBZ      r2,|L36.316|
000136  1e50              SUBS     r0,r2,#1              ;2286
000138  4202              TST      r2,r0                 ;2286
00013a  d001              BEQ      |L36.320|
                  |L36.316|
00013c  200d              MOVS     r0,#0xd               ;2287
00013e  e76d              B        |L36.28|
                  |L36.320|
000140  f8940041          LDRB     r0,[r4,#0x41]         ;2289
000144  f8943042          LDRB     r3,[r4,#0x42]         ;2289
000148  ea402303          ORR      r3,r0,r3,LSL #8       ;2289
00014c  8123              STRH     r3,[r4,#8]            ;2289
00014e  0718              LSLS     r0,r3,#28             ;2290
000150  d001              BEQ      |L36.342|
000152  200d              MOVS     r0,#0xd               ;2291
000154  e762              B        |L36.28|
                  |L36.342|
000156  f8940043          LDRB     r0,[r4,#0x43]         ;2293
00015a  f8946044          LDRB     r6,[r4,#0x44]         ;2293
00015e  ea402006          ORR      r0,r0,r6,LSL #8       ;2293
000162  b960              CBNZ     r0,|L36.382|
000164  f8140f50          LDRB     r0,[r4,#0x50]!        ;2294
000168  78e6              LDRB     r6,[r4,#3]            ;2294
00016a  f894c001          LDRB     r12,[r4,#1]           ;2294
00016e  ea406006          ORR      r0,r0,r6,LSL #24      ;2294
000172  78a6              LDRB     r6,[r4,#2]            ;2294
000174  0436              LSLS     r6,r6,#16             ;2294
000176  3c50              SUBS     r4,r4,#0x50           ;2294
000178  ea46260c          ORR      r6,r6,r12,LSL #8      ;2294
00017c  4330              ORRS     r0,r0,r6              ;2294
                  |L36.382|
00017e  f894603e          LDRB     r6,[r4,#0x3e]         ;2296
000182  f894c03f          LDRB     r12,[r4,#0x3f]        ;2296
000186  ea46280c          ORR      r8,r6,r12,LSL #8      ;2296
00018a  f1b80f00          CMP      r8,#0                 ;2297
00018e  d007              BEQ      |L36.416|
000190  eb080609          ADD      r6,r8,r9              ;2300
000194  eb061c13          ADD      r12,r6,r3,LSR #4      ;2300
000198  4560              CMP      r0,r12                ;2301
00019a  d203              BCS      |L36.420|
00019c  200d              MOVS     r0,#0xd               ;2301
00019e  e73d              B        |L36.28|
                  |L36.416|
0001a0  200d              MOVS     r0,#0xd               ;2297
0001a2  e73b              B        |L36.28|
                  |L36.420|
0001a4  eba0000c          SUB      r0,r0,r12             ;2302
0001a8  fbb0f0f2          UDIV     r0,r0,r2              ;2302
0001ac  b338              CBZ      r0,|L36.510|
0001ae  2601              MOVS     r6,#1                 ;2304
0001b0  f64072f6          MOV      r2,#0xff6             ;2305
0001b4  4290              CMP      r0,r2                 ;2305
0001b6  d300              BCC      |L36.442|
0001b8  2602              MOVS     r6,#2                 ;2305
                  |L36.442|
0001ba  f64f72f6          MOV      r2,#0xfff6            ;2306
0001be  4290              CMP      r0,r2                 ;2306
0001c0  d300              BCC      |L36.452|
0001c2  2603              MOVS     r6,#3                 ;2306
                  |L36.452|
0001c4  1c80              ADDS     r0,r0,#2              ;2309
0001c6  6160              STR      r0,[r4,#0x14]         ;2309
0001c8  61e5              STR      r5,[r4,#0x1c]         ;2310
0001ca  eb050208          ADD      r2,r5,r8              ;2311
0001ce  6222              STR      r2,[r4,#0x20]         ;2311
0001d0  44ac              ADD      r12,r12,r5            ;2312
0001d2  f8c4c028          STR      r12,[r4,#0x28]        ;2312
0001d6  2e03              CMP      r6,#3                 ;2313
0001d8  d013              BEQ      |L36.514|
0001da  b333              CBZ      r3,|L36.554|
0001dc  444a              ADD      r2,r2,r9              ;2319
0001de  6262              STR      r2,[r4,#0x24]         ;2319
0001e0  2e02              CMP      r6,#2                 ;2320
0001e2  d024              BEQ      |L36.558|
0001e4  f0000201          AND      r2,r0,#1              ;2321
0001e8  eb000040          ADD      r0,r0,r0,LSL #1       ;2321
0001ec  eb020050          ADD      r0,r2,r0,LSR #1       ;2321
                  |L36.496|
0001f0  f20010ff          ADD      r0,r0,#0x1ff          ;2323
0001f4  ebb12f50          CMP      r1,r0,LSR #9          ;2323
0001f8  d21b              BCS      |L36.562|
0001fa  200d              MOVS     r0,#0xd               ;2324
0001fc  e70e              B        |L36.28|
                  |L36.510|
0001fe  200d              MOVS     r0,#0xd               ;2303
000200  e70c              B        |L36.28|
                  |L36.514|
000202  b10b              CBZ      r3,|L36.520|
000204  200d              MOVS     r0,#0xd               ;2314
000206  e709              B        |L36.28|
                  |L36.520|
000208  f894205c          LDRB     r2,[r4,#0x5c]         ;2315
00020c  f894305f          LDRB     r3,[r4,#0x5f]         ;2315
000210  f894c05d          LDRB     r12,[r4,#0x5d]        ;2315
000214  ea426203          ORR      r2,r2,r3,LSL #24      ;2315
000218  f894305e          LDRB     r3,[r4,#0x5e]         ;2315
00021c  041b              LSLS     r3,r3,#16             ;2315
00021e  ea43230c          ORR      r3,r3,r12,LSL #8      ;2315
000222  431a              ORRS     r2,r2,r3              ;2315
000224  6262              STR      r2,[r4,#0x24]         ;2315
000226  0080              LSLS     r0,r0,#2              ;2316
000228  e7e2              B        |L36.496|
                  |L36.554|
00022a  200d              MOVS     r0,#0xd               ;2318
00022c  e6f6              B        |L36.28|
                  |L36.558|
00022e  0040              LSLS     r0,r0,#1              ;2321
000230  e7de              B        |L36.496|
                  |L36.562|
000232  f04f30ff          MOV      r0,#0xffffffff        ;2328
000236  6120              STR      r0,[r4,#0x10]         ;2328
000238  60e0              STR      r0,[r4,#0xc]          ;2328
00023a  2080              MOVS     r0,#0x80              ;2331
00023c  7160              STRB     r0,[r4,#5]            ;2331
00023e  2e03              CMP      r6,#3                 ;2333
000240  d157              BNE      |L36.754|
000242  f8940060          LDRB     r0,[r4,#0x60]         ;2334
000246  f8941061          LDRB     r1,[r4,#0x61]         ;2334
00024a  ea402001          ORR      r0,r0,r1,LSL #8       ;2334
00024e  2801              CMP      r0,#1                 ;2334
000250  d14f              BNE      |L36.754|
000252  1c69              ADDS     r1,r5,#1              ;2335
000254  4620              MOV      r0,r4                 ;2335
000256  f7fffffe          BL       move_window
00025a  bbe0              CBNZ     r0,|L36.726|
00025c  7167              STRB     r7,[r4,#5]            ;2337
00025e  f894022e          LDRB     r0,[r4,#0x22e]        ;2338
000262  f894122f          LDRB     r1,[r4,#0x22f]        ;2338
000266  ea402001          ORR      r0,r0,r1,LSL #8       ;2338
00026a  f5a0412a          SUB      r1,r0,#0xaa00         ;2338
00026e  3955              SUBS     r1,r1,#0x55           ;2338
000270  d13f              BNE      |L36.754|
000272  f8140f30          LDRB     r0,[r4,#0x30]!        ;2339
000276  78e1              LDRB     r1,[r4,#3]            ;2339
000278  7862              LDRB     r2,[r4,#1]            ;2339
00027a  ea406001          ORR      r0,r0,r1,LSL #24      ;2339
00027e  78a1              LDRB     r1,[r4,#2]            ;2339
000280  3c30              SUBS     r4,r4,#0x30           ;2339
000282  0409              LSLS     r1,r1,#16             ;2339
000284  ea412102          ORR      r1,r1,r2,LSL #8       ;2339
000288  4308              ORRS     r0,r0,r1              ;2339
00028a  4920              LDR      r1,|L36.780|
00028c  4288              CMP      r0,r1                 ;2339
00028e  d130              BNE      |L36.754|
000290  f8940214          LDRB     r0,[r4,#0x214]        ;2340
000294  f8941217          LDRB     r1,[r4,#0x217]        ;2340
000298  f8942215          LDRB     r2,[r4,#0x215]        ;2340
00029c  ea406001          ORR      r0,r0,r1,LSL #24      ;2340
0002a0  f8941216          LDRB     r1,[r4,#0x216]        ;2340
0002a4  0409              LSLS     r1,r1,#16             ;2340
0002a6  ea412102          ORR      r1,r1,r2,LSL #8       ;2340
0002aa  4308              ORRS     r0,r0,r1              ;2340
0002ac  4918              LDR      r1,|L36.784|
0002ae  4288              CMP      r0,r1                 ;2340
0002b0  d11f              BNE      |L36.754|
0002b2  f8940218          LDRB     r0,[r4,#0x218]        ;2343
0002b6  f894121b          LDRB     r1,[r4,#0x21b]        ;2343
0002ba  f8942219          LDRB     r2,[r4,#0x219]        ;2343
0002be  ea406001          ORR      r0,r0,r1,LSL #24      ;2343
0002c2  f894121a          LDRB     r1,[r4,#0x21a]        ;2343
0002c6  0409              LSLS     r1,r1,#16             ;2343
0002c8  ea412102          ORR      r1,r1,r2,LSL #8       ;2343
0002cc  4308              ORRS     r0,r0,r1              ;2343
0002ce  6120              STR      r0,[r4,#0x10]         ;2343
0002d0  f894021c          LDRB     r0,[r4,#0x21c]        ;2346
0002d4  e000              B        |L36.728|
                  |L36.726|
0002d6  e00c              B        |L36.754|
                  |L36.728|
0002d8  f894121f          LDRB     r1,[r4,#0x21f]        ;2346
0002dc  f894221d          LDRB     r2,[r4,#0x21d]        ;2346
0002e0  ea406001          ORR      r0,r0,r1,LSL #24      ;2346
0002e4  f894121e          LDRB     r1,[r4,#0x21e]        ;2346
0002e8  0409              LSLS     r1,r1,#16             ;2346
0002ea  ea412102          ORR      r1,r1,r2,LSL #8       ;2346
0002ee  4308              ORRS     r0,r0,r1              ;2346
0002f0  60e0              STR      r0,[r4,#0xc]          ;2346
                  |L36.754|
0002f2  7026              STRB     r6,[r4,#0]            ;2352
0002f4  4907              LDR      r1,|L36.788|
0002f6  8808              LDRH     r0,[r1,#0]            ;2353  ; Fsid
0002f8  1c40              ADDS     r0,r0,#1              ;2353
0002fa  8008              STRH     r0,[r1,#0]            ;2353
0002fc  80e0              STRH     r0,[r4,#6]            ;2353
0002fe  4620              MOV      r0,r4                 ;2358
000300  f7fffffe          BL       clear_lock
000304  2000              MOVS     r0,#0                 ;2361
000306  e689              B        |L36.28|
;;;2363   
                          ENDP

                  |L36.776|
                          DCD      ||.bss||
                  |L36.780|
                          DCD      0x41615252
                  |L36.784|
                          DCD      0x61417272
                  |L36.788|
                          DCD      ||.data||

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;2051   static
;;;2052   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;2053   	DIR* dp,			/* Directory object to return last directory and found object */
;;;2054   	const TCHAR* path	/* Full-path string to find a file or directory */
;;;2055   )
;;;2056   {
000002  4604              MOV      r4,r0
;;;2057   	FRESULT res;
;;;2058   	BYTE *dir, ns;
;;;2059   
;;;2060   
;;;2061   #if _FS_RPATH
;;;2062   	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
;;;2063   		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
;;;2064   	} else {								/* No heading separator */
;;;2065   		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
;;;2066   	}
;;;2067   #else
;;;2068   	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
000004  9901              LDR      r1,[sp,#4]
000006  7808              LDRB     r0,[r1,#0]
000008  282f              CMP      r0,#0x2f
00000a  d001              BEQ      |L37.16|
00000c  285c              CMP      r0,#0x5c
00000e  d101              BNE      |L37.20|
                  |L37.16|
;;;2069   		path++;
000010  1c49              ADDS     r1,r1,#1
000012  9101              STR      r1,[sp,#4]
                  |L37.20|
;;;2070   	dp->sclust = 0;							/* Always start from the root directory */
000014  2500              MOVS     r5,#0
000016  60a5              STR      r5,[r4,#8]
;;;2071   #endif
;;;2072   
;;;2073   	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
000018  9801              LDR      r0,[sp,#4]
00001a  7800              LDRB     r0,[r0,#0]
00001c  2820              CMP      r0,#0x20
00001e  d205              BCS      |L37.44|
;;;2074   		res = dir_sdi(dp, 0);
000020  2100              MOVS     r1,#0
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       dir_sdi
;;;2075   		dp->dir = 0;
000028  6165              STR      r5,[r4,#0x14]
                  |L37.42|
;;;2076   	} else {								/* Follow path */
;;;2077   		for (;;) {
;;;2078   			res = create_name(dp, &path);	/* Get a segment name of the path */
;;;2079   			if (res != FR_OK) break;
;;;2080   			res = dir_find(dp);				/* Find an object with the sagment name */
;;;2081   			ns = dp->fn[NSFLAG];
;;;2082   			if (res != FR_OK) {				/* Failed to find the object */
;;;2083   				if (res == FR_NO_FILE) {	/* Object is not found */
;;;2084   					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
;;;2085   						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
;;;2086   						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
;;;2087   						res = FR_OK;					/* Ended at the root directroy. Function completed. */
;;;2088   					} else {							/* Could not find the object */
;;;2089   						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
;;;2090   					}
;;;2091   				}
;;;2092   				break;
;;;2093   			}
;;;2094   			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
;;;2095   			dir = dp->dir;						/* Follow the sub-directory */
;;;2096   			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
;;;2097   				res = FR_NO_PATH; break;
;;;2098   			}
;;;2099   			dp->sclust = ld_clust(dp->fs, dir);
;;;2100   		}
;;;2101   	}
;;;2102   
;;;2103   	return res;
;;;2104   }
00002a  bd7c              POP      {r2-r6,pc}
                  |L37.44|
00002c  a901              ADD      r1,sp,#4              ;2078
00002e  4620              MOV      r0,r4                 ;2078
000030  f7fffffe          BL       create_name
000034  2800              CMP      r0,#0                 ;2079
000036  d1f8              BNE      |L37.42|
000038  4620              MOV      r0,r4                 ;2080
00003a  f7fffffe          BL       dir_find
00003e  69a1              LDR      r1,[r4,#0x18]         ;2081
000040  7ac9              LDRB     r1,[r1,#0xb]          ;2081
000042  b128              CBZ      r0,|L37.80|
000044  2804              CMP      r0,#4                 ;2083
000046  d1f0              BNE      |L37.42|
000048  0749              LSLS     r1,r1,#29             ;2089
00004a  d4ee              BMI      |L37.42|
00004c  2005              MOVS     r0,#5                 ;2089
                  |L37.78|
00004e  bd7c              POP      {r2-r6,pc}
                  |L37.80|
000050  0749              LSLS     r1,r1,#29             ;2094
000052  d4fc              BMI      |L37.78|
000054  6961              LDR      r1,[r4,#0x14]         ;2095
000056  7ac8              LDRB     r0,[r1,#0xb]          ;2096
000058  06c0              LSLS     r0,r0,#27             ;2096
00005a  d401              BMI      |L37.96|
00005c  2005              MOVS     r0,#5                 ;2097
00005e  bd7c              POP      {r2-r6,pc}
                  |L37.96|
000060  6820              LDR      r0,[r4,#0]            ;2099
000062  f7fffffe          BL       ld_clust
000066  60a0              STR      r0,[r4,#8]            ;2099
000068  e7e0              B        |L37.44|
;;;2105   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;817    
;;;818    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;819    	FATFS* fs,	/* File system object */
;;;820    	DWORD clst	/* FAT index number (cluster number) to get the value */
;;;821    )
;;;822    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;823    	UINT wc, bc;
;;;824    	BYTE *p;
;;;825    	DWORD val;
;;;826    
;;;827    
;;;828    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
000008  2d02              CMP      r5,#2
00000a  d302              BCC      |L38.18|
00000c  6960              LDR      r0,[r4,#0x14]
00000e  42a8              CMP      r0,r5
000010  d801              BHI      |L38.22|
                  |L38.18|
;;;829    		val = 1;	/* Internal error */
000012  2601              MOVS     r6,#1
000014  e009              B        |L38.42|
                  |L38.22|
;;;830    
;;;831    	} else {
;;;832    		val = 0xFFFFFFFF;	/* Default value falls on disk error */
000016  f04f36ff          MOV      r6,#0xffffffff
;;;833    
;;;834    		switch (fs->fs_type) {
00001a  7820              LDRB     r0,[r4,#0]
00001c  2801              CMP      r0,#1
00001e  d007              BEQ      |L38.48|
000020  2802              CMP      r0,#2
000022  d02c              BEQ      |L38.126|
000024  2803              CMP      r0,#3
000026  d03b              BEQ      |L38.160|
;;;835    		case FS_FAT12 :
;;;836    			bc = (UINT)clst; bc += bc / 2;
;;;837    			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
;;;838    			wc = fs->win[bc++ % SS(fs)];
;;;839    			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
;;;840    			wc |= fs->win[bc % SS(fs)] << 8;
;;;841    			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
;;;842    			break;
;;;843    
;;;844    		case FS_FAT16 :
;;;845    			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
;;;846    			p = &fs->win[clst * 2 % SS(fs)];
;;;847    			val = LD_WORD(p);
;;;848    			break;
;;;849    
;;;850    		case FS_FAT32 :
;;;851    			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
;;;852    			p = &fs->win[clst * 4 % SS(fs)];
;;;853    			val = LD_DWORD(p) & 0x0FFFFFFF;
;;;854    			break;
;;;855    
;;;856    		default:
;;;857    			val = 1;	/* Internal error */
000028  2601              MOVS     r6,#1
                  |L38.42|
;;;858    		}
;;;859    	}
;;;860    
;;;861    	return val;
00002a  4630              MOV      r0,r6
;;;862    }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L38.48|
000030  eb050755          ADD      r7,r5,r5,LSR #1       ;836
000034  6a20              LDR      r0,[r4,#0x20]         ;837
000036  eb002157          ADD      r1,r0,r7,LSR #9       ;837
00003a  4620              MOV      r0,r4                 ;837
00003c  f7fffffe          BL       move_window
000040  2800              CMP      r0,#0                 ;837
000042  d1f2              BNE      |L38.42|
000044  f3c70008          UBFX     r0,r7,#0,#9           ;838
000048  4420              ADD      r0,r0,r4              ;838
00004a  f1070801          ADD      r8,r7,#1              ;838
00004e  f8909030          LDRB     r9,[r0,#0x30]         ;838
000052  6a20              LDR      r0,[r4,#0x20]         ;839
000054  eb002158          ADD      r1,r0,r8,LSR #9       ;839
000058  4620              MOV      r0,r4                 ;839
00005a  f7fffffe          BL       move_window
00005e  2800              CMP      r0,#0                 ;839
000060  d1e3              BNE      |L38.42|
000062  f3c80008          UBFX     r0,r8,#0,#9           ;840
000066  4420              ADD      r0,r0,r4              ;840
000068  f8900030          LDRB     r0,[r0,#0x30]         ;840
00006c  ea492000          ORR      r0,r9,r0,LSL #8       ;840
000070  07e9              LSLS     r1,r5,#31             ;841
000072  d001              BEQ      |L38.120|
000074  0906              LSRS     r6,r0,#4              ;841
000076  e7d8              B        |L38.42|
                  |L38.120|
000078  f3c0060b          UBFX     r6,r0,#0,#12          ;841
00007c  e7d5              B        |L38.42|
                  |L38.126|
00007e  6a20              LDR      r0,[r4,#0x20]         ;845
000080  eb002115          ADD      r1,r0,r5,LSR #8       ;845
000084  4620              MOV      r0,r4                 ;845
000086  f7fffffe          BL       move_window
00008a  2800              CMP      r0,#0                 ;845
00008c  d1cd              BNE      |L38.42|
00008e  b2e8              UXTB     r0,r5                 ;846
000090  eb040040          ADD      r0,r4,r0,LSL #1       ;846
000094  3030              ADDS     r0,r0,#0x30           ;846
000096  7801              LDRB     r1,[r0,#0]            ;847
000098  7840              LDRB     r0,[r0,#1]            ;847
00009a  ea412600          ORR      r6,r1,r0,LSL #8       ;847
00009e  e7c4              B        |L38.42|
                  |L38.160|
0000a0  6a20              LDR      r0,[r4,#0x20]         ;851
0000a2  eb0011d5          ADD      r1,r0,r5,LSR #7       ;851
0000a6  4620              MOV      r0,r4                 ;851
0000a8  f7fffffe          BL       move_window
0000ac  2800              CMP      r0,#0                 ;851
0000ae  d1bc              BNE      |L38.42|
0000b0  f24010ff          MOV      r0,#0x1ff             ;852
0000b4  ea000085          AND      r0,r0,r5,LSL #2       ;852
0000b8  4420              ADD      r0,r0,r4              ;852
0000ba  3030              ADDS     r0,r0,#0x30           ;852
0000bc  7801              LDRB     r1,[r0,#0]            ;853
0000be  78c2              LDRB     r2,[r0,#3]            ;853
0000c0  ea416102          ORR      r1,r1,r2,LSL #24      ;853
0000c4  7882              LDRB     r2,[r0,#2]            ;853
0000c6  7840              LDRB     r0,[r0,#1]            ;853
0000c8  0412              LSLS     r2,r2,#16             ;853
0000ca  ea422000          ORR      r0,r2,r0,LSL #8       ;853
0000ce  4301              ORRS     r1,r1,r0              ;853
0000d0  f0214670          BIC      r6,r1,#0xf0000000     ;853
0000d4  e7a9              B        |L38.42|
;;;863    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1702   static
;;;1703   void get_fileinfo (		/* No return code */
000000  b530              PUSH     {r4,r5,lr}
;;;1704   	DIR* dp,			/* Pointer to the directory object */
;;;1705   	FILINFO* fno	 	/* Pointer to the file information to be filled */
;;;1706   )
;;;1707   {
;;;1708   	UINT i;
;;;1709   	TCHAR *p, c;
;;;1710   	BYTE *dir;
;;;1711   #if _USE_LFN
;;;1712   	WCHAR w, *lfn;
;;;1713   #endif
;;;1714   
;;;1715   	p = fno->fname;
000002  f1010209          ADD      r2,r1,#9
;;;1716   	if (dp->sect) {		/* Get SFN */
000006  6903              LDR      r3,[r0,#0x10]
000008  2b00              CMP      r3,#0
00000a  d029              BEQ      |L39.96|
;;;1717   		dir = dp->dir;
00000c  6940              LDR      r0,[r0,#0x14]
;;;1718   		i = 0;
00000e  2300              MOVS     r3,#0
;;;1719   		while (i < 11) {		/* Copy name body and extension */
;;;1720   			c = (TCHAR)dir[i++];
;;;1721   			if (c == ' ') continue;				/* Skip padding spaces */
;;;1722   			if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
;;;1723   			if (i == 9) *p++ = '.';				/* Insert a . if extension is exist */
000010  252e              MOVS     r5,#0x2e
                  |L39.18|
000012  461c              MOV      r4,r3                 ;1720
000014  1c5b              ADDS     r3,r3,#1              ;1720
000016  5d04              LDRB     r4,[r0,r4]            ;1720
000018  2c20              CMP      r4,#0x20              ;1721
00001a  d008              BEQ      |L39.46|
00001c  2c05              CMP      r4,#5                 ;1722
00001e  d100              BNE      |L39.34|
000020  24e5              MOVS     r4,#0xe5              ;1722
                  |L39.34|
000022  2b09              CMP      r3,#9
000024  d101              BNE      |L39.42|
000026  f8025b01          STRB     r5,[r2],#1
                  |L39.42|
;;;1724   #if _USE_LFN
;;;1725   			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
;;;1726   				c += 0x20;			/* To lower */
;;;1727   #if _LFN_UNICODE
;;;1728   			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
;;;1729   				c = c << 8 | dir[i++];
;;;1730   			c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;1731   			if (!c) c = '?';
;;;1732   #endif
;;;1733   #endif
;;;1734   			*p++ = c;
00002a  f8024b01          STRB     r4,[r2],#1
                  |L39.46|
00002e  2b0b              CMP      r3,#0xb               ;1719
000030  d3ef              BCC      |L39.18|
;;;1735   		}
;;;1736   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
000032  7ac3              LDRB     r3,[r0,#0xb]
000034  720b              STRB     r3,[r1,#8]
;;;1737   		fno->fsize = LD_DWORD(dir + DIR_FileSize);	/* Size */
000036  7f03              LDRB     r3,[r0,#0x1c]
000038  7fc4              LDRB     r4,[r0,#0x1f]
00003a  7f45              LDRB     r5,[r0,#0x1d]
00003c  ea436304          ORR      r3,r3,r4,LSL #24
000040  7f84              LDRB     r4,[r0,#0x1e]
000042  0424              LSLS     r4,r4,#16
000044  ea442405          ORR      r4,r4,r5,LSL #8
000048  4323              ORRS     r3,r3,r4
00004a  600b              STR      r3,[r1,#0]
;;;1738   		fno->fdate = LD_WORD(dir + DIR_WrtDate);	/* Date */
00004c  7e03              LDRB     r3,[r0,#0x18]
00004e  7e44              LDRB     r4,[r0,#0x19]
000050  ea432304          ORR      r3,r3,r4,LSL #8
000054  808b              STRH     r3,[r1,#4]
;;;1739   		fno->ftime = LD_WORD(dir + DIR_WrtTime);	/* Time */
000056  7d83              LDRB     r3,[r0,#0x16]
000058  7dc0              LDRB     r0,[r0,#0x17]
00005a  ea432000          ORR      r0,r3,r0,LSL #8
00005e  80c8              STRH     r0,[r1,#6]
                  |L39.96|
;;;1740   	}
;;;1741   	*p = 0;		/* Terminate SFN string by a \0 */
000060  2000              MOVS     r0,#0
000062  7010              STRB     r0,[r2,#0]
;;;1742   
;;;1743   #if _USE_LFN
;;;1744   	if (fno->lfname) {
;;;1745   		i = 0; p = fno->lfname;
;;;1746   		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
;;;1747   			lfn = dp->lfn;
;;;1748   			while ((w = *lfn++) != 0) {		/* Get an LFN character */
;;;1749   #if !_LFN_UNICODE
;;;1750   				w = ff_convert(w, 0);		/* Unicode -> OEM */
;;;1751   				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
;;;1752   				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
;;;1753   					p[i++] = (TCHAR)(w >> 8);
;;;1754   #endif
;;;1755   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
;;;1756   				p[i++] = (TCHAR)w;
;;;1757   			}
;;;1758   		}
;;;1759   		p[i] = 0;	/* Terminate LFN string by a \0 */
;;;1760   	}
;;;1761   #endif
;;;1762   }
000064  bd30              POP      {r4,r5,pc}
;;;1763   #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
                          ENDP


                          AREA ||i.get_ldnumber||, CODE, READONLY, ALIGN=1

                  get_ldnumber PROC
;;;2113   static
;;;2114   int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
000000  b510              PUSH     {r4,lr}
;;;2115   	const TCHAR** path	/* Pointer to pointer to the path name */
;;;2116   )
;;;2117   {
000002  4604              MOV      r4,r0
;;;2118   	const TCHAR *tp, *tt;
;;;2119   	UINT i;
;;;2120   	int vol = -1;
000004  f04f30ff          MOV      r0,#0xffffffff
;;;2121   #if _STR_VOLUME_ID		/* Find string drive id */
;;;2122   	static const char* const str[] = {_VOLUME_STRS};
;;;2123   	const char *sp;
;;;2124   	char c;
;;;2125   	TCHAR tc;
;;;2126   #endif
;;;2127   
;;;2128   
;;;2129   	if (*path) {	/* If the pointer is not a null */
000008  6823              LDR      r3,[r4,#0]
00000a  2b00              CMP      r3,#0
00000c  d00b              BEQ      |L40.38|
;;;2130   		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
00000e  4619              MOV      r1,r3
000010  e000              B        |L40.20|
                  |L40.18|
000012  1c49              ADDS     r1,r1,#1
                  |L40.20|
000014  780a              LDRB     r2,[r1,#0]
000016  2a21              CMP      r2,#0x21
000018  d301              BCC      |L40.30|
00001a  2a3a              CMP      r2,#0x3a
00001c  d1f9              BNE      |L40.18|
                  |L40.30|
;;;2131   		if (*tt == ':') {	/* If a ':' is exist in the path name */
00001e  780a              LDRB     r2,[r1,#0]
000020  2a3a              CMP      r2,#0x3a
000022  d001              BEQ      |L40.40|
;;;2132   			tp = *path;
;;;2133   			i = *tp++ - '0'; 
;;;2134   			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
;;;2135   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2136   					vol = (int)i;
;;;2137   					*path = ++tt;
;;;2138   				}
;;;2139   			}
;;;2140   #if _STR_VOLUME_ID
;;;2141   			 else {	/* No numeric drive number, find string drive id */
;;;2142   				i = 0; tt++;
;;;2143   				do {
;;;2144   					sp = str[i]; tp = *path;
;;;2145   					do {	/* Compare a string drive id with path name */
;;;2146   						c = *sp++; tc = *tp++;
;;;2147   						if (IsLower(tc)) tc -= 0x20;
;;;2148   					} while (c && (TCHAR)c == tc);
;;;2149   				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
;;;2150   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2151   					vol = (int)i;
;;;2152   					*path = tt;
;;;2153   				}
;;;2154   			}
;;;2155   #endif
;;;2156   			return vol;
;;;2157   		}
;;;2158   #if _FS_RPATH && _VOLUMES >= 2
;;;2159   		vol = CurrVol;	/* Current drive */
;;;2160   #else
;;;2161   		vol = 0;		/* Drive 0 */
000024  2000              MOVS     r0,#0
                  |L40.38|
;;;2162   #endif
;;;2163   	}
;;;2164   	return vol;
;;;2165   }
000026  bd10              POP      {r4,pc}
                  |L40.40|
000028  f8132b01          LDRB     r2,[r3],#1            ;2133
00002c  3a30              SUBS     r2,r2,#0x30           ;2133
00002e  2a0a              CMP      r2,#0xa               ;2134
000030  d2f9              BCS      |L40.38|
000032  428b              CMP      r3,r1                 ;2134
000034  d1f7              BNE      |L40.38|
000036  2a03              CMP      r2,#3                 ;2135
000038  d2f5              BCS      |L40.38|
00003a  4610              MOV      r0,r2                 ;2136
00003c  1c49              ADDS     r1,r1,#1              ;2137
00003e  6021              STR      r1,[r4,#0]            ;2137
000040  bd10              POP      {r4,pc}
;;;2166   
                          ENDP


                          AREA ||i.inc_lock||, CODE, READONLY, ALIGN=2

                  inc_lock PROC
;;;624    static
;;;625    UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
000000  b5f0              PUSH     {r4-r7,lr}
;;;626    	DIR* dp,	/* Directory object pointing the file to register or increment */
;;;627    	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
;;;628    )
;;;629    {
000002  4602              MOV      r2,r0
;;;630    	UINT i;
;;;631    
;;;632    
;;;633    	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
000004  2000              MOVS     r0,#0
;;;634    		if (Files[i].fs == dp->fs &&
000006  4c26              LDR      r4,|L41.160|
000008  6815              LDR      r5,[r2,#0]
                  |L41.10|
00000a  eb000340          ADD      r3,r0,r0,LSL #1
00000e  f8546023          LDR      r6,[r4,r3,LSL #2]
000012  42ae              CMP      r6,r5
000014  d109              BNE      |L41.42|
;;;635    			Files[i].clu == dp->sclust &&
000016  eb040383          ADD      r3,r4,r3,LSL #2
00001a  6897              LDR      r7,[r2,#8]
00001c  685e              LDR      r6,[r3,#4]
00001e  42be              CMP      r6,r7
000020  d103              BNE      |L41.42|
;;;636    			Files[i].idx == dp->index) break;
000022  891b              LDRH     r3,[r3,#8]
000024  88d6              LDRH     r6,[r2,#6]
000026  42b3              CMP      r3,r6
000028  d002              BEQ      |L41.48|
                  |L41.42|
00002a  1c40              ADDS     r0,r0,#1              ;633
00002c  2803              CMP      r0,#3                 ;633
00002e  d3ec              BCC      |L41.10|
                  |L41.48|
;;;637    	}
;;;638    
;;;639    	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
000030  2803              CMP      r0,#3
000032  d118              BNE      |L41.102|
;;;640    		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
000034  2000              MOVS     r0,#0
000036  e000              B        |L41.58|
                  |L41.56|
000038  1c40              ADDS     r0,r0,#1
                  |L41.58|
00003a  2803              CMP      r0,#3
00003c  d205              BCS      |L41.74|
00003e  eb000340          ADD      r3,r0,r0,LSL #1
000042  f8543023          LDR      r3,[r4,r3,LSL #2]
000046  2b00              CMP      r3,#0
000048  d1f6              BNE      |L41.56|
                  |L41.74|
;;;641    		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
00004a  2803              CMP      r0,#3
00004c  d014              BEQ      |L41.120|
;;;642    		Files[i].fs = dp->fs;
00004e  eb000340          ADD      r3,r0,r0,LSL #1
000052  f8445023          STR      r5,[r4,r3,LSL #2]
;;;643    		Files[i].clu = dp->sclust;
000056  eb040383          ADD      r3,r4,r3,LSL #2
00005a  6895              LDR      r5,[r2,#8]
00005c  605d              STR      r5,[r3,#4]
;;;644    		Files[i].idx = dp->index;
00005e  88d2              LDRH     r2,[r2,#6]
000060  811a              STRH     r2,[r3,#8]
;;;645    		Files[i].ctr = 0;
000062  2200              MOVS     r2,#0
000064  815a              STRH     r2,[r3,#0xa]
                  |L41.102|
;;;646    	}
;;;647    
;;;648    	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
000066  b149              CBZ      r1,|L41.124|
000068  eb000240          ADD      r2,r0,r0,LSL #1
00006c  eb040282          ADD      r2,r4,r2,LSL #2
000070  8952              LDRH     r2,[r2,#0xa]
000072  b11a              CBZ      r2,|L41.124|
000074  2000              MOVS     r0,#0
;;;649    
;;;650    	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
;;;651    
;;;652    	return i + 1;
;;;653    }
000076  bdf0              POP      {r4-r7,pc}
                  |L41.120|
000078  2000              MOVS     r0,#0                 ;641
00007a  bdf0              POP      {r4-r7,pc}
                  |L41.124|
00007c  b111              CBZ      r1,|L41.132|
00007e  f44f7180          MOV      r1,#0x100             ;650
000082  e005              B        |L41.144|
                  |L41.132|
000084  eb000140          ADD      r1,r0,r0,LSL #1       ;650
000088  eb040181          ADD      r1,r4,r1,LSL #2       ;650
00008c  8949              LDRH     r1,[r1,#0xa]          ;650
00008e  1c49              ADDS     r1,r1,#1              ;650
                  |L41.144|
000090  eb000240          ADD      r2,r0,r0,LSL #1       ;650
000094  eb040282          ADD      r2,r4,r2,LSL #2       ;650
000098  8151              STRH     r1,[r2,#0xa]          ;650
00009a  1c40              ADDS     r0,r0,#1              ;652
00009c  bdf0              POP      {r4-r7,pc}
;;;654    
                          ENDP

00009e  0000              DCW      0x0000
                  |L41.160|
                          DCD      ||.bss||+0xc

                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;1234   static
;;;1235   DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
000000  4602              MOV      r2,r0
;;;1236   	FATFS* fs,		/* Pointer to the fs object */
;;;1237   	const BYTE* dir	/* Pointer to the SFN entry */
;;;1238   )
;;;1239   {
;;;1240   	DWORD cl;
;;;1241   
;;;1242   	cl = LD_WORD(dir + DIR_FstClusLO);
000002  7e88              LDRB     r0,[r1,#0x1a]
000004  7ecb              LDRB     r3,[r1,#0x1b]
000006  ea402003          ORR      r0,r0,r3,LSL #8
;;;1243   	if (fs->fs_type == FS_FAT32)
00000a  7812              LDRB     r2,[r2,#0]
00000c  2a03              CMP      r2,#3
00000e  d105              BNE      |L42.28|
;;;1244   		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
000010  7d0a              LDRB     r2,[r1,#0x14]
000012  7d49              LDRB     r1,[r1,#0x15]
000014  ea422101          ORR      r1,r2,r1,LSL #8
000018  ea404001          ORR      r0,r0,r1,LSL #16
                  |L42.28|
;;;1245   
;;;1246   	return cl;
;;;1247   }
00001c  4770              BX       lr
;;;1248   
                          ENDP


                          AREA ||i.mem_cmp||, CODE, READONLY, ALIGN=1

                  mem_cmp PROC
;;;532    static
;;;533    int mem_cmp (const void* dst, const void* src, UINT cnt) {
000000  b510              PUSH     {r4,lr}
;;;534    	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
;;;535    	int r = 0;
000002  2300              MOVS     r3,#0
                  |L43.4|
;;;536    
;;;537    	while (cnt-- && (r = *d++ - *s++) == 0) ;
000004  1e52              SUBS     r2,r2,#1
000006  1c54              ADDS     r4,r2,#1
000008  d005              BEQ      |L43.22|
00000a  f8103b01          LDRB     r3,[r0],#1
00000e  f8114b01          LDRB     r4,[r1],#1
000012  1b1b              SUBS     r3,r3,r4
000014  d0f6              BEQ      |L43.4|
                  |L43.22|
;;;538    	return r;
000016  4618              MOV      r0,r3
;;;539    }
000018  bd10              POP      {r4,pc}
;;;540    
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;506    static
;;;507    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  e003              B        |L44.10|
                  |L44.2|
;;;508    	BYTE *d = (BYTE*)dst;
;;;509    	const BYTE *s = (const BYTE*)src;
;;;510    
;;;511    #if _WORD_ACCESS == 1
;;;512    	while (cnt >= sizeof (int)) {
;;;513    		*(int*)d = *(int*)s;
;;;514    		d += sizeof (int); s += sizeof (int);
;;;515    		cnt -= sizeof (int);
;;;516    	}
;;;517    #endif
;;;518    	while (cnt--)
;;;519    		*d++ = *s++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
                  |L44.10|
00000a  1e52              SUBS     r2,r2,#1              ;518
00000c  1c53              ADDS     r3,r2,#1              ;518
00000e  d1f8              BNE      |L44.2|
;;;520    }
000010  4770              BX       lr
;;;521    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;523    static
;;;524    void mem_set (void* dst, int val, UINT cnt) {
000000  b2c9              UXTB     r1,r1
000002  e001              B        |L45.8|
                  |L45.4|
;;;525    	BYTE *d = (BYTE*)dst;
;;;526    
;;;527    	while (cnt--)
;;;528    		*d++ = (BYTE)val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L45.8|
000008  1e52              SUBS     r2,r2,#1              ;527
00000a  1c53              ADDS     r3,r2,#1              ;527
00000c  d1fa              BNE      |L45.4|
;;;529    }
00000e  4770              BX       lr
;;;530    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;728    static
;;;729    FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;730    	FATFS* fs,		/* File system object */
;;;731    	DWORD sector	/* Sector number to make appearance in the fs->win[] */
;;;732    )
;;;733    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;734    	FRESULT res = FR_OK;
000006  2500              MOVS     r5,#0
;;;735    
;;;736    
;;;737    	if (sector != fs->winsect) {	/* Window offset changed? */
000008  6ae0              LDR      r0,[r4,#0x2c]
00000a  42b0              CMP      r0,r6
00000c  d010              BEQ      |L46.48|
;;;738    #if !_FS_READONLY
;;;739    		res = sync_window(fs);		/* Write-back changes */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sync_window
000014  4605              MOV      r5,r0
;;;740    #endif
;;;741    		if (res == FR_OK) {			/* Fill sector window with new data */
000016  b95d              CBNZ     r5,|L46.48|
;;;742    			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
000018  7860              LDRB     r0,[r4,#1]
00001a  2301              MOVS     r3,#1
00001c  4632              MOV      r2,r6
00001e  f1040130          ADD      r1,r4,#0x30
000022  f7fffffe          BL       disk_read
000026  b110              CBZ      r0,|L46.46|
;;;743    				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
000028  f04f36ff          MOV      r6,#0xffffffff
;;;744    				res = FR_DISK_ERR;
00002c  2501              MOVS     r5,#1
                  |L46.46|
;;;745    			}
;;;746    			fs->winsect = sector;
00002e  62e6              STR      r6,[r4,#0x2c]
                  |L46.48|
;;;747    		}
;;;748    	}
;;;749    	return res;
000030  4628              MOV      r0,r5
;;;750    }
000032  bd70              POP      {r4-r6,pc}
;;;751    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;872    #if !_FS_READONLY
;;;873    FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;874    	FATFS* fs,		/* File system object */
;;;875    	DWORD clst,		/* FAT index number (cluster number) to be changed */
;;;876    	DWORD val		/* New value to be set to the entry */
;;;877    )
;;;878    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;879    	UINT bc;
;;;880    	BYTE *p;
;;;881    	FRESULT res;
;;;882    
;;;883    
;;;884    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
00000a  2d02              CMP      r5,#2
00000c  d302              BCC      |L47.20|
00000e  6960              LDR      r0,[r4,#0x14]
000010  42a8              CMP      r0,r5
000012  d802              BHI      |L47.26|
                  |L47.20|
;;;885    		res = FR_INT_ERR;
000014  2002              MOVS     r0,#2
                  |L47.22|
;;;886    
;;;887    	} else {
;;;888    		switch (fs->fs_type) {
;;;889    		case FS_FAT12 :
;;;890    			bc = (UINT)clst; bc += bc / 2;
;;;891    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;892    			if (res != FR_OK) break;
;;;893    			p = &fs->win[bc++ % SS(fs)];
;;;894    			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;;;895    			fs->wflag = 1;
;;;896    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;897    			if (res != FR_OK) break;
;;;898    			p = &fs->win[bc % SS(fs)];
;;;899    			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;;;900    			fs->wflag = 1;
;;;901    			break;
;;;902    
;;;903    		case FS_FAT16 :
;;;904    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
;;;905    			if (res != FR_OK) break;
;;;906    			p = &fs->win[clst * 2 % SS(fs)];
;;;907    			ST_WORD(p, (WORD)val);
;;;908    			fs->wflag = 1;
;;;909    			break;
;;;910    
;;;911    		case FS_FAT32 :
;;;912    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
;;;913    			if (res != FR_OK) break;
;;;914    			p = &fs->win[clst * 4 % SS(fs)];
;;;915    			val |= LD_DWORD(p) & 0xF0000000;
;;;916    			ST_DWORD(p, val);
;;;917    			fs->wflag = 1;
;;;918    			break;
;;;919    
;;;920    		default :
;;;921    			res = FR_INT_ERR;
;;;922    		}
;;;923    	}
;;;924    
;;;925    	return res;
;;;926    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L47.26|
00001a  7820              LDRB     r0,[r4,#0]            ;888
00001c  f00609ff          AND      r9,r6,#0xff           ;894
000020  f04f0801          MOV      r8,#1                 ;888
000024  2801              CMP      r0,#1                 ;888
000026  d005              BEQ      |L47.52|
000028  2802              CMP      r0,#2                 ;888
00002a  d038              BEQ      |L47.158|
00002c  2803              CMP      r0,#3                 ;888
00002e  d049              BEQ      |L47.196|
000030  2002              MOVS     r0,#2                 ;921
000032  e7f0              B        |L47.22|
                  |L47.52|
000034  eb050755          ADD      r7,r5,r5,LSR #1       ;890
000038  6a20              LDR      r0,[r4,#0x20]         ;891
00003a  eb002157          ADD      r1,r0,r7,LSR #9       ;891
00003e  4620              MOV      r0,r4                 ;891
000040  f7fffffe          BL       move_window
000044  2800              CMP      r0,#0                 ;892
000046  d1e6              BNE      |L47.22|
000048  f3c70008          UBFX     r0,r7,#0,#9           ;893
00004c  4420              ADD      r0,r0,r4              ;893
00004e  f1070a01          ADD      r10,r7,#1             ;893
000052  3030              ADDS     r0,r0,#0x30           ;893
000054  07e9              LSLS     r1,r5,#31             ;894
000056  d003              BEQ      |L47.96|
000058  7801              LDRB     r1,[r0,#0]            ;894
00005a  f369111f          BFI      r1,r9,#4,#28          ;894
00005e  e000              B        |L47.98|
                  |L47.96|
000060  4631              MOV      r1,r6                 ;894
                  |L47.98|
000062  7001              STRB     r1,[r0,#0]            ;894
000064  f8848004          STRB     r8,[r4,#4]            ;895
000068  6a20              LDR      r0,[r4,#0x20]         ;896
00006a  eb00215a          ADD      r1,r0,r10,LSR #9      ;896
00006e  4620              MOV      r0,r4                 ;896
000070  f7fffffe          BL       move_window
000074  2800              CMP      r0,#0                 ;897
000076  d1ce              BNE      |L47.22|
000078  f3ca0108          UBFX     r1,r10,#0,#9          ;898
00007c  4421              ADD      r1,r1,r4              ;898
00007e  3130              ADDS     r1,r1,#0x30           ;898
000080  07ea              LSLS     r2,r5,#31             ;899
000082  d002              BEQ      |L47.138|
000084  f3c61207          UBFX     r2,r6,#4,#8           ;899
000088  e005              B        |L47.150|
                  |L47.138|
00008a  780a              LDRB     r2,[r1,#0]            ;899
00008c  f3c62303          UBFX     r3,r6,#8,#4           ;899
000090  f00202f0          AND      r2,r2,#0xf0           ;899
000094  431a              ORRS     r2,r2,r3              ;899
                  |L47.150|
000096  700a              STRB     r2,[r1,#0]            ;899
000098  f8848004          STRB     r8,[r4,#4]            ;900
00009c  e7bb              B        |L47.22|
                  |L47.158|
00009e  6a20              LDR      r0,[r4,#0x20]         ;904
0000a0  eb002115          ADD      r1,r0,r5,LSR #8       ;904
0000a4  4620              MOV      r0,r4                 ;904
0000a6  f7fffffe          BL       move_window
0000aa  2800              CMP      r0,#0                 ;905
0000ac  d1b3              BNE      |L47.22|
0000ae  b2e9              UXTB     r1,r5                 ;906
0000b0  eb040141          ADD      r1,r4,r1,LSL #1       ;906
0000b4  f8819030          STRB     r9,[r1,#0x30]         ;907
0000b8  0a32              LSRS     r2,r6,#8              ;907
0000ba  f8812031          STRB     r2,[r1,#0x31]         ;907
0000be  f8848004          STRB     r8,[r4,#4]            ;908
0000c2  e7a8              B        |L47.22|
                  |L47.196|
0000c4  6a20              LDR      r0,[r4,#0x20]         ;912
0000c6  eb0011d5          ADD      r1,r0,r5,LSR #7       ;912
0000ca  4620              MOV      r0,r4                 ;912
0000cc  f7fffffe          BL       move_window
0000d0  2800              CMP      r0,#0                 ;913
0000d2  d1a0              BNE      |L47.22|
0000d4  f24011ff          MOV      r1,#0x1ff             ;914
0000d8  ea010185          AND      r1,r1,r5,LSL #2       ;914
0000dc  4421              ADD      r1,r1,r4              ;914
0000de  3130              ADDS     r1,r1,#0x30           ;914
0000e0  f04f4370          MOV      r3,#0xf0000000        ;915
0000e4  78ca              LDRB     r2,[r1,#3]            ;915
0000e6  ea036202          AND      r2,r3,r2,LSL #24      ;915
0000ea  4332              ORRS     r2,r2,r6              ;915
0000ec  700a              STRB     r2,[r1,#0]            ;916
0000ee  0a13              LSRS     r3,r2,#8              ;916
0000f0  704b              STRB     r3,[r1,#1]            ;916
0000f2  0c13              LSRS     r3,r2,#16             ;916
0000f4  708b              STRB     r3,[r1,#2]            ;916
0000f6  0e12              LSRS     r2,r2,#24             ;916
0000f8  70ca              STRB     r2,[r1,#3]            ;916
0000fa  f8848004          STRB     r8,[r4,#4]            ;917
0000fe  e78a              B        |L47.22|
;;;927    #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;936    static
;;;937    FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;938    	FATFS* fs,			/* File system object */
;;;939    	DWORD clst			/* Cluster# to remove a chain from */
;;;940    )
;;;941    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;942    	FRESULT res;
;;;943    	DWORD nxt;
;;;944    #if _USE_TRIM
;;;945    	DWORD scl = clst, ecl = clst, rt[2];
;;;946    #endif
;;;947    
;;;948    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
000008  2f02              CMP      r7,#2
00000a  d302              BCC      |L48.18|
00000c  6960              LDR      r0,[r4,#0x14]
00000e  42b8              CMP      r0,r7
000010  d801              BHI      |L48.22|
                  |L48.18|
;;;949    		res = FR_INT_ERR;
000012  2602              MOVS     r6,#2
000014  e024              B        |L48.96|
                  |L48.22|
;;;950    
;;;951    	} else {
;;;952    		res = FR_OK;
000016  2600              MOVS     r6,#0
;;;953    		while (clst < fs->n_fatent) {			/* Not a last link? */
000018  e01f              B        |L48.90|
                  |L48.26|
;;;954    			nxt = get_fat(fs, clst);			/* Get cluster status */
00001a  4639              MOV      r1,r7
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       get_fat
000022  4605              MOV      r5,r0
;;;955    			if (nxt == 0) break;				/* Empty cluster? */
000024  b1e5              CBZ      r5,|L48.96|
;;;956    			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
000026  2d01              CMP      r5,#1
000028  d009              BEQ      |L48.62|
;;;957    			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
00002a  1c68              ADDS     r0,r5,#1
00002c  d009              BEQ      |L48.66|
;;;958    			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
00002e  2200              MOVS     r2,#0
000030  4639              MOV      r1,r7
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       put_fat
000038  4606              MOV      r6,r0
;;;959    			if (res != FR_OK) break;
00003a  b98e              CBNZ     r6,|L48.96|
00003c  e003              B        |L48.70|
                  |L48.62|
00003e  2602              MOVS     r6,#2                 ;956
000040  e00e              B        |L48.96|
                  |L48.66|
000042  2601              MOVS     r6,#1                 ;957
000044  e00c              B        |L48.96|
                  |L48.70|
;;;960    			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
000046  6920              LDR      r0,[r4,#0x10]
000048  1c41              ADDS     r1,r0,#1
00004a  d005              BEQ      |L48.88|
;;;961    				fs->free_clust++;
00004c  1c40              ADDS     r0,r0,#1
00004e  6120              STR      r0,[r4,#0x10]
;;;962    				fs->fsi_flag |= 1;
000050  7960              LDRB     r0,[r4,#5]
000052  f0400001          ORR      r0,r0,#1
000056  7160              STRB     r0,[r4,#5]
                  |L48.88|
;;;963    			}
;;;964    #if _USE_TRIM
;;;965    			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
;;;966    				ecl = nxt;
;;;967    			} else {				/* End of contiguous clusters */ 
;;;968    				rt[0] = clust2sect(fs, scl);					/* Start sector */
;;;969    				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;970    				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
;;;971    				scl = ecl = nxt;
;;;972    			}
;;;973    #endif
;;;974    			clst = nxt;	/* Next cluster */
000058  462f              MOV      r7,r5
                  |L48.90|
00005a  6960              LDR      r0,[r4,#0x14]         ;953
00005c  42b8              CMP      r0,r7                 ;953
00005e  d8dc              BHI      |L48.26|
                  |L48.96|
;;;975    		}
;;;976    	}
;;;977    
;;;978    	return res;
000060  4630              MOV      r0,r6
;;;979    }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;980    #endif
                          ENDP


                          AREA ||i.st_clust||, CODE, READONLY, ALIGN=1

                  st_clust PROC
;;;1251   static
;;;1252   void st_clust (
000000  7681              STRB     r1,[r0,#0x1a]
;;;1253   	BYTE* dir,	/* Pointer to the SFN entry */
;;;1254   	DWORD cl	/* Value to be set */
;;;1255   )
;;;1256   {
;;;1257   	ST_WORD(dir + DIR_FstClusLO, cl);
000002  0a0a              LSRS     r2,r1,#8
000004  76c2              STRB     r2,[r0,#0x1b]
;;;1258   	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
000006  0c0a              LSRS     r2,r1,#16
000008  7502              STRB     r2,[r0,#0x14]
00000a  0e09              LSRS     r1,r1,#24
00000c  7541              STRB     r1,[r0,#0x15]
;;;1259   }
00000e  4770              BX       lr
;;;1260   #endif
                          ENDP


                          AREA ||i.sync_fs||, CODE, READONLY, ALIGN=1

                  sync_fs PROC
;;;759    static
;;;760    FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
000000  b570              PUSH     {r4-r6,lr}
;;;761    	FATFS* fs		/* File system object */
;;;762    )
;;;763    {
000002  4604              MOV      r4,r0
;;;764    	FRESULT res;
;;;765    
;;;766    
;;;767    	res = sync_window(fs);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       sync_window
00000a  4605              MOV      r5,r0
;;;768    	if (res == FR_OK) {
00000c  0028              MOVS     r0,r5
00000e  d14f              BNE      |L50.176|
;;;769    		/* Update FSInfo sector if needed */
;;;770    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
000010  7820              LDRB     r0,[r4,#0]
000012  2803              CMP      r0,#3
000014  d145              BNE      |L50.162|
000016  7960              LDRB     r0,[r4,#5]
000018  2801              CMP      r0,#1
00001a  d142              BNE      |L50.162|
;;;771    			/* Create FSInfo structure */
;;;772    			mem_set(fs->win, 0, SS(fs));
00001c  0242              LSLS     r2,r0,#9
00001e  f1040030          ADD      r0,r4,#0x30
000022  2100              MOVS     r1,#0
000024  4606              MOV      r6,r0
000026  f7fffffe          BL       mem_set
;;;773    			ST_WORD(fs->win + BS_55AA, 0xAA55);
00002a  2055              MOVS     r0,#0x55
00002c  f884022e          STRB     r0,[r4,#0x22e]
000030  20aa              MOVS     r0,#0xaa
000032  f884022f          STRB     r0,[r4,#0x22f]
;;;774    			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
000036  2052              MOVS     r0,#0x52
000038  f8840030          STRB     r0,[r4,#0x30]
00003c  f8840031          STRB     r0,[r4,#0x31]
000040  2161              MOVS     r1,#0x61
000042  f8841032          STRB     r1,[r4,#0x32]
000046  2041              MOVS     r0,#0x41
000048  f8840033          STRB     r0,[r4,#0x33]
;;;775    			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
00004c  2272              MOVS     r2,#0x72
00004e  f8842214          STRB     r2,[r4,#0x214]
000052  f8842215          STRB     r2,[r4,#0x215]
000056  f8840216          STRB     r0,[r4,#0x216]
00005a  f8841217          STRB     r1,[r4,#0x217]
;;;776    			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
00005e  6920              LDR      r0,[r4,#0x10]
000060  f8840218          STRB     r0,[r4,#0x218]
000064  0a01              LSRS     r1,r0,#8
000066  f8841219          STRB     r1,[r4,#0x219]
00006a  0c01              LSRS     r1,r0,#16
00006c  f884121a          STRB     r1,[r4,#0x21a]
000070  0e00              LSRS     r0,r0,#24
000072  f884021b          STRB     r0,[r4,#0x21b]
;;;777    			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
000076  68e0              LDR      r0,[r4,#0xc]
000078  f884021c          STRB     r0,[r4,#0x21c]
00007c  0a01              LSRS     r1,r0,#8
00007e  f884121d          STRB     r1,[r4,#0x21d]
000082  0c01              LSRS     r1,r0,#16
000084  f884121e          STRB     r1,[r4,#0x21e]
000088  0e00              LSRS     r0,r0,#24
00008a  f884021f          STRB     r0,[r4,#0x21f]
;;;778    			/* Write it into the FSInfo sector */
;;;779    			fs->winsect = fs->volbase + 1;
00008e  69e2              LDR      r2,[r4,#0x1c]
000090  1c52              ADDS     r2,r2,#1
000092  62e2              STR      r2,[r4,#0x2c]
;;;780    			disk_write(fs->drv, fs->win, fs->winsect, 1);
000094  7860              LDRB     r0,[r4,#1]
000096  2301              MOVS     r3,#1
000098  4631              MOV      r1,r6
00009a  f7fffffe          BL       disk_write
;;;781    			fs->fsi_flag = 0;
00009e  2000              MOVS     r0,#0
0000a0  7160              STRB     r0,[r4,#5]
                  |L50.162|
;;;782    		}
;;;783    		/* Make sure that no pending write process in the physical drive */
;;;784    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
0000a2  2200              MOVS     r2,#0
0000a4  7860              LDRB     r0,[r4,#1]
0000a6  4611              MOV      r1,r2
0000a8  f7fffffe          BL       disk_ioctl
0000ac  b100              CBZ      r0,|L50.176|
;;;785    			res = FR_DISK_ERR;
0000ae  2501              MOVS     r5,#1
                  |L50.176|
;;;786    	}
;;;787    
;;;788    	return res;
0000b0  4628              MOV      r0,r5
;;;789    }
0000b2  bd70              POP      {r4-r6,pc}
;;;790    #endif
                          ENDP


                          AREA ||i.sync_window||, CODE, READONLY, ALIGN=1

                  sync_window PROC
;;;699    static
;;;700    FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;701    	FATFS* fs		/* File system object */
;;;702    )
;;;703    {
000004  4604              MOV      r4,r0
;;;704    	DWORD wsect;
;;;705    	UINT nf;
;;;706    	FRESULT res = FR_OK;
000006  2700              MOVS     r7,#0
;;;707    
;;;708    
;;;709    	if (fs->wflag) {	/* Write back the sector if it is dirty */
000008  7920              LDRB     r0,[r4,#4]
00000a  2800              CMP      r0,#0
00000c  d01f              BEQ      |L51.78|
;;;710    		wsect = fs->winsect;	/* Current sector number */
00000e  6ae6              LDR      r6,[r4,#0x2c]
;;;711    		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
000010  f1040130          ADD      r1,r4,#0x30
000014  7860              LDRB     r0,[r4,#1]
000016  2301              MOVS     r3,#1
000018  4632              MOV      r2,r6
00001a  4688              MOV      r8,r1
00001c  f7fffffe          BL       disk_write
000020  b108              CBZ      r0,|L51.38|
;;;712    			res = FR_DISK_ERR;
000022  2701              MOVS     r7,#1
000024  e013              B        |L51.78|
                  |L51.38|
;;;713    		} else {
;;;714    			fs->wflag = 0;
000026  2000              MOVS     r0,#0
000028  7120              STRB     r0,[r4,#4]
;;;715    			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
00002a  6a20              LDR      r0,[r4,#0x20]
00002c  69a1              LDR      r1,[r4,#0x18]
00002e  1a30              SUBS     r0,r6,r0
000030  4288              CMP      r0,r1
000032  d20c              BCS      |L51.78|
;;;716    				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
000034  78e5              LDRB     r5,[r4,#3]
000036  e008              B        |L51.74|
                  |L51.56|
;;;717    					wsect += fs->fsize;
000038  69a0              LDR      r0,[r4,#0x18]
00003a  4406              ADD      r6,r6,r0
;;;718    					disk_write(fs->drv, fs->win, wsect, 1);
00003c  7860              LDRB     r0,[r4,#1]
00003e  2301              MOVS     r3,#1
000040  4632              MOV      r2,r6
000042  4641              MOV      r1,r8
000044  f7fffffe          BL       disk_write
000048  1e6d              SUBS     r5,r5,#1              ;716
                  |L51.74|
00004a  2d02              CMP      r5,#2                 ;716
00004c  d2f4              BCS      |L51.56|
                  |L51.78|
;;;719    				}
;;;720    			}
;;;721    		}
;;;722    	}
;;;723    	return res;
00004e  4638              MOV      r0,r7
;;;724    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;725    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;2371   static
;;;2372   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b510              PUSH     {r4,lr}
;;;2373   	void* obj		/* Pointer to the object FIL/DIR to check validity */
;;;2374   )
;;;2375   {
;;;2376   	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
;;;2377   
;;;2378   
;;;2379   	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
000002  2800              CMP      r0,#0
000004  d00c              BEQ      |L52.32|
000006  6801              LDR      r1,[r0,#0]
000008  b151              CBZ      r1,|L52.32|
00000a  780a              LDRB     r2,[r1,#0]
00000c  b142              CBZ      r2,|L52.32|
00000e  88ca              LDRH     r2,[r1,#6]
000010  8880              LDRH     r0,[r0,#4]
000012  4282              CMP      r2,r0
000014  d104              BNE      |L52.32|
000016  7848              LDRB     r0,[r1,#1]
000018  f7fffffe          BL       disk_status
00001c  07c0              LSLS     r0,r0,#31
00001e  d001              BEQ      |L52.36|
                  |L52.32|
;;;2380   		return FR_INVALID_OBJECT;
000020  2009              MOVS     r0,#9
;;;2381   
;;;2382   	ENTER_FF(fil->fs);		/* Lock file system */
;;;2383   
;;;2384   	return FR_OK;
;;;2385   }
000022  bd10              POP      {r4,pc}
                  |L52.36|
000024  2000              MOVS     r0,#0                 ;2384
000026  bd10              POP      {r4,pc}
;;;2386   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  FatFs
                          %        12
                  Files
                          %        36

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  vst
000000  04000200          DCW      0x0400,0x0200
000004  01000080          DCW      0x0100,0x0080
000008  00400020          DCW      0x0040,0x0020
00000c  00100008          DCW      0x0010,0x0008
000010  00040002          DCW      0x0004,0x0002
000014  0000              DCW      0x0000
                  ||cst||
000016  8000              DCW      0x8000
000018  40002000          DCW      0x4000,0x2000
00001c  10000800          DCW      0x1000,0x0800
000020  40002000          DCW      0x4000,0x2000
000024  10000800          DCW      0x1000,0x0800
000028  04000200          DCW      0x0400,0x0200

                          AREA ||.data||, DATA, ALIGN=1

                  Fsid
000000  0000              DCB      0x00,0x00
