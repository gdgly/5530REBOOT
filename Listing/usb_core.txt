; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\usb_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\usb_core.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -I..\Libraries\STM32_USB_OTG_Driver\inc -I..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\User\usbh_mass_storage -I..\User\fatfs\src -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY -DSTM32F40XX --omf_browse=..\output\usb_core.crf --no_multibyte_chars ..\Libraries\STM32_USB_OTG_Driver\src\usb_core.c]
                          THUMB

                          AREA ||i.USB_OTG_ActiveRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USB_OTG_ActiveRemoteWakeup PROC
;;;1991   */
;;;1992   void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
000000  b53e              PUSH     {r1-r5,lr}
;;;1993   {
000002  4604              MOV      r4,r0
;;;1994     
;;;1995     USB_OTG_DCTL_TypeDef     dctl;
;;;1996     USB_OTG_DSTS_TypeDef     dsts;
;;;1997     USB_OTG_PCGCCTL_TypeDef  power;  
;;;1998     
;;;1999     if (pdev->dev.DevRemoteWakeup) 
000004  f8d40118          LDR      r0,[r4,#0x118]
000008  2800              CMP      r0,#0
00000a  d01e              BEQ      |L1.74|
;;;2000     {
;;;2001       dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
00000c  6920              LDR      r0,[r4,#0x10]
00000e  6880              LDR      r0,[r0,#8]
000010  9001              STR      r0,[sp,#4]
;;;2002       if(dsts.b.suspsts == 1)
000012  07c0              LSLS     r0,r0,#31
000014  d019              BEQ      |L1.74|
;;;2003       {
;;;2004         if(pdev->cfg.low_power)
000016  7aa0              LDRB     r0,[r4,#0xa]
000018  b140              CBZ      r0,|L1.44|
;;;2005         {
;;;2006           /* un-gate USB Core clock */
;;;2007           power.d32 = USB_OTG_READ_REG32(pdev->regs.PCGCCTL);
00001a  f8d4010c          LDR      r0,[r4,#0x10c]
00001e  6801              LDR      r1,[r0,#0]
;;;2008           power.b.gatehclk = 0;
000020  f0210102          BIC      r1,r1,#2
;;;2009           power.b.stoppclk = 0;
000024  f0210101          BIC      r1,r1,#1
000028  9100              STR      r1,[sp,#0]
;;;2010           USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
00002a  6001              STR      r1,[r0,#0]
                  |L1.44|
;;;2011         }   
;;;2012         /* active Remote wakeup signaling */
;;;2013         dctl.d32 = 0;
;;;2014         dctl.b.rmtwkupsig = 1;
00002c  2001              MOVS     r0,#1
00002e  9002              STR      r0,[sp,#8]
;;;2015         USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
000030  6920              LDR      r0,[r4,#0x10]
000032  6841              LDR      r1,[r0,#4]
000034  f0410101          ORR      r1,r1,#1
000038  6041              STR      r1,[r0,#4]
;;;2016         USB_OTG_BSP_mDelay(5);
00003a  2005              MOVS     r0,#5
00003c  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;2017         USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
000040  6920              LDR      r0,[r4,#0x10]
000042  6841              LDR      r1,[r0,#4]
000044  f0210101          BIC      r1,r1,#1
000048  6041              STR      r1,[r0,#4]
                  |L1.74|
;;;2018       }
;;;2019     }
;;;2020   }
00004a  bd3e              POP      {r1-r5,pc}
;;;2021   
                          ENDP


                          AREA ||i.USB_OTG_CoreInit||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInit PROC
;;;328    */
;;;329    USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
000000  b53e              PUSH     {r1-r5,lr}
;;;330    {
000002  4604              MOV      r4,r0
;;;331      USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;332      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;333      USB_OTG_GCCFG_TypeDef    gccfg;
;;;334      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;335    #if defined (STM32F446xx) || defined (STM32F469_479xx)
;;;336      USB_OTG_DCTL_TypeDef     dctl;
;;;337    #endif
;;;338      usbcfg.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
;;;339      gccfg.d32 = 0;
00000a  9001              STR      r0,[sp,#4]
;;;340      ahbcfg.d32 = 0;
00000c  9000              STR      r0,[sp,#0]
;;;341    
;;;342      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
00000e  7a21              LDRB     r1,[r4,#8]
000010  68e0              LDR      r0,[r4,#0xc]
000012  2901              CMP      r1,#1
000014  d019              BEQ      |L2.74|
;;;343      {
;;;344        gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
;;;345        gccfg.b.pwdn = 0;
;;;346        
;;;347        if (pdev->cfg.Sof_output)
;;;348        {
;;;349          gccfg.b.sofouten = 1;   
;;;350        }
;;;351        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
;;;352        
;;;353        /* Init The ULPI Interface */
;;;354        usbcfg.d32 = 0;
;;;355        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;356        
;;;357        usbcfg.b.physel            = 0; /* HS Interface */
;;;358    #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
;;;359        usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
;;;360    #else
;;;361    #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
;;;362        usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
;;;363    #endif
;;;364    #endif 
;;;365        usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
;;;366        
;;;367        usbcfg.b.ulpi_fsls = 0;
;;;368        usbcfg.b.ulpi_clk_sus_m = 0;
;;;369        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;370        
;;;371        /* Reset after a PHY select  */
;;;372        USB_OTG_CoreReset(pdev);
;;;373        
;;;374        if(pdev->cfg.dma_enable == 1)
;;;375        {
;;;376          
;;;377          ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
;;;378          ahbcfg.b.dmaenable = 1;
;;;379          USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
;;;380          
;;;381        }    
;;;382      }
;;;383      else /* FS interface (embedded Phy) */
;;;384      {
;;;385        
;;;386        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
000016  68c1              LDR      r1,[r0,#0xc]
;;;387        usbcfg.b.physel  = 1; /* FS Interface */
000018  f0410140          ORR      r1,r1,#0x40
00001c  9102              STR      r1,[sp,#8]
;;;388        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00001e  60c1              STR      r1,[r0,#0xc]
;;;389        /* Reset after a PHY select and set Host mode */
;;;390        USB_OTG_CoreReset(pdev);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USB_OTG_CoreReset
;;;391        /* Deactivate the power down*/
;;;392        gccfg.d32 = 0;
;;;393        gccfg.b.pwdn = 1;
;;;394        gccfg.b.vbussensingA = 1 ;
;;;395        gccfg.b.vbussensingB = 1 ; 
;;;396       
;;;397    #ifndef VBUS_SENSING_ENABLED
;;;398        gccfg.b.disablevbussensing = 1; 
000026  f44f1034          MOV      r0,#0x2d0000
00002a  9001              STR      r0,[sp,#4]
;;;399    #endif    
;;;400        
;;;401        if(pdev->cfg.Sof_output)
00002c  7a60              LDRB     r0,[r4,#9]
00002e  b110              CBZ      r0,|L2.54|
;;;402        {
;;;403          gccfg.b.sofouten = 1;  
000030  f44f1074          MOV      r0,#0x3d0000
000034  9001              STR      r0,[sp,#4]
                  |L2.54|
;;;404        }
;;;405        
;;;406        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
000036  68e1              LDR      r1,[r4,#0xc]
000038  9801              LDR      r0,[sp,#4]
00003a  6388              STR      r0,[r1,#0x38]
;;;407        USB_OTG_BSP_mDelay(20);
00003c  2014              MOVS     r0,#0x14
00003e  f7fffffe          BL       USB_OTG_BSP_mDelay
                  |L2.66|
;;;408      }
;;;409      /* case the HS core is working in FS mode */
;;;410      if(pdev->cfg.dma_enable == 1)
000042  78e0              LDRB     r0,[r4,#3]
000044  2801              CMP      r0,#1
000046  d024              BEQ      |L2.146|
000048  e02c              B        |L2.164|
                  |L2.74|
00004a  6b81              LDR      r1,[r0,#0x38]         ;344
00004c  f4213180          BIC      r1,r1,#0x10000        ;345
000050  9101              STR      r1,[sp,#4]            ;345
000052  7a62              LDRB     r2,[r4,#9]            ;347
000054  b112              CBZ      r2,|L2.92|
000056  f4411180          ORR      r1,r1,#0x100000       ;349
00005a  9101              STR      r1,[sp,#4]            ;349
                  |L2.92|
00005c  9901              LDR      r1,[sp,#4]            ;351
00005e  6381              STR      r1,[r0,#0x38]         ;351
000060  68e0              LDR      r0,[r4,#0xc]          ;355
000062  68c1              LDR      r1,[r0,#0xc]          ;355
000064  f0210140          BIC      r1,r1,#0x40           ;357
000068  f4411180          ORR      r1,r1,#0x100000       ;362
00006c  f4210180          BIC      r1,r1,#0x400000       ;365
000070  f4213100          BIC      r1,r1,#0x20000        ;367
000074  f4212100          BIC      r1,r1,#0x80000        ;368
000078  9102              STR      r1,[sp,#8]            ;368
00007a  60c1              STR      r1,[r0,#0xc]          ;369
00007c  4620              MOV      r0,r4                 ;372
00007e  f7fffffe          BL       USB_OTG_CoreReset
000082  78e0              LDRB     r0,[r4,#3]            ;374
000084  2801              CMP      r0,#1                 ;374
000086  d1dc              BNE      |L2.66|
000088  202a              MOVS     r0,#0x2a              ;378
00008a  9000              STR      r0,[sp,#0]            ;378
00008c  68e1              LDR      r1,[r4,#0xc]          ;379
00008e  6088              STR      r0,[r1,#8]            ;379
000090  e7d7              B        |L2.66|
                  |L2.146|
;;;411      {
;;;412        
;;;413        ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
000092  68e0              LDR      r0,[r4,#0xc]
000094  6881              LDR      r1,[r0,#8]
;;;414        ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
000096  f021011e          BIC      r1,r1,#0x1e
00009a  310a              ADDS     r1,r1,#0xa
;;;415        ahbcfg.b.dmaenable = 1;
00009c  f0410120          ORR      r1,r1,#0x20
0000a0  9100              STR      r1,[sp,#0]
;;;416        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
0000a2  6081              STR      r1,[r0,#8]
                  |L2.164|
;;;417        
;;;418      }
;;;419      /* initialize OTG features */
;;;420    #ifdef  USE_OTG_MODE
;;;421      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;422      usbcfg.b.hnpcap = 1;
;;;423      usbcfg.b.srpcap = 1;
;;;424      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;425      USB_OTG_EnableCommonInt(pdev);
;;;426    #endif
;;;427      
;;;428    #if defined (STM32F446xx) || defined (STM32F469_479xx)
;;;429      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;430      usbcfg.b.srpcap = 1;
;;;431      /*clear sdis bit in dctl */
;;;432      dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
;;;433      /* Connect device */
;;;434      dctl.b.sftdiscon  = 0;
;;;435      USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
;;;436      dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
;;;437      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;438      USB_OTG_EnableCommonInt(pdev);
;;;439    #endif
;;;440      
;;;441      return status;
0000a4  4628              MOV      r0,r5
;;;442    }
0000a6  bd3e              POP      {r1-r5,pc}
;;;443    /**
                          ENDP


                          AREA ||i.USB_OTG_CoreInitDev||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInitDev PROC
;;;1228   */
;;;1229   USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1230   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;1231     USB_OTG_STS             status       = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;1232     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1233     uint32_t i;
;;;1234     USB_OTG_DCFG_TypeDef    dcfg;
;;;1235     USB_OTG_FSIZ_TypeDef    nptxfifosize;
;;;1236     USB_OTG_FSIZ_TypeDef    txfifosize;
;;;1237     USB_OTG_DIEPMSK_TypeDef msk;
;;;1238     USB_OTG_DTHRCTL_TypeDef dthrctl;  
;;;1239     
;;;1240     depctl.d32 = 0;
000008  2500              MOVS     r5,#0
00000a  9506              STR      r5,[sp,#0x18]
;;;1241     dcfg.d32 = 0;
;;;1242     nptxfifosize.d32 = 0;
00000c  9504              STR      r5,[sp,#0x10]
;;;1243     txfifosize.d32 = 0;
00000e  9503              STR      r5,[sp,#0xc]
;;;1244     msk.d32 = 0;
000010  9502              STR      r5,[sp,#8]
;;;1245     
;;;1246     /* Restart the Phy Clock */
;;;1247     USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
000012  f8d4010c          LDR      r0,[r4,#0x10c]
000016  6005              STR      r5,[r0,#0]
;;;1248     /* Device configuration register */
;;;1249     dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
000018  6920              LDR      r0,[r4,#0x10]
00001a  6801              LDR      r1,[r0,#0]
;;;1250     dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
00001c  f42151c0          BIC      r1,r1,#0x1800
000020  9105              STR      r1,[sp,#0x14]
;;;1251     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
000022  6001              STR      r1,[r0,#0]
;;;1252     
;;;1253   #ifdef USB_OTG_FS_CORE
;;;1254   //  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
;;;1255   //  {  
;;;1256   //    
;;;1257   //    /* Set Full speed phy */
;;;1258   //    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
;;;1259   //    
;;;1260   //    /* set Rx FIFO size */
;;;1261   //    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
;;;1262   //    
;;;1263   //    /* EP0 TX*/
;;;1264   //    nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
;;;1265   //    nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
;;;1266   //    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
;;;1267   //    
;;;1268   //    
;;;1269   //    /* EP1 TX*/
;;;1270   //    txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
;;;1271   //    txfifosize.b.depth = TX1_FIFO_FS_SIZE;
;;;1272   //    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
;;;1273   //    
;;;1274   //    
;;;1275   //    /* EP2 TX*/
;;;1276   //    txfifosize.b.startaddr += txfifosize.b.depth;
;;;1277   //    txfifosize.b.depth = TX2_FIFO_FS_SIZE;
;;;1278   //    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
;;;1279   //    
;;;1280   //    
;;;1281   //    /* EP3 TX*/  
;;;1282   //    txfifosize.b.startaddr += txfifosize.b.depth;
;;;1283   //    txfifosize.b.depth = TX3_FIFO_FS_SIZE;
;;;1284   //    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
;;;1285   //  }
;;;1286   #endif
;;;1287   #ifdef USB_OTG_HS_CORE
;;;1288     if(pdev->cfg.coreID == USB_OTG_HS_CORE_ID  )
000024  7ae0              LDRB     r0,[r4,#0xb]
000026  2800              CMP      r0,#0
000028  d146              BNE      |L3.184|
;;;1289     {
;;;1290       
;;;1291       /* Set High speed phy */
;;;1292       
;;;1293       if(pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY)
00002a  7a20              LDRB     r0,[r4,#8]
00002c  2801              CMP      r0,#1
00002e  d05a              BEQ      |L3.230|
;;;1294       {
;;;1295         USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH);
;;;1296       }
;;;1297       else /* set High speed phy in Full speed mode */
;;;1298       {
;;;1299         USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH_IN_FULL);
000030  2101              MOVS     r1,#1
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       USB_OTG_InitDevSpeed
                  |L3.56|
;;;1300       }
;;;1301       
;;;1302       /* set Rx FIFO size */
;;;1303       USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
000038  68e1              LDR      r1,[r4,#0xc]
00003a  f44f7000          MOV      r0,#0x200
00003e  6248              STR      r0,[r1,#0x24]
;;;1304       
;;;1305       /* EP0 TX*/
;;;1306       nptxfifosize.b.depth     = TX0_FIFO_HS_SIZE;
000040  2180              MOVS     r1,#0x80
000042  f8ad1012          STRH     r1,[sp,#0x12]
;;;1307       nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;
000046  f8ad0010          STRH     r0,[sp,#0x10]
;;;1308       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
00004a  68e1              LDR      r1,[r4,#0xc]
00004c  9804              LDR      r0,[sp,#0x10]
00004e  6288              STR      r0,[r1,#0x28]
;;;1309       
;;;1310       
;;;1311       /* EP1 TX*/
;;;1312       txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
000050  eb004010          ADD      r0,r0,r0,LSR #16
000054  f8ad000c          STRH     r0,[sp,#0xc]
;;;1313       txfifosize.b.depth = TX1_FIFO_HS_SIZE;
000058  f44f70c0          MOV      r0,#0x180
00005c  f8ad000e          STRH     r0,[sp,#0xe]
;;;1314       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
000060  68e1              LDR      r1,[r4,#0xc]
000062  9803              LDR      r0,[sp,#0xc]
000064  f8c10104          STR      r0,[r1,#0x104]
;;;1315       
;;;1316       
;;;1317       /* EP2 TX*/
;;;1318       txfifosize.b.startaddr += txfifosize.b.depth;
000068  eb004010          ADD      r0,r0,r0,LSR #16
00006c  f8ad000c          STRH     r0,[sp,#0xc]
;;;1319       txfifosize.b.depth = TX2_FIFO_HS_SIZE;
000070  f8ad500e          STRH     r5,[sp,#0xe]
;;;1320       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
000074  68e1              LDR      r1,[r4,#0xc]
000076  9803              LDR      r0,[sp,#0xc]
000078  f8c10108          STR      r0,[r1,#0x108]
;;;1321       
;;;1322       
;;;1323       /* EP3 TX*/  
;;;1324       txfifosize.b.startaddr += txfifosize.b.depth;
00007c  eb004010          ADD      r0,r0,r0,LSR #16
000080  f8ad000c          STRH     r0,[sp,#0xc]
;;;1325       txfifosize.b.depth = TX3_FIFO_HS_SIZE;
000084  f8ad500e          STRH     r5,[sp,#0xe]
;;;1326       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
000088  68e1              LDR      r1,[r4,#0xc]
00008a  9803              LDR      r0,[sp,#0xc]
00008c  f8c1010c          STR      r0,[r1,#0x10c]
;;;1327       
;;;1328       /* EP4 TX*/
;;;1329       txfifosize.b.startaddr += txfifosize.b.depth;
000090  eb004010          ADD      r0,r0,r0,LSR #16
000094  f8ad000c          STRH     r0,[sp,#0xc]
;;;1330       txfifosize.b.depth = TX4_FIFO_HS_SIZE;
000098  f8ad500e          STRH     r5,[sp,#0xe]
;;;1331       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[3], txfifosize.d32 );
00009c  68e1              LDR      r1,[r4,#0xc]
00009e  9803              LDR      r0,[sp,#0xc]
0000a0  f8c10110          STR      r0,[r1,#0x110]
;;;1332       
;;;1333       
;;;1334       /* EP5 TX*/  
;;;1335       txfifosize.b.startaddr += txfifosize.b.depth;
0000a4  eb004010          ADD      r0,r0,r0,LSR #16
0000a8  f8ad000c          STRH     r0,[sp,#0xc]
;;;1336       txfifosize.b.depth = TX5_FIFO_HS_SIZE;
0000ac  f8ad500e          STRH     r5,[sp,#0xe]
;;;1337       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
0000b0  68e1              LDR      r1,[r4,#0xc]
0000b2  9803              LDR      r0,[sp,#0xc]
0000b4  f8c10114          STR      r0,[r1,#0x114]
                  |L3.184|
;;;1338     }
;;;1339   #endif  
;;;1340     /* Flush the FIFOs */
;;;1341     USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
0000b8  2110              MOVS     r1,#0x10
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;1342     USB_OTG_FlushRxFifo(pdev);
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;1343     /* Clear all pending Device Interrupts */
;;;1344     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
0000c6  6920              LDR      r0,[r4,#0x10]
0000c8  6105              STR      r5,[r0,#0x10]
;;;1345     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
0000ca  6920              LDR      r0,[r4,#0x10]
0000cc  6145              STR      r5,[r0,#0x14]
;;;1346     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
0000ce  6921              LDR      r1,[r4,#0x10]
0000d0  f04f30ff          MOV      r0,#0xffffffff
0000d4  6188              STR      r0,[r1,#0x18]
;;;1347     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
0000d6  6920              LDR      r0,[r4,#0x10]
0000d8  61c5              STR      r5,[r0,#0x1c]
;;;1348     
;;;1349     for (i = 0; i < pdev->cfg.dev_endpoints; i++)
0000da  2000              MOVS     r0,#0
;;;1350     {
;;;1351       depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
;;;1352       if (depctl.b.epena)
;;;1353       {
;;;1354         depctl.d32 = 0;
;;;1355         depctl.b.epdis = 1;
;;;1356         depctl.b.snak = 1;
0000dc  f04f4790          MOV      r7,#0x48000000
;;;1357       }
;;;1358       else
;;;1359       {
;;;1360         depctl.d32 = 0;
;;;1361       }
;;;1362       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
;;;1363       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
;;;1364       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
0000e0  f04f0cff          MOV      r12,#0xff
0000e4  e016              B        |L3.276|
                  |L3.230|
0000e6  2100              MOVS     r1,#0                 ;1295
0000e8  4620              MOV      r0,r4                 ;1295
0000ea  f7fffffe          BL       USB_OTG_InitDevSpeed
0000ee  e7a3              B        |L3.56|
                  |L3.240|
0000f0  eb040180          ADD      r1,r4,r0,LSL #2       ;1351
0000f4  698b              LDR      r3,[r1,#0x18]         ;1351
0000f6  681a              LDR      r2,[r3,#0]            ;1351
0000f8  9206              STR      r2,[sp,#0x18]         ;1351
0000fa  2a00              CMP      r2,#0                 ;1352
0000fc  da01              BGE      |L3.258|
0000fe  9706              STR      r7,[sp,#0x18]         ;1356
000100  e000              B        |L3.260|
                  |L3.258|
000102  9506              STR      r5,[sp,#0x18]         ;1360
                  |L3.260|
000104  9a06              LDR      r2,[sp,#0x18]         ;1362
000106  601a              STR      r2,[r3,#0]            ;1362
000108  698a              LDR      r2,[r1,#0x18]         ;1363
00010a  6115              STR      r5,[r2,#0x10]         ;1363
00010c  6989              LDR      r1,[r1,#0x18]
00010e  f8c1c008          STR      r12,[r1,#8]
000112  1c40              ADDS     r0,r0,#1              ;1349
                  |L3.276|
000114  7861              LDRB     r1,[r4,#1]            ;1349
000116  4281              CMP      r1,r0                 ;1349
000118  d8ea              BHI      |L3.240|
;;;1365     }
;;;1366     for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
00011a  2000              MOVS     r0,#0
00011c  e011              B        |L3.322|
                  |L3.286|
;;;1367     {
;;;1368       USB_OTG_DEPCTL_TypeDef  depctl;
;;;1369       depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
00011e  eb040180          ADD      r1,r4,r0,LSL #2
000122  6d4b              LDR      r3,[r1,#0x54]
000124  681a              LDR      r2,[r3,#0]
000126  9200              STR      r2,[sp,#0]
;;;1370       if (depctl.b.epena)
000128  2a00              CMP      r2,#0
00012a  da01              BGE      |L3.304|
;;;1371       {
;;;1372         depctl.d32 = 0;
;;;1373         depctl.b.epdis = 1;
;;;1374         depctl.b.snak = 1;
00012c  9700              STR      r7,[sp,#0]
00012e  e000              B        |L3.306|
                  |L3.304|
;;;1375       }
;;;1376       else
;;;1377       {
;;;1378         depctl.d32 = 0;
000130  9500              STR      r5,[sp,#0]
                  |L3.306|
;;;1379       }
;;;1380       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
000132  9a00              LDR      r2,[sp,#0]
000134  601a              STR      r2,[r3,#0]
;;;1381       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
000136  6d4a              LDR      r2,[r1,#0x54]
000138  6115              STR      r5,[r2,#0x10]
;;;1382       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
00013a  6d49              LDR      r1,[r1,#0x54]
00013c  f8c1c008          STR      r12,[r1,#8]
000140  1c40              ADDS     r0,r0,#1              ;1366
                  |L3.322|
000142  7861              LDRB     r1,[r4,#1]            ;1366
000144  4281              CMP      r1,r0                 ;1366
000146  d8ea              BHI      |L3.286|
;;;1383     }
;;;1384     msk.d32 = 0;
;;;1385     msk.b.txfifoundrn = 1;
000148  f44f7080          MOV      r0,#0x100
00014c  9002              STR      r0,[sp,#8]
;;;1386     USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
00014e  6920              LDR      r0,[r4,#0x10]
000150  6901              LDR      r1,[r0,#0x10]
000152  f4417180          ORR      r1,r1,#0x100
000156  6101              STR      r1,[r0,#0x10]
;;;1387     
;;;1388     if (pdev->cfg.dma_enable == 1)
000158  78e0              LDRB     r0,[r4,#3]
00015a  2801              CMP      r0,#1
00015c  d10a              BNE      |L3.372|
;;;1389     {
;;;1390       dthrctl.d32 = 0;
;;;1391       dthrctl.b.non_iso_thr_en = 1;
;;;1392       dthrctl.b.iso_thr_en = 1;
00015e  2003              MOVS     r0,#3
;;;1393       dthrctl.b.tx_thr_len = 64;
000160  2140              MOVS     r1,#0x40
000162  f361008a          BFI      r0,r1,#2,#9
;;;1394       dthrctl.b.rx_thr_en = 1;
000166  f4403080          ORR      r0,r0,#0x10000
;;;1395       dthrctl.b.rx_thr_len = 64;
00016a  f3614059          BFI      r0,r1,#17,#9
00016e  9001              STR      r0,[sp,#4]
;;;1396       USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
000170  6921              LDR      r1,[r4,#0x10]
000172  6308              STR      r0,[r1,#0x30]
                  |L3.372|
;;;1397     }
;;;1398     USB_OTG_EnableDevInt(pdev);
000174  4620              MOV      r0,r4
000176  f7fffffe          BL       USB_OTG_EnableDevInt
;;;1399     return status;
;;;1400   }
00017a  b007              ADD      sp,sp,#0x1c
00017c  4630              MOV      r0,r6                 ;1399
00017e  bdf0              POP      {r4-r7,pc}
;;;1401   
                          ENDP


                          AREA ||i.USB_OTG_CoreInitHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInitHost PROC
;;;636    */
;;;637    USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
000000  b5fe              PUSH     {r1-r7,lr}
;;;638    {
000002  4604              MOV      r4,r0
;;;639      USB_OTG_STS                     status = USB_OTG_OK;
000004  2700              MOVS     r7,#0
;;;640      USB_OTG_FSIZ_TypeDef            nptxfifosize;
;;;641      USB_OTG_FSIZ_TypeDef            ptxfifosize;  
;;;642      USB_OTG_HCFG_TypeDef            hcfg;
;;;643      
;;;644    #ifdef USE_OTG_MODE
;;;645      USB_OTG_OTGCTL_TypeDef          gotgctl;
;;;646    #endif
;;;647      
;;;648      uint32_t                        i = 0;
000006  2500              MOVS     r5,#0
;;;649      
;;;650      nptxfifosize.d32 = 0;  
000008  2600              MOVS     r6,#0
00000a  9602              STR      r6,[sp,#8]
;;;651      ptxfifosize.d32 = 0;
00000c  9601              STR      r6,[sp,#4]
;;;652    #ifdef USE_OTG_MODE
;;;653      gotgctl.d32 = 0;
;;;654    #endif
;;;655      hcfg.d32 = 0;
00000e  9600              STR      r6,[sp,#0]
;;;656      
;;;657      
;;;658      /* configure charge pump IO */
;;;659      USB_OTG_BSP_ConfigVBUS(pdev);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;660      
;;;661      /* Restart the Phy Clock */
;;;662      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
000016  f8d4010c          LDR      r0,[r4,#0x10c]
00001a  6006              STR      r6,[r0,#0]
;;;663      
;;;664      /* Initialize Host Configuration Register */
;;;665      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
00001c  7a20              LDRB     r0,[r4,#8]
00001e  2801              CMP      r0,#1
000020  d00f              BEQ      |L4.66|
;;;666      {
;;;667        USB_OTG_InitFSLSPClkSel(pdev , HCFG_30_60_MHZ); 
;;;668      }
;;;669      else
;;;670      {
;;;671        USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); 
000022  2101              MOVS     r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       USB_OTG_InitFSLSPClkSel
                  |L4.42|
;;;672      }
;;;673      USB_OTG_ResetPort(pdev);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       USB_OTG_ResetPort
;;;674      
;;;675      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
000030  6960              LDR      r0,[r4,#0x14]
000032  6801              LDR      r1,[r0,#0]
;;;676      hcfg.b.fslssupp = 0;
000034  f0210104          BIC      r1,r1,#4
000038  9100              STR      r1,[sp,#0]
;;;677      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
00003a  6001              STR      r1,[r0,#0]
;;;678      
;;;679      /* Configure data FIFO sizes */
;;;680      /* Rx FIFO */
;;;681    #ifdef USB_OTG_FS_CORE
;;;682      if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
;;;683      {
;;;684        /* set Rx FIFO size */
;;;685        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
;;;686        nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
;;;687        nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
;;;688        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
;;;689        
;;;690        ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
;;;691        ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
;;;692        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
;;;693      }
;;;694    #endif
;;;695    #ifdef USB_OTG_HS_CORE  
;;;696      if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
00003c  7ae0              LDRB     r0,[r4,#0xb]
00003e  b128              CBZ      r0,|L4.76|
000040  e01a              B        |L4.120|
                  |L4.66|
000042  2100              MOVS     r1,#0                 ;667
000044  4620              MOV      r0,r4                 ;667
000046  f7fffffe          BL       USB_OTG_InitFSLSPClkSel
00004a  e7ee              B        |L4.42|
                  |L4.76|
;;;697      {
;;;698        /* set Rx FIFO size */
;;;699        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
00004c  68e1              LDR      r1,[r4,#0xc]
00004e  f44f7000          MOV      r0,#0x200
000052  6248              STR      r0,[r1,#0x24]
;;;700        nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
000054  f8ad0008          STRH     r0,[sp,#8]
;;;701        nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
000058  1040              ASRS     r0,r0,#1
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;702        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
00005e  68e2              LDR      r2,[r4,#0xc]
000060  9902              LDR      r1,[sp,#8]
000062  6291              STR      r1,[r2,#0x28]
;;;703        
;;;704        ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
000064  f44f7140          MOV      r1,#0x300
000068  f8ad1004          STRH     r1,[sp,#4]
;;;705        ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
00006c  f8ad0006          STRH     r0,[sp,#6]
;;;706        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
000070  68e1              LDR      r1,[r4,#0xc]
000072  9801              LDR      r0,[sp,#4]
000074  f8c10100          STR      r0,[r1,#0x100]
                  |L4.120|
;;;707      }
;;;708    #endif  
;;;709      
;;;710    #ifdef USE_OTG_MODE
;;;711      /* Clear Host Set HNP Enable in the USB_OTG Control Register */
;;;712      gotgctl.b.hstsethnpen = 1;
;;;713      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
;;;714    #endif
;;;715      
;;;716      /* Make sure the FIFOs are flushed. */
;;;717      USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
000078  2110              MOVS     r1,#0x10
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;718      USB_OTG_FlushRxFifo(pdev);
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;719      
;;;720      
;;;721      /* Clear all pending HC Interrupts */
;;;722      for (i = 0; i < pdev->cfg.host_channels; i++)
;;;723      {
;;;724        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
000086  f04f31ff          MOV      r1,#0xffffffff
00008a  e007              B        |L4.156|
                  |L4.140|
00008c  eb040085          ADD      r0,r4,r5,LSL #2
000090  f8502f90          LDR      r2,[r0,#0x90]!
000094  6091              STR      r1,[r2,#8]
;;;725        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
000096  6800              LDR      r0,[r0,#0]
000098  60c6              STR      r6,[r0,#0xc]
00009a  1c6d              ADDS     r5,r5,#1              ;722
                  |L4.156|
00009c  7820              LDRB     r0,[r4,#0]            ;722
00009e  42a8              CMP      r0,r5                 ;722
0000a0  d8f4              BHI      |L4.140|
;;;726      }
;;;727    #ifndef USE_OTG_MODE
;;;728      USB_OTG_DriveVbus(pdev, 1);
0000a2  2101              MOVS     r1,#1
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       USB_OTG_DriveVbus
;;;729    #endif
;;;730      
;;;731      USB_OTG_EnableHostInt(pdev);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       USB_OTG_EnableHostInt
;;;732      return status;
0000b0  4638              MOV      r0,r7
;;;733    }
0000b2  bdfe              POP      {r1-r7,pc}
;;;734    
                          ENDP


                          AREA ||i.USB_OTG_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_OTG_CoreReset PROC
;;;122    */
;;;123    static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;124    {
000002  4605              MOV      r5,r0
;;;125      USB_OTG_STS status = USB_OTG_OK;
000004  2700              MOVS     r7,#0
;;;126      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;127      uint32_t count = 0;
000006  2400              MOVS     r4,#0
;;;128      
;;;129      greset.d32 = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;130      /* Wait for AHB master IDLE state. */
;;;131      do
;;;132      {
;;;133        USB_OTG_BSP_uDelay(3);
;;;134        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;135        if (++count > 200000)
00000c  4e12              LDR      r6,|L5.88|
                  |L5.14|
00000e  2003              MOVS     r0,#3                 ;133
000010  f7fffffe          BL       USB_OTG_BSP_uDelay
000014  68e8              LDR      r0,[r5,#0xc]          ;134
000016  6900              LDR      r0,[r0,#0x10]         ;134
000018  9000              STR      r0,[sp,#0]            ;134
00001a  1c64              ADDS     r4,r4,#1
00001c  42b4              CMP      r4,r6
00001e  d901              BLS      |L5.36|
;;;136        {
;;;137          return USB_OTG_OK;
000020  2000              MOVS     r0,#0
;;;138        }
;;;139      }
;;;140      while (greset.b.ahbidle == 0);
;;;141      /* Core Soft Reset */
;;;142      count = 0;
;;;143      greset.b.csftrst = 1;
;;;144      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
;;;145      do
;;;146      {
;;;147        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;148        if (++count > 200000)
;;;149        {
;;;150          break;
;;;151        }
;;;152      }
;;;153      while (greset.b.csftrst == 1);
;;;154      /* Wait for 3 PHY Clocks*/
;;;155      USB_OTG_BSP_uDelay(3);
;;;156      return status;
;;;157    }
000022  bdf8              POP      {r3-r7,pc}
                  |L5.36|
000024  9800              LDR      r0,[sp,#0]            ;140
000026  2800              CMP      r0,#0                 ;140
000028  daf1              BGE      |L5.14|
00002a  2100              MOVS     r1,#0                 ;142
00002c  9800              LDR      r0,[sp,#0]            ;143
00002e  f0400001          ORR      r0,r0,#1              ;143
000032  9000              STR      r0,[sp,#0]            ;143
000034  9800              LDR      r0,[sp,#0]            ;144
000036  68ea              LDR      r2,[r5,#0xc]          ;144
000038  6110              STR      r0,[r2,#0x10]         ;144
00003a  68e8              LDR      r0,[r5,#0xc]          ;134
                  |L5.60|
00003c  6902              LDR      r2,[r0,#0x10]         ;147
00003e  9200              STR      r2,[sp,#0]            ;147
000040  1c49              ADDS     r1,r1,#1              ;148
000042  42b1              CMP      r1,r6                 ;148
000044  d802              BHI      |L5.76|
000046  9a00              LDR      r2,[sp,#0]            ;153
000048  07d2              LSLS     r2,r2,#31             ;153
00004a  d1f7              BNE      |L5.60|
                  |L5.76|
00004c  2003              MOVS     r0,#3                 ;155
00004e  f7fffffe          BL       USB_OTG_BSP_uDelay
000052  4638              MOV      r0,r7                 ;156
000054  bdf8              POP      {r3-r7,pc}
;;;158    
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_DisableGlobalInt PROC
;;;466    */
;;;467    USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  2200              MOVS     r2,#0
;;;468    {
;;;469      USB_OTG_STS status = USB_OTG_OK;
;;;470      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;471      ahbcfg.d32 = 0;
;;;472      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;473      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
000002  68c0              LDR      r0,[r0,#0xc]
000004  6881              LDR      r1,[r0,#8]
000006  f0210101          BIC      r1,r1,#1
00000a  6081              STR      r1,[r0,#8]
;;;474      return status;
00000c  4610              MOV      r0,r2
;;;475    }
00000e  4770              BX       lr
;;;476    
                          ENDP


                          AREA ||i.USB_OTG_DriveVbus||, CODE, READONLY, ALIGN=1

                  USB_OTG_DriveVbus PROC
;;;751    */
;;;752    void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
000000  b538              PUSH     {r3-r5,lr}
;;;753    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;754      USB_OTG_HPRT0_TypeDef     hprt0;
;;;755      
;;;756      hprt0.d32 = 0;
;;;757      
;;;758      /* enable disable the external charge pump */
;;;759      USB_OTG_BSP_DriveVBUS(pdev, state);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USB_OTG_BSP_DriveVBUS
;;;760      
;;;761      /* Turn on the Host port power. */
;;;762      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USB_OTG_ReadHPRT0
000014  9000              STR      r0,[sp,#0]
;;;763      if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
000016  04c1              LSLS     r1,r0,#19
000018  d407              BMI      |L7.42|
00001a  2d01              CMP      r5,#1
00001c  d105              BNE      |L7.42|
;;;764      {
;;;765        hprt0.b.prtpwr = 1;
00001e  f4405080          ORR      r0,r0,#0x1000
000022  9000              STR      r0,[sp,#0]
;;;766        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000024  f8d410cc          LDR      r1,[r4,#0xcc]
000028  6008              STR      r0,[r1,#0]
                  |L7.42|
;;;767      }
;;;768      if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
00002a  9800              LDR      r0,[sp,#0]
00002c  04c1              LSLS     r1,r0,#19
00002e  d506              BPL      |L7.62|
000030  b92d              CBNZ     r5,|L7.62|
;;;769      {
;;;770        hprt0.b.prtpwr = 0;
000032  f4205080          BIC      r0,r0,#0x1000
000036  9000              STR      r0,[sp,#0]
;;;771        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000038  f8d410cc          LDR      r1,[r4,#0xcc]
00003c  6008              STR      r0,[r1,#0]
                  |L7.62|
;;;772      }
;;;773      
;;;774      USB_OTG_BSP_mDelay(200);
00003e  e8bd4038          POP      {r3-r5,lr}
000042  20c8              MOVS     r0,#0xc8
000044  f7ffbffe          B.W      USB_OTG_BSP_mDelay
;;;775    }
;;;776    /**
                          ENDP


                          AREA ||i.USB_OTG_EP0Activate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EP0Activate PROC
;;;1486   */
;;;1487   USB_OTG_STS  USB_OTG_EP0Activate(USB_OTG_CORE_HANDLE *pdev)
000000  b51e              PUSH     {r1-r4,lr}
;;;1488   {
;;;1489     USB_OTG_STS             status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
;;;1490     USB_OTG_DSTS_TypeDef    dsts;
;;;1491     USB_OTG_DEPCTL_TypeDef  diepctl;
;;;1492     USB_OTG_DCTL_TypeDef    dctl;
;;;1493     
;;;1494     dctl.d32 = 0;
000004  2100              MOVS     r1,#0
000006  9100              STR      r1,[sp,#0]
;;;1495     /* Read the Device Status and Endpoint 0 Control registers */
;;;1496     dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
000008  6901              LDR      r1,[r0,#0x10]
00000a  6889              LDR      r1,[r1,#8]
00000c  9102              STR      r1,[sp,#8]
;;;1497     diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
00000e  6983              LDR      r3,[r0,#0x18]
000010  681a              LDR      r2,[r3,#0]
000012  9201              STR      r2,[sp,#4]
;;;1498     /* Set the MPS of the IN EP based on the enumeration speed */
;;;1499     switch (dsts.b.enumspd)
000014  f3c10141          UBFX     r1,r1,#1,#2
000018  2900              CMP      r1,#0
00001a  d011              BEQ      |L8.64|
00001c  2901              CMP      r1,#1
00001e  d00f              BEQ      |L8.64|
000020  2902              CMP      r1,#2
000022  d011              BEQ      |L8.72|
000024  2903              CMP      r1,#3
000026  d00b              BEQ      |L8.64|
;;;1500     {
;;;1501     case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
;;;1502     case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
;;;1503     case DSTS_ENUMSPD_FS_PHY_48MHZ:
;;;1504       diepctl.b.mps = DEP0CTL_MPS_64;
;;;1505       break;
;;;1506     case DSTS_ENUMSPD_LS_PHY_6MHZ:
;;;1507       diepctl.b.mps = DEP0CTL_MPS_8;
;;;1508       break;
;;;1509     default:
;;;1510       diepctl.b.mps = DEP0CTL_MPS_64;
000028  0ad1              LSRS     r1,r2,#11
00002a  02c9              LSLS     r1,r1,#11
00002c  9101              STR      r1,[sp,#4]
                  |L8.46|
;;;1511       break; 
;;;1512     }
;;;1513     USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
00002e  9901              LDR      r1,[sp,#4]
000030  6019              STR      r1,[r3,#0]
;;;1514     dctl.b.cgnpinnak = 1;
;;;1515     USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
000032  6900              LDR      r0,[r0,#0x10]
000034  6841              LDR      r1,[r0,#4]
000036  f4417180          ORR      r1,r1,#0x100
00003a  6041              STR      r1,[r0,#4]
;;;1516     return status;
00003c  4620              MOV      r0,r4
;;;1517   }
00003e  bd1e              POP      {r1-r4,pc}
                  |L8.64|
000040  0ad1              LSRS     r1,r2,#11             ;1504
000042  02c9              LSLS     r1,r1,#11             ;1504
000044  9101              STR      r1,[sp,#4]            ;1504
000046  e7f2              B        |L8.46|
                  |L8.72|
000048  0ad1              LSRS     r1,r2,#11             ;1507
00004a  02c9              LSLS     r1,r1,#11             ;1507
00004c  1cc9              ADDS     r1,r1,#3              ;1507
00004e  9101              STR      r1,[sp,#4]            ;1507
000050  e7ed              B        |L8.46|
;;;1518   
                          ENDP


                          AREA ||i.USB_OTG_EP0StartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_EP0StartXfer PROC
;;;1750   */
;;;1751   USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b5fc              PUSH     {r2-r7,lr}
;;;1752   {
;;;1753     USB_OTG_STS                 status = USB_OTG_OK;
000002  2600              MOVS     r6,#0
;;;1754     USB_OTG_DEPCTL_TypeDef      depctl;
;;;1755     USB_OTG_DEP0XFRSIZ_TypeDef  deptsiz;
;;;1756     USB_OTG_INEPREGS          *in_regs;
;;;1757     uint32_t fifoemptymsk = 0;
;;;1758     
;;;1759     depctl.d32   = 0;
000004  2200              MOVS     r2,#0
000006  9201              STR      r2,[sp,#4]
;;;1760     deptsiz.d32  = 0;
000008  9200              STR      r2,[sp,#0]
;;;1761     /* IN endpoint */
;;;1762     if (ep->is_in == 1)
00000a  784a              LDRB     r2,[r1,#1]
00000c  694b              LDR      r3,[r1,#0x14]
00000e  2a01              CMP      r2,#1
000010  d016              BEQ      |L9.64|
;;;1763     {
;;;1764       in_regs = pdev->regs.INEP_REGS[0];
;;;1765       depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
;;;1766       deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
;;;1767       /* Zero Length Packet? */
;;;1768       if (ep->xfer_len == 0)
;;;1769       {
;;;1770         deptsiz.b.xfersize = 0;
;;;1771         deptsiz.b.pktcnt = 1;
;;;1772         
;;;1773       }
;;;1774       else
;;;1775       {
;;;1776         if (ep->xfer_len > ep->maxpacket)
;;;1777         {
;;;1778           ep->xfer_len = ep->maxpacket;
;;;1779           deptsiz.b.xfersize = ep->maxpacket;
;;;1780         }
;;;1781         else
;;;1782         {
;;;1783           deptsiz.b.xfersize = ep->xfer_len;
;;;1784         }
;;;1785         deptsiz.b.pktcnt = 1;
;;;1786       }
;;;1787       USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
;;;1788       
;;;1789       if (pdev->cfg.dma_enable == 1)
;;;1790       {
;;;1791         USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
;;;1792       }
;;;1793       
;;;1794       /* EP enable, IN data in FIFO */
;;;1795       depctl.b.cnak = 1;
;;;1796       depctl.b.epena = 1;
;;;1797       USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
;;;1798       
;;;1799       
;;;1800       
;;;1801       if (pdev->cfg.dma_enable == 0)
;;;1802       {
;;;1803         /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;1804         if (ep->xfer_len > 0)
;;;1805         {
;;;1806           {
;;;1807             fifoemptymsk |= 1 << ep->num;
;;;1808             USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
;;;1809           }
;;;1810         }
;;;1811       }
;;;1812     }
;;;1813     else
;;;1814     {
;;;1815       /* OUT endpoint */
;;;1816       depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
000012  780a              LDRB     r2,[r1,#0]
000014  eb000482          ADD      r4,r0,r2,LSL #2
000018  6d62              LDR      r2,[r4,#0x54]
00001a  6815              LDR      r5,[r2,#0]
00001c  9501              STR      r5,[sp,#4]
;;;1817       deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
00001e  6912              LDR      r2,[r2,#0x10]
000020  9200              STR      r2,[sp,#0]
;;;1818       /* Program the transfer size and packet count as follows:
;;;1819       * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
;;;1820       * pktcnt = N           */
;;;1821       if (ep->xfer_len == 0)
000022  b3eb              CBZ      r3,|L9.160|
;;;1822       {
;;;1823         deptsiz.b.xfersize = ep->maxpacket;
;;;1824         deptsiz.b.pktcnt = 1;
;;;1825       }
;;;1826       else
;;;1827       {
;;;1828         ep->xfer_len = ep->maxpacket;
000024  688b              LDR      r3,[r1,#8]
000026  614b              STR      r3,[r1,#0x14]
;;;1829         deptsiz.b.xfersize = ep->maxpacket;
000028  f3630206          BFI      r2,r3,#0,#7
;;;1830         deptsiz.b.pktcnt = 1;
00002c  f4422200          ORR      r2,r2,#0x80000
000030  9200              STR      r2,[sp,#0]
                  |L9.50|
;;;1831       }
;;;1832       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
000032  6d63              LDR      r3,[r4,#0x54]
000034  9a00              LDR      r2,[sp,#0]
000036  611a              STR      r2,[r3,#0x10]
;;;1833       if (pdev->cfg.dma_enable == 1)
000038  78c2              LDRB     r2,[r0,#3]
00003a  2a01              CMP      r2,#1
00003c  d041              BEQ      |L9.194|
00003e  e046              B        |L9.206|
                  |L9.64|
000040  6982              LDR      r2,[r0,#0x18]         ;1764
000042  6817              LDR      r7,[r2,#0]            ;1765
000044  9701              STR      r7,[sp,#4]            ;1765
000046  6914              LDR      r4,[r2,#0x10]         ;1766
000048  9400              STR      r4,[sp,#0]            ;1766
00004a  b13b              CBZ      r3,|L9.92|
00004c  688d              LDR      r5,[r1,#8]            ;1776
00004e  42ab              CMP      r3,r5                 ;1776
000050  d90a              BLS      |L9.104|
000052  614d              STR      r5,[r1,#0x14]         ;1778
000054  f3650406          BFI      r4,r5,#0,#7           ;1779
000058  9400              STR      r4,[sp,#0]            ;1779
00005a  e008              B        |L9.110|
                  |L9.92|
00005c  f024037f          BIC      r3,r4,#0x7f           ;1770
000060  f4432300          ORR      r3,r3,#0x80000        ;1771
000064  9300              STR      r3,[sp,#0]            ;1771
000066  e006              B        |L9.118|
                  |L9.104|
000068  f3630406          BFI      r4,r3,#0,#7           ;1783
00006c  9400              STR      r4,[sp,#0]            ;1783
                  |L9.110|
00006e  9b00              LDR      r3,[sp,#0]            ;1785
000070  f4432300          ORR      r3,r3,#0x80000        ;1785
000074  9300              STR      r3,[sp,#0]            ;1785
                  |L9.118|
000076  9b00              LDR      r3,[sp,#0]            ;1787
000078  6113              STR      r3,[r2,#0x10]         ;1787
00007a  78c3              LDRB     r3,[r0,#3]            ;1789
00007c  2b01              CMP      r3,#1                 ;1789
00007e  d105              BNE      |L9.140|
000080  780c              LDRB     r4,[r1,#0]            ;1791
000082  690b              LDR      r3,[r1,#0x10]         ;1791
000084  eb000484          ADD      r4,r0,r4,LSL #2       ;1791
000088  69a4              LDR      r4,[r4,#0x18]         ;1791
00008a  6163              STR      r3,[r4,#0x14]         ;1791
                  |L9.140|
00008c  f0476380          ORR      r3,r7,#0x4000000      ;1795
000090  f0434300          ORR      r3,r3,#0x80000000     ;1796
000094  9301              STR      r3,[sp,#4]            ;1796
000096  6013              STR      r3,[r2,#0]            ;1797
000098  78c2              LDRB     r2,[r0,#3]            ;1801
00009a  bb12              CBNZ     r2,|L9.226|
00009c  694a              LDR      r2,[r1,#0x14]         ;1804
00009e  e000              B        |L9.162|
                  |L9.160|
0000a0  e008              B        |L9.180|
                  |L9.162|
0000a2  b1f2              CBZ      r2,|L9.226|
0000a4  780a              LDRB     r2,[r1,#0]            ;1807
0000a6  2101              MOVS     r1,#1                 ;1807
0000a8  4091              LSLS     r1,r1,r2              ;1807
0000aa  6900              LDR      r0,[r0,#0x10]         ;1808
0000ac  6b42              LDR      r2,[r0,#0x34]         ;1808
0000ae  430a              ORRS     r2,r2,r1              ;1808
0000b0  6342              STR      r2,[r0,#0x34]         ;1808
0000b2  e016              B        |L9.226|
                  |L9.180|
0000b4  7a0b              LDRB     r3,[r1,#8]            ;1823
0000b6  f3630206          BFI      r2,r3,#0,#7           ;1823
0000ba  f4422200          ORR      r2,r2,#0x80000        ;1824
0000be  9200              STR      r2,[sp,#0]            ;1824
0000c0  e7b7              B        |L9.50|
                  |L9.194|
;;;1834       {
;;;1835         USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
0000c2  780b              LDRB     r3,[r1,#0]
0000c4  690a              LDR      r2,[r1,#0x10]
0000c6  eb000383          ADD      r3,r0,r3,LSL #2
0000ca  6d5b              LDR      r3,[r3,#0x54]
0000cc  615a              STR      r2,[r3,#0x14]
                  |L9.206|
;;;1836       }
;;;1837       /* EP enable */
;;;1838       depctl.b.cnak = 1;
0000ce  f0456280          ORR      r2,r5,#0x4000000
;;;1839       depctl.b.epena = 1;
0000d2  f0424200          ORR      r2,r2,#0x80000000
0000d6  9201              STR      r2,[sp,#4]
;;;1840       USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
0000d8  7809              LDRB     r1,[r1,#0]
0000da  eb000081          ADD      r0,r0,r1,LSL #2
0000de  6d40              LDR      r0,[r0,#0x54]
0000e0  6002              STR      r2,[r0,#0]
                  |L9.226|
;;;1841       
;;;1842     }
;;;1843     return status;
0000e2  4630              MOV      r0,r6
;;;1844   }
0000e4  bdfc              POP      {r2-r7,pc}
;;;1845   
                          ENDP


                          AREA ||i.USB_OTG_EP0_OutStart||, CODE, READONLY, ALIGN=2

                  USB_OTG_EP0_OutStart PROC
;;;1962   */
;;;1963   void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
000000  b50c              PUSH     {r2,r3,lr}
;;;1964   {
;;;1965     USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
;;;1966     doeptsize0.d32 = 0;
;;;1967     doeptsize0.b.supcnt = 3;
;;;1968     doeptsize0.b.pktcnt = 1;
;;;1969     doeptsize0.b.xfersize = 8 * 3;
000002  4909              LDR      r1,|L10.40|
000004  9101              STR      r1,[sp,#4]
;;;1970     USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
000006  6d42              LDR      r2,[r0,#0x54]
000008  6111              STR      r1,[r2,#0x10]
;;;1971     
;;;1972     if (pdev->cfg.dma_enable == 1)
00000a  78c1              LDRB     r1,[r0,#3]
00000c  2901              CMP      r1,#1
00000e  d109              BNE      |L10.36|
;;;1973     {
;;;1974       USB_OTG_DEPCTL_TypeDef  doepctl;
;;;1975       doepctl.d32 = 0;
;;;1976       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
000010  6d42              LDR      r2,[r0,#0x54]
000012  f20051cc          ADD      r1,r0,#0x5cc
000016  6151              STR      r1,[r2,#0x14]
;;;1977                           (uint32_t)&pdev->dev.setup_packet);
;;;1978       
;;;1979       /* EP enable */
;;;1980       doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
000018  6d41              LDR      r1,[r0,#0x54]
00001a  6808              LDR      r0,[r1,#0]
;;;1981       doepctl.b.epena = 1;
;;;1982       doepctl.d32 = 0x80008000;
00001c  f04f2080          MOV      r0,#0x80008000
000020  9000              STR      r0,[sp,#0]
;;;1983       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
000022  6008              STR      r0,[r1,#0]
                  |L10.36|
;;;1984     }
;;;1985   }
000024  bd0c              POP      {r2,r3,pc}
;;;1986   
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x60080018

                          AREA ||i.USB_OTG_EPActivate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPActivate PROC
;;;1524   */
;;;1525   USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b57c              PUSH     {r2-r6,lr}
;;;1526   {
;;;1527     USB_OTG_STS status = USB_OTG_OK;
000002  2500              MOVS     r5,#0
;;;1528     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1529     USB_OTG_DAINT_TypeDef  daintmsk;
;;;1530     __IO uint32_t *addr;
;;;1531     
;;;1532     
;;;1533     depctl.d32 = 0;
000004  2200              MOVS     r2,#0
000006  9201              STR      r2,[sp,#4]
;;;1534     daintmsk.d32 = 0;
000008  9200              STR      r2,[sp,#0]
;;;1535     /* Read DEPCTLn register */
;;;1536     if (ep->is_in == 1)
;;;1537     {
;;;1538       addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
00000a  780c              LDRB     r4,[r1,#0]
00000c  784e              LDRB     r6,[r1,#1]            ;1536
00000e  2301              MOVS     r3,#1                 ;1536
;;;1539       daintmsk.ep.in = 1 << ep->num;
000010  40a3              LSLS     r3,r3,r4
000012  eb000284          ADD      r2,r0,r4,LSL #2       ;1538
000016  2e01              CMP      r6,#1                 ;1536
000018  d01c              BEQ      |L11.84|
;;;1540     }
;;;1541     else
;;;1542     {
;;;1543       addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
00001a  6d52              LDR      r2,[r2,#0x54]
;;;1544       daintmsk.ep.out = 1 << ep->num;
00001c  f8ad3002          STRH     r3,[sp,#2]
                  |L11.32|
;;;1545     }
;;;1546     /* If the EP is already active don't change the EP Control
;;;1547     * register. */
;;;1548     depctl.d32 = USB_OTG_READ_REG32(addr);
000020  6813              LDR      r3,[r2,#0]
000022  9301              STR      r3,[sp,#4]
;;;1549     if (!depctl.b.usbactep)
000024  041c              LSLS     r4,r3,#16
000026  d40e              BMI      |L11.70|
;;;1550     {
;;;1551       depctl.b.mps    = ep->maxpacket;
000028  890c              LDRH     r4,[r1,#8]
00002a  f364030a          BFI      r3,r4,#0,#11
;;;1552       depctl.b.eptype = ep->type;
00002e  78cc              LDRB     r4,[r1,#3]
000030  f3644393          BFI      r3,r4,#18,#2
;;;1553       depctl.b.txfnum = ep->tx_fifo_num;
000034  7989              LDRB     r1,[r1,#6]
000036  f3615399          BFI      r3,r1,#22,#4
;;;1554       depctl.b.setd0pid = 1;
00003a  f0435180          ORR      r1,r3,#0x10000000
;;;1555       depctl.b.usbactep = 1;
00003e  f4414100          ORR      r1,r1,#0x8000
000042  9101              STR      r1,[sp,#4]
;;;1556       USB_OTG_WRITE_REG32(addr, depctl.d32);
000044  6011              STR      r1,[r2,#0]
                  |L11.70|
;;;1557     }
;;;1558     /* Enable the Interrupt for this EP */
;;;1559   #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
;;;1560     if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
;;;1561     {
;;;1562       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
;;;1563     }
;;;1564     else
;;;1565   #endif   
;;;1566       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
000046  6900              LDR      r0,[r0,#0x10]
000048  69c1              LDR      r1,[r0,#0x1c]
00004a  9a00              LDR      r2,[sp,#0]
00004c  4311              ORRS     r1,r1,r2
00004e  61c1              STR      r1,[r0,#0x1c]
;;;1567     return status;
000050  4628              MOV      r0,r5
;;;1568   }
000052  bd7c              POP      {r2-r6,pc}
                  |L11.84|
000054  6992              LDR      r2,[r2,#0x18]         ;1538
000056  f8ad3000          STRH     r3,[sp,#0]            ;1539
00005a  e7e1              B        |L11.32|
;;;1569   
                          ENDP


                          AREA ||i.USB_OTG_EPClearStall||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPClearStall PROC
;;;1887   */
;;;1888   USB_OTG_STS USB_OTG_EPClearStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b518              PUSH     {r3,r4,lr}
;;;1889   {
000002  4603              MOV      r3,r0
;;;1890     USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;1891     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1892     __IO uint32_t *depctl_addr;
;;;1893     
;;;1894     depctl.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;1895     
;;;1896     if (ep->is_in == 1)
00000a  784c              LDRB     r4,[r1,#1]
;;;1897     {
;;;1898       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
00000c  780a              LDRB     r2,[r1,#0]
00000e  2c01              CMP      r4,#1                 ;1896
000010  eb030282          ADD      r2,r3,r2,LSL #2
000014  d00a              BEQ      |L12.44|
;;;1899     }
;;;1900     else
;;;1901     {
;;;1902       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
000016  6d52              LDR      r2,[r2,#0x54]
                  |L12.24|
;;;1903     }
;;;1904     depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
000018  6813              LDR      r3,[r2,#0]
;;;1905     /* clear the stall bits */
;;;1906     depctl.b.stall = 0;
00001a  f4231300          BIC      r3,r3,#0x200000
00001e  9300              STR      r3,[sp,#0]
;;;1907     if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
000020  78c9              LDRB     r1,[r1,#3]
000022  2903              CMP      r1,#3
000024  d004              BEQ      |L12.48|
000026  2902              CMP      r1,#2
000028  d002              BEQ      |L12.48|
00002a  e004              B        |L12.54|
                  |L12.44|
00002c  6992              LDR      r2,[r2,#0x18]         ;1898
00002e  e7f3              B        |L12.24|
                  |L12.48|
;;;1908     {
;;;1909       depctl.b.setd0pid = 1; /* DATA0 */
000030  f0435180          ORR      r1,r3,#0x10000000
000034  9100              STR      r1,[sp,#0]
                  |L12.54|
;;;1910     }
;;;1911     USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
000036  9900              LDR      r1,[sp,#0]
000038  6011              STR      r1,[r2,#0]
;;;1912     return status;
;;;1913   }
00003a  bd18              POP      {r3,r4,pc}
;;;1914   
                          ENDP


                          AREA ||i.USB_OTG_EPDeactivate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPDeactivate PROC
;;;1575   */
;;;1576   USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b53c              PUSH     {r2-r5,lr}
;;;1577   {
;;;1578     USB_OTG_STS status = USB_OTG_OK;
;;;1579     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1580     USB_OTG_DAINT_TypeDef  daintmsk;
;;;1581     __IO uint32_t *addr;
;;;1582     
;;;1583     depctl.d32 = 0;
000002  2400              MOVS     r4,#0
000004  9401              STR      r4,[sp,#4]
;;;1584     daintmsk.d32 = 0;  
000006  9400              STR      r4,[sp,#0]
;;;1585     /* Read DEPCTLn register */
;;;1586     if (ep->is_in == 1)
;;;1587     {
;;;1588       addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
000008  780b              LDRB     r3,[r1,#0]
00000a  784d              LDRB     r5,[r1,#1]            ;1586
00000c  2201              MOVS     r2,#1                 ;1586
;;;1589       daintmsk.ep.in = 1 << ep->num;
00000e  409a              LSLS     r2,r2,r3
000010  eb000183          ADD      r1,r0,r3,LSL #2       ;1588
000014  2d01              CMP      r5,#1                 ;1586
000016  d00a              BEQ      |L13.46|
;;;1590     }
;;;1591     else
;;;1592     {
;;;1593       addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
000018  6d49              LDR      r1,[r1,#0x54]
;;;1594       daintmsk.ep.out = 1 << ep->num;
00001a  f8ad2002          STRH     r2,[sp,#2]
                  |L13.30|
;;;1595     }
;;;1596     depctl.b.usbactep = 0;
;;;1597     USB_OTG_WRITE_REG32(addr, depctl.d32);
00001e  600c              STR      r4,[r1,#0]
;;;1598     /* Disable the Interrupt for this EP */
;;;1599     
;;;1600   #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
;;;1601     if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
;;;1602     {
;;;1603       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
;;;1604     }
;;;1605     else
;;;1606   #endif    
;;;1607       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
000020  6900              LDR      r0,[r0,#0x10]
000022  69c1              LDR      r1,[r0,#0x1c]
000024  9a00              LDR      r2,[sp,#0]
000026  4391              BICS     r1,r1,r2
000028  61c1              STR      r1,[r0,#0x1c]
;;;1608     return status;
00002a  4620              MOV      r0,r4
;;;1609   }
00002c  bd3c              POP      {r2-r5,pc}
                  |L13.46|
00002e  6989              LDR      r1,[r1,#0x18]         ;1588
000030  f8ad2000          STRH     r2,[sp,#0]            ;1589
000034  e7f3              B        |L13.30|
;;;1610   
                          ENDP


                          AREA ||i.USB_OTG_EPSetStall||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPSetStall PROC
;;;1851   */
;;;1852   USB_OTG_STS USB_OTG_EPSetStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b508              PUSH     {r3,lr}
;;;1853   {
000002  4602              MOV      r2,r0
;;;1854     USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;1855     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1856     __IO uint32_t *depctl_addr;
;;;1857     
;;;1858     depctl.d32 = 0;
000006  2300              MOVS     r3,#0
000008  9300              STR      r3,[sp,#0]
;;;1859     if (ep->is_in == 1)
00000a  784b              LDRB     r3,[r1,#1]
;;;1860     {
;;;1861       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
00000c  7809              LDRB     r1,[r1,#0]
00000e  2b01              CMP      r3,#1                 ;1859
000010  eb020181          ADD      r1,r2,r1,LSL #2
000014  d006              BEQ      |L14.36|
;;;1862       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
;;;1863       /* set the disable and stall bits */
;;;1864       if (depctl.b.epena)
;;;1865       {
;;;1866         depctl.b.epdis = 1;
;;;1867       }
;;;1868       depctl.b.stall = 1;
;;;1869       USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
;;;1870     }
;;;1871     else
;;;1872     {
;;;1873       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
000016  6d49              LDR      r1,[r1,#0x54]
;;;1874       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
000018  680a              LDR      r2,[r1,#0]
;;;1875       /* set the stall bit */
;;;1876       depctl.b.stall = 1;
00001a  f4421200          ORR      r2,r2,#0x200000
00001e  9200              STR      r2,[sp,#0]
;;;1877       USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
000020  600a              STR      r2,[r1,#0]
;;;1878     }
;;;1879     return status;
;;;1880   }
000022  bd08              POP      {r3,pc}
                  |L14.36|
000024  698a              LDR      r2,[r1,#0x18]         ;1861
000026  6811              LDR      r1,[r2,#0]            ;1862
000028  9100              STR      r1,[sp,#0]            ;1862
00002a  2900              CMP      r1,#0                 ;1864
00002c  da02              BGE      |L14.52|
00002e  f0414180          ORR      r1,r1,#0x40000000     ;1866
000032  9100              STR      r1,[sp,#0]            ;1866
                  |L14.52|
000034  9900              LDR      r1,[sp,#0]            ;1868
000036  f4411100          ORR      r1,r1,#0x200000       ;1868
00003a  9100              STR      r1,[sp,#0]            ;1868
00003c  6011              STR      r1,[r2,#0]            ;1869
00003e  bd08              POP      {r3,pc}
;;;1881   
                          ENDP


                          AREA ||i.USB_OTG_EPStartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPStartXfer PROC
;;;1617   */
;;;1618   USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1619   {
;;;1620     USB_OTG_STS status = USB_OTG_OK;
000002  2500              MOVS     r5,#0
;;;1621     USB_OTG_DEPCTL_TypeDef     depctl;
;;;1622     USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
;;;1623     USB_OTG_DSTS_TypeDef       dsts;    
;;;1624     uint32_t fifoemptymsk = 0;  
;;;1625     
;;;1626     depctl.d32 = 0;
000004  2200              MOVS     r2,#0
000006  9202              STR      r2,[sp,#8]
;;;1627     deptsiz.d32 = 0;
000008  9201              STR      r2,[sp,#4]
;;;1628     /* IN endpoint */
;;;1629     if (ep->is_in == 1)
00000a  784c              LDRB     r4,[r1,#1]
;;;1630     {
;;;1631       depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
00000c  780b              LDRB     r3,[r1,#0]
00000e  694a              LDR      r2,[r1,#0x14]         ;1629
000010  f04f0c01          MOV      r12,#1                ;1629
000014  eb000383          ADD      r3,r0,r3,LSL #2
000018  2c01              CMP      r4,#1                 ;1629
00001a  d01d              BEQ      |L15.88|
;;;1632       deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
;;;1633       /* Zero Length Packet? */
;;;1634       if (ep->xfer_len == 0)
;;;1635       {
;;;1636         deptsiz.b.xfersize = 0;
;;;1637         deptsiz.b.pktcnt = 1;
;;;1638       }
;;;1639       else
;;;1640       {
;;;1641         /* Program the transfer size and packet count
;;;1642         * as follows: xfersize = N * maxpacket +
;;;1643         * short_packet pktcnt = N + (short_packet
;;;1644         * exist ? 1 : 0)
;;;1645         */
;;;1646         deptsiz.b.xfersize = ep->xfer_len;
;;;1647         deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
;;;1648         
;;;1649         if (ep->type == EP_TYPE_ISOC)
;;;1650         {
;;;1651           deptsiz.b.mc = 1;
;;;1652         }       
;;;1653       }
;;;1654       USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
;;;1655       
;;;1656       if (pdev->cfg.dma_enable == 1)
;;;1657       {
;;;1658         USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
;;;1659       }
;;;1660       else
;;;1661       {
;;;1662         if (ep->type != EP_TYPE_ISOC)
;;;1663         {
;;;1664           /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;1665           if (ep->xfer_len > 0)
;;;1666           {
;;;1667             fifoemptymsk = 1 << ep->num;
;;;1668             USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
;;;1669           }
;;;1670         }
;;;1671       }
;;;1672       
;;;1673       
;;;1674       if (ep->type == EP_TYPE_ISOC)
;;;1675       {
;;;1676         dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
;;;1677         
;;;1678         if (((dsts.b.soffn)&0x1) == 0)
;;;1679         {
;;;1680           depctl.b.setd1pid = 1;
;;;1681         }
;;;1682         else
;;;1683         {
;;;1684           depctl.b.setd0pid = 1;
;;;1685         }
;;;1686       } 
;;;1687       
;;;1688       /* EP enable, IN data in FIFO */
;;;1689       depctl.b.cnak = 1;
;;;1690       depctl.b.epena = 1;
;;;1691       USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
;;;1692       
;;;1693       if (ep->type == EP_TYPE_ISOC)
;;;1694       {
;;;1695         USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
;;;1696       }    
;;;1697     }
;;;1698     else
;;;1699     {
;;;1700       /* OUT endpoint */
;;;1701       depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
00001c  6d5c              LDR      r4,[r3,#0x54]
00001e  6826              LDR      r6,[r4,#0]
000020  9602              STR      r6,[sp,#8]
;;;1702       deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
000022  6924              LDR      r4,[r4,#0x10]
000024  9401              STR      r4,[sp,#4]
;;;1703       /* Program the transfer size and packet count as follows:
;;;1704       * pktcnt = N
;;;1705       * xfersize = N * maxpacket
;;;1706       */
;;;1707       if (ep->xfer_len == 0)
000026  2a00              CMP      r2,#0
000028  d076              BEQ      |L15.280|
;;;1708       {
;;;1709         deptsiz.b.xfersize = ep->maxpacket;
;;;1710         deptsiz.b.pktcnt = 1;
;;;1711       }
;;;1712       else
;;;1713       {
;;;1714         deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
00002a  688f              LDR      r7,[r1,#8]
00002c  443a              ADD      r2,r2,r7
00002e  1e52              SUBS     r2,r2,#1
000030  fbb2f2f7          UDIV     r2,r2,r7
000034  f36244dc          BFI      r4,r2,#19,#10
;;;1715         deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
000038  f3c442c9          UBFX     r2,r4,#19,#10
00003c  437a              MULS     r2,r7,r2
00003e  f3620412          BFI      r4,r2,#0,#19
000042  9401              STR      r4,[sp,#4]
;;;1716         ep->xfer_len = deptsiz.b.xfersize ;
000044  f3c40212          UBFX     r2,r4,#0,#19
000048  614a              STR      r2,[r1,#0x14]
                  |L15.74|
;;;1717       }
;;;1718       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
00004a  6d5b              LDR      r3,[r3,#0x54]
00004c  9a01              LDR      r2,[sp,#4]
00004e  611a              STR      r2,[r3,#0x10]
;;;1719       
;;;1720       if (pdev->cfg.dma_enable == 1)
000050  78c2              LDRB     r2,[r0,#3]
000052  2a01              CMP      r2,#1
000054  d067              BEQ      |L15.294|
000056  e06c              B        |L15.306|
                  |L15.88|
000058  699b              LDR      r3,[r3,#0x18]         ;1631
00005a  681e              LDR      r6,[r3,#0]            ;1631
00005c  9602              STR      r6,[sp,#8]            ;1631
00005e  691c              LDR      r4,[r3,#0x10]         ;1632
000060  9401              STR      r4,[sp,#4]            ;1632
000062  b16a              CBZ      r2,|L15.128|
000064  f3620412          BFI      r4,r2,#0,#19          ;1646
000068  688f              LDR      r7,[r1,#8]            ;1647
00006a  443a              ADD      r2,r2,r7              ;1647
00006c  1e52              SUBS     r2,r2,#1              ;1647
00006e  fbb2f2f7          UDIV     r2,r2,r7              ;1647
000072  f36244dc          BFI      r4,r2,#19,#10         ;1647
000076  9401              STR      r4,[sp,#4]            ;1647
000078  78ca              LDRB     r2,[r1,#3]            ;1649
00007a  2a01              CMP      r2,#1                 ;1649
00007c  d006              BEQ      |L15.140|
00007e  e00a              B        |L15.150|
                  |L15.128|
000080  0ce2              LSRS     r2,r4,#19             ;1636
000082  04d2              LSLS     r2,r2,#19             ;1636
000084  f36c42dc          BFI      r2,r12,#19,#10        ;1637
000088  9201              STR      r2,[sp,#4]            ;1637
00008a  e004              B        |L15.150|
                  |L15.140|
00008c  f02442c0          BIC      r2,r4,#0x60000000     ;1651
000090  f1025200          ADD      r2,r2,#0x20000000     ;1651
000094  9201              STR      r2,[sp,#4]            ;1651
                  |L15.150|
000096  9a01              LDR      r2,[sp,#4]            ;1654
000098  611a              STR      r2,[r3,#0x10]         ;1654
00009a  78c2              LDRB     r2,[r0,#3]            ;1656
00009c  2a01              CMP      r2,#1                 ;1656
00009e  d010              BEQ      |L15.194|
0000a0  78ca              LDRB     r2,[r1,#3]            ;1662
0000a2  2a01              CMP      r2,#1                 ;1662
0000a4  d009              BEQ      |L15.186|
0000a6  694a              LDR      r2,[r1,#0x14]         ;1665
0000a8  b13a              CBZ      r2,|L15.186|
0000aa  780a              LDRB     r2,[r1,#0]            ;1667
0000ac  fa0cfc02          LSL      r12,r12,r2            ;1667
0000b0  6902              LDR      r2,[r0,#0x10]         ;1668
0000b2  6b53              LDR      r3,[r2,#0x34]         ;1668
0000b4  ea43030c          ORR      r3,r3,r12             ;1668
0000b8  6353              STR      r3,[r2,#0x34]         ;1668
                  |L15.186|
0000ba  78ca              LDRB     r2,[r1,#3]            ;1674
0000bc  2a01              CMP      r2,#1                 ;1674
0000be  d007              BEQ      |L15.208|
0000c0  e00f              B        |L15.226|
                  |L15.194|
0000c2  780b              LDRB     r3,[r1,#0]            ;1658
0000c4  690a              LDR      r2,[r1,#0x10]         ;1658
0000c6  eb000383          ADD      r3,r0,r3,LSL #2       ;1658
0000ca  699b              LDR      r3,[r3,#0x18]         ;1658
0000cc  615a              STR      r2,[r3,#0x14]         ;1658
0000ce  e7f4              B        |L15.186|
                  |L15.208|
0000d0  6902              LDR      r2,[r0,#0x10]         ;1676
0000d2  6892              LDR      r2,[r2,#8]            ;1676
0000d4  9200              STR      r2,[sp,#0]            ;1676
0000d6  0a12              LSRS     r2,r2,#8              ;1678
0000d8  07d2              LSLS     r2,r2,#31             ;1678
0000da  d011              BEQ      |L15.256|
0000dc  f0465280          ORR      r2,r6,#0x10000000     ;1684
0000e0  9202              STR      r2,[sp,#8]            ;1684
                  |L15.226|
0000e2  9a02              LDR      r2,[sp,#8]            ;1689
0000e4  f0426280          ORR      r2,r2,#0x4000000      ;1689
0000e8  f0424200          ORR      r2,r2,#0x80000000     ;1690
0000ec  9202              STR      r2,[sp,#8]            ;1690
0000ee  780b              LDRB     r3,[r1,#0]            ;1691
0000f0  eb000383          ADD      r3,r0,r3,LSL #2       ;1691
0000f4  699b              LDR      r3,[r3,#0x18]         ;1691
0000f6  601a              STR      r2,[r3,#0]            ;1691
0000f8  78ca              LDRB     r2,[r1,#3]            ;1693
0000fa  2a01              CMP      r2,#1                 ;1693
0000fc  d004              BEQ      |L15.264|
0000fe  e02f              B        |L15.352|
                  |L15.256|
000100  f0465200          ORR      r2,r6,#0x20000000     ;1680
000104  9202              STR      r2,[sp,#8]            ;1680
000106  e7ec              B        |L15.226|
                  |L15.264|
000108  8a8a              LDRH     r2,[r1,#0x14]         ;1695
00010a  b293              UXTH     r3,r2                 ;1695
00010c  780a              LDRB     r2,[r1,#0]            ;1695
00010e  68c9              LDR      r1,[r1,#0xc]          ;1695
000110  f7fffffe          BL       USB_OTG_WritePacket
000114  e024              B        |L15.352|
000116  e7ff              B        |L15.280|
                  |L15.280|
000118  688a              LDR      r2,[r1,#8]            ;1709
00011a  f3620412          BFI      r4,r2,#0,#19          ;1709
00011e  f36c44dc          BFI      r4,r12,#19,#10        ;1710
000122  9401              STR      r4,[sp,#4]            ;1710
000124  e791              B        |L15.74|
                  |L15.294|
;;;1721       {
;;;1722         USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
000126  780b              LDRB     r3,[r1,#0]
000128  690a              LDR      r2,[r1,#0x10]
00012a  eb000383          ADD      r3,r0,r3,LSL #2
00012e  6d5b              LDR      r3,[r3,#0x54]
000130  615a              STR      r2,[r3,#0x14]
                  |L15.306|
;;;1723       }
;;;1724       
;;;1725       if (ep->type == EP_TYPE_ISOC)
000132  78ca              LDRB     r2,[r1,#3]
000134  2a01              CMP      r2,#1
000136  d108              BNE      |L15.330|
;;;1726       {
;;;1727         if (ep->even_odd_frame)
000138  794a              LDRB     r2,[r1,#5]
00013a  b11a              CBZ      r2,|L15.324|
;;;1728         {
;;;1729           depctl.b.setd1pid = 1;
00013c  f0465200          ORR      r2,r6,#0x20000000
000140  9202              STR      r2,[sp,#8]
000142  e002              B        |L15.330|
                  |L15.324|
;;;1730         }
;;;1731         else
;;;1732         {
;;;1733           depctl.b.setd0pid = 1;
000144  f0465280          ORR      r2,r6,#0x10000000
000148  9202              STR      r2,[sp,#8]
                  |L15.330|
;;;1734         }
;;;1735       }
;;;1736       /* EP enable */
;;;1737       depctl.b.cnak = 1;
00014a  9a02              LDR      r2,[sp,#8]
00014c  f0426280          ORR      r2,r2,#0x4000000
;;;1738       depctl.b.epena = 1;
000150  f0424200          ORR      r2,r2,#0x80000000
000154  9202              STR      r2,[sp,#8]
;;;1739       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
000156  7809              LDRB     r1,[r1,#0]
000158  eb000081          ADD      r0,r0,r1,LSL #2
00015c  6d40              LDR      r0,[r0,#0x54]
00015e  6002              STR      r2,[r0,#0]
                  |L15.352|
;;;1740     }
;;;1741     return status;
000160  4628              MOV      r0,r5
;;;1742   }
000162  bdfe              POP      {r1-r7,pc}
;;;1743   
                          ENDP


                          AREA ||i.USB_OTG_EnableCommonInt||, CODE, READONLY, ALIGN=2

                  USB_OTG_EnableCommonInt PROC
;;;94     */
;;;95     static void USB_OTG_EnableCommonInt(USB_OTG_CORE_HANDLE *pdev)
000000  68c2              LDR      r2,[r0,#0xc]
;;;96     {
;;;97       USB_OTG_GINTMSK_TypeDef  int_mask;
;;;98       
;;;99       int_mask.d32 = 0;
;;;100      /* Clear any pending USB_OTG Interrupts */
;;;101    #ifndef USE_OTG_MODE
;;;102      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
000002  f04f31ff          MOV      r1,#0xffffffff
000006  6051              STR      r1,[r2,#4]
;;;103    #endif
;;;104      /* Clear any pending interrupts */
;;;105      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
000008  68c2              LDR      r2,[r0,#0xc]
00000a  f06f4180          MVN      r1,#0x40000000
00000e  6151              STR      r1,[r2,#0x14]
;;;106      /* Enable the interrupts in the INTMSK */
;;;107      int_mask.b.wkupintr = 1;
;;;108      int_mask.b.usbsuspend = 1; 
000010  4901              LDR      r1,|L16.24|
;;;109      
;;;110    #ifdef USE_OTG_MODE
;;;111      int_mask.b.otgintr = 1;
;;;112      int_mask.b.sessreqintr = 1;
;;;113      int_mask.b.conidstschng = 1;
;;;114    #endif
;;;115      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
000012  68c0              LDR      r0,[r0,#0xc]
000014  6181              STR      r1,[r0,#0x18]
;;;116    }
000016  4770              BX       lr
;;;117    
                          ENDP

                  |L16.24|
                          DCD      0x80000800

                          AREA ||i.USB_OTG_EnableDevInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableDevInt PROC
;;;1407   */
;;;1408   USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;1409   {
000002  4604              MOV      r4,r0
;;;1410     USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;1411     USB_OTG_GINTMSK_TypeDef  intmsk;
;;;1412     
;;;1413     intmsk.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1414     
;;;1415     /* Disable all interrupts. */
;;;1416     USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
00000a  68e1              LDR      r1,[r4,#0xc]
00000c  6188              STR      r0,[r1,#0x18]
;;;1417     /* Clear any pending interrupts */
;;;1418     USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
00000e  68e1              LDR      r1,[r4,#0xc]
000010  f06f4080          MVN      r0,#0x40000000
000014  6148              STR      r0,[r1,#0x14]
;;;1419     /* Enable the common interrupts */
;;;1420     USB_OTG_EnableCommonInt(pdev);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       USB_OTG_EnableCommonInt
;;;1421     
;;;1422     if (pdev->cfg.dma_enable == 0)
00001c  78e0              LDRB     r0,[r4,#3]
00001e  b908              CBNZ     r0,|L17.36|
;;;1423     {
;;;1424       intmsk.b.rxstsqlvl = 1;
000020  2010              MOVS     r0,#0x10
000022  9000              STR      r0,[sp,#0]
                  |L17.36|
;;;1425     }
;;;1426     
;;;1427     /* Enable interrupts matching to the Device mode ONLY */
;;;1428     intmsk.b.usbsuspend = 1;
000024  9800              LDR      r0,[sp,#0]
000026  f4406000          ORR      r0,r0,#0x800
;;;1429     intmsk.b.usbreset   = 1;
00002a  f4405080          ORR      r0,r0,#0x1000
;;;1430     intmsk.b.enumdone   = 1;
00002e  f4405000          ORR      r0,r0,#0x2000
;;;1431     intmsk.b.inepintr   = 1;
000032  f4402080          ORR      r0,r0,#0x40000
;;;1432     intmsk.b.outepintr  = 1;
000036  f4402000          ORR      r0,r0,#0x80000
;;;1433     intmsk.b.sofintr    = 1; 
00003a  f0400008          ORR      r0,r0,#8
;;;1434     
;;;1435     intmsk.b.incomplisoin    = 1; 
00003e  f4401080          ORR      r0,r0,#0x100000
;;;1436     intmsk.b.incomplisoout    = 1;   
000042  f4401000          ORR      r0,r0,#0x200000
;;;1437   #ifdef VBUS_SENSING_ENABLED
;;;1438     intmsk.b.sessreqintr    = 1; 
;;;1439     intmsk.b.otgintr    = 1;    
;;;1440   #endif  
;;;1441     USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
000046  68e1              LDR      r1,[r4,#0xc]
000048  698a              LDR      r2,[r1,#0x18]
00004a  4382              BICS     r2,r2,r0
00004c  4302              ORRS     r2,r2,r0
00004e  618a              STR      r2,[r1,#0x18]
;;;1442     return status;
000050  4628              MOV      r0,r5
;;;1443   }
000052  bd38              POP      {r3-r5,pc}
;;;1444   
                          ENDP


                          AREA ||i.USB_OTG_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableGlobalInt PROC
;;;448    */
;;;449    USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  2200              MOVS     r2,#0
;;;450    {
;;;451      USB_OTG_STS status = USB_OTG_OK;
;;;452      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;453      
;;;454      ahbcfg.d32 = 0;
;;;455      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;456      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
000002  68c0              LDR      r0,[r0,#0xc]
000004  6881              LDR      r1,[r0,#8]
000006  f0410101          ORR      r1,r1,#1
00000a  6081              STR      r1,[r0,#8]
;;;457      return status;
00000c  4610              MOV      r0,r2
;;;458    }
00000e  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.USB_OTG_EnableHostInt||, CODE, READONLY, ALIGN=2

                  USB_OTG_EnableHostInt PROC
;;;780    */
;;;781    USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;782    {
000002  4604              MOV      r4,r0
;;;783      USB_OTG_STS       status = USB_OTG_OK;
;;;784      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;785      intmsk.d32 = 0;
000004  2500              MOVS     r5,#0
000006  9500              STR      r5,[sp,#0]
;;;786      /* Disable all interrupts. */
;;;787      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
000008  68e0              LDR      r0,[r4,#0xc]
00000a  6185              STR      r5,[r0,#0x18]
;;;788      
;;;789      /* Clear any pending interrupts. */
;;;790      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
00000c  68e1              LDR      r1,[r4,#0xc]
00000e  1e68              SUBS     r0,r5,#1
000010  6148              STR      r0,[r1,#0x14]
;;;791      
;;;792      /* Enable the common interrupts */
;;;793      USB_OTG_EnableCommonInt(pdev);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USB_OTG_EnableCommonInt
;;;794      
;;;795      if (pdev->cfg.dma_enable == 0)
000018  78e0              LDRB     r0,[r4,#3]
00001a  b908              CBNZ     r0,|L19.32|
;;;796      {  
;;;797        intmsk.b.rxstsqlvl  = 1;
00001c  2010              MOVS     r0,#0x10
00001e  9000              STR      r0,[sp,#0]
                  |L19.32|
;;;798      }  
;;;799      
;;;800    
;;;801      intmsk.b.incomplisoout  = 1;
000020  9800              LDR      r0,[sp,#0]
000022  f4401000          ORR      r0,r0,#0x200000
;;;802      intmsk.b.hcintr     = 1; 
000026  f0407000          ORR      r0,r0,#0x2000000
;;;803    intmsk.b.portintr   = 1;
00002a  f0407080          ORR      r0,r0,#0x1000000
;;;804      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
00002e  68e1              LDR      r1,[r4,#0xc]
000030  698a              LDR      r2,[r1,#0x18]
000032  4382              BICS     r2,r2,r0
000034  4302              ORRS     r2,r2,r0
000036  618a              STR      r2,[r1,#0x18]
;;;805     
;;;806      intmsk.d32 = 0;
;;;807     
;;;808      intmsk.b.disconnect = 1;  
;;;809      
;;;810      intmsk.b.sofintr    = 1; 
000038  4903              LDR      r1,|L19.72|
;;;811      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  6982              LDR      r2,[r0,#0x18]
00003e  438a              BICS     r2,r2,r1
000040  6182              STR      r2,[r0,#0x18]
;;;812      return status;
000042  4628              MOV      r0,r5
;;;813    }
000044  bd38              POP      {r3-r5,pc}
;;;814    
                          ENDP

000046  0000              DCW      0x0000
                  |L19.72|
                          DCD      0x20000008

                          AREA ||i.USB_OTG_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushRxFifo PROC
;;;513    */
;;;514    USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
000000  b538              PUSH     {r3-r5,lr}
;;;515    {
;;;516      USB_OTG_STS status = USB_OTG_OK;
000002  2500              MOVS     r5,#0
;;;517      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;518      uint32_t count = 0;
000004  2100              MOVS     r1,#0
;;;519      
;;;520      greset.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;521      greset.b.rxfflsh = 1;
00000a  9a00              LDR      r2,[sp,#0]
00000c  f0420210          ORR      r2,r2,#0x10
000010  9200              STR      r2,[sp,#0]
;;;522      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000012  9a00              LDR      r2,[sp,#0]
000014  68c3              LDR      r3,[r0,#0xc]
000016  611a              STR      r2,[r3,#0x10]
;;;523      do
;;;524      {
;;;525        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;526        if (++count > 200000)
000018  4b07              LDR      r3,|L20.56|
00001a  68c2              LDR      r2,[r0,#0xc]          ;522
                  |L20.28|
00001c  6914              LDR      r4,[r2,#0x10]         ;525
00001e  9400              STR      r4,[sp,#0]            ;525
000020  1c49              ADDS     r1,r1,#1
000022  4299              CMP      r1,r3
000024  d802              BHI      |L20.44|
;;;527        {
;;;528          break;
;;;529        }
;;;530      }
;;;531      while (greset.b.rxfflsh == 1);
000026  9c00              LDR      r4,[sp,#0]
000028  06e0              LSLS     r0,r4,#27
00002a  d4f7              BMI      |L20.28|
                  |L20.44|
;;;532      /* Wait for 3 PHY Clocks*/
;;;533      USB_OTG_BSP_uDelay(3);
00002c  2003              MOVS     r0,#3
00002e  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;534      return status;
000032  4628              MOV      r0,r5
;;;535    }
000034  bd38              POP      {r3-r5,pc}
;;;536    
                          ENDP

000036  0000              DCW      0x0000
                  |L20.56|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushTxFifo PROC
;;;483    */
;;;484    USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
000000  b538              PUSH     {r3-r5,lr}
;;;485    {
;;;486      USB_OTG_STS status = USB_OTG_OK;
000002  2500              MOVS     r5,#0
;;;487      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;488      
;;;489      uint32_t count = 0;
000004  2200              MOVS     r2,#0
;;;490      greset.d32 = 0;
000006  2300              MOVS     r3,#0
000008  9300              STR      r3,[sp,#0]
;;;491      greset.b.txfflsh = 1;
00000a  9b00              LDR      r3,[sp,#0]
00000c  f0430320          ORR      r3,r3,#0x20
000010  9300              STR      r3,[sp,#0]
;;;492      greset.b.txfnum  = num;
000012  9b00              LDR      r3,[sp,#0]
000014  f361138a          BFI      r3,r1,#6,#5
000018  9300              STR      r3,[sp,#0]
;;;493      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
00001a  9900              LDR      r1,[sp,#0]
00001c  68c3              LDR      r3,[r0,#0xc]
00001e  6119              STR      r1,[r3,#0x10]
;;;494      do
;;;495      {
;;;496        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;497        if (++count > 200000)
000020  4b07              LDR      r3,|L21.64|
000022  68c1              LDR      r1,[r0,#0xc]          ;493
                  |L21.36|
000024  690c              LDR      r4,[r1,#0x10]         ;496
000026  9400              STR      r4,[sp,#0]            ;496
000028  1c52              ADDS     r2,r2,#1
00002a  429a              CMP      r2,r3
00002c  d802              BHI      |L21.52|
;;;498        {
;;;499          break;
;;;500        }
;;;501      }
;;;502      while (greset.b.txfflsh == 1);
00002e  9c00              LDR      r4,[sp,#0]
000030  06a0              LSLS     r0,r4,#26
000032  d4f7              BMI      |L21.36|
                  |L21.52|
;;;503      /* Wait for 3 PHY Clocks*/
;;;504      USB_OTG_BSP_uDelay(3);
000034  2003              MOVS     r0,#3
000036  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;505      return status;
00003a  4628              MOV      r0,r5
;;;506    }
00003c  bd38              POP      {r3-r5,pc}
;;;507    
                          ENDP

00003e  0000              DCW      0x0000
                  |L21.64|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_GetDeviceSpeed||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetDeviceSpeed PROC
;;;1451   */
;;;1452   enum USB_OTG_SPEED USB_OTG_GetDeviceSpeed (USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;1453   {
;;;1454     USB_OTG_DSTS_TypeDef  dsts;
;;;1455     enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
;;;1456     
;;;1457     
;;;1458     dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
000002  6900              LDR      r0,[r0,#0x10]
000004  6880              LDR      r0,[r0,#8]
000006  9000              STR      r0,[sp,#0]
;;;1459     
;;;1460     switch (dsts.b.enumspd)
000008  f3c00041          UBFX     r0,r0,#1,#2
00000c  2800              CMP      r0,#0
00000e  d007              BEQ      |L22.32|
000010  2801              CMP      r0,#1
000012  d007              BEQ      |L22.36|
000014  2802              CMP      r0,#2
000016  d007              BEQ      |L22.40|
000018  2803              CMP      r0,#3
00001a  d003              BEQ      |L22.36|
;;;1461     {
;;;1462     case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
;;;1463       speed = USB_SPEED_HIGH;
;;;1464       break;
;;;1465     case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
;;;1466     case DSTS_ENUMSPD_FS_PHY_48MHZ:
;;;1467       speed = USB_SPEED_FULL;
;;;1468       break;
;;;1469       
;;;1470     case DSTS_ENUMSPD_LS_PHY_6MHZ:
;;;1471       speed = USB_SPEED_LOW;
;;;1472       break;
;;;1473     default:
;;;1474       speed = USB_SPEED_FULL;
00001c  2002              MOVS     r0,#2
;;;1475       break; 
;;;1476     }
;;;1477     
;;;1478     return speed;
;;;1479   }
00001e  bd08              POP      {r3,pc}
                  |L22.32|
000020  2003              MOVS     r0,#3                 ;1463
000022  bd08              POP      {r3,pc}
                  |L22.36|
000024  2002              MOVS     r0,#2                 ;1467
000026  bd08              POP      {r3,pc}
                  |L22.40|
000028  2001              MOVS     r0,#1                 ;1471
00002a  bd08              POP      {r3,pc}
;;;1480   
                          ENDP


                          AREA ||i.USB_OTG_GetEPStatus||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetEPStatus PROC
;;;2083   
;;;2084   uint32_t USB_OTG_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,USB_OTG_EP *ep)
000000  b508              PUSH     {r3,lr}
;;;2085   {
;;;2086     USB_OTG_DEPCTL_TypeDef  depctl;
;;;2087     __IO uint32_t *depctl_addr;
;;;2088     uint32_t Status = 0;  
;;;2089     
;;;2090     depctl.d32 = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;2091     if (ep->is_in == 1)
000006  784a              LDRB     r2,[r1,#1]
;;;2092     {
;;;2093       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000008  7809              LDRB     r1,[r1,#0]
00000a  2a01              CMP      r2,#1                 ;2091
00000c  eb000081          ADD      r0,r0,r1,LSL #2
000010  d007              BEQ      |L23.34|
;;;2094       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
;;;2095       
;;;2096       if (depctl.b.stall == 1)
;;;2097       {
;;;2098         Status = USB_OTG_EP_TX_STALL;
;;;2099       }
;;;2100       else if (depctl.b.naksts == 1)
;;;2101       {
;;;2102         Status = USB_OTG_EP_TX_NAK;
;;;2103       }
;;;2104       else 
;;;2105       {
;;;2106         Status = USB_OTG_EP_TX_VALID;     
;;;2107       }
;;;2108     }
;;;2109     else
;;;2110     {
;;;2111       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
000012  6d40              LDR      r0,[r0,#0x54]
;;;2112       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
000014  6800              LDR      r0,[r0,#0]
000016  9000              STR      r0,[sp,#0]
;;;2113       if (depctl.b.stall == 1)
000018  0281              LSLS     r1,r0,#10
00001a  d50f              BPL      |L23.60|
;;;2114       {
;;;2115         Status = USB_OTG_EP_RX_STALL;
00001c  f44f5080          MOV      r0,#0x1000
;;;2116       }
;;;2117       else if (depctl.b.naksts == 1)
;;;2118       {
;;;2119         Status = USB_OTG_EP_RX_NAK;
;;;2120       }
;;;2121       else 
;;;2122       {
;;;2123         Status = USB_OTG_EP_RX_VALID; 
;;;2124       }
;;;2125     } 
;;;2126     
;;;2127     /* Return the current status */
;;;2128     return Status;
;;;2129   }
000020  bd08              POP      {r3,pc}
                  |L23.34|
000022  6980              LDR      r0,[r0,#0x18]         ;2093
000024  6800              LDR      r0,[r0,#0]            ;2094
000026  9000              STR      r0,[sp,#0]            ;2094
000028  0281              LSLS     r1,r0,#10             ;2096
00002a  d501              BPL      |L23.48|
00002c  2010              MOVS     r0,#0x10              ;2098
00002e  bd08              POP      {r3,pc}
                  |L23.48|
000030  0380              LSLS     r0,r0,#14             ;2100
000032  d501              BPL      |L23.56|
000034  2020              MOVS     r0,#0x20              ;2102
000036  bd08              POP      {r3,pc}
                  |L23.56|
000038  2030              MOVS     r0,#0x30              ;2106
00003a  bd08              POP      {r3,pc}
                  |L23.60|
00003c  0380              LSLS     r0,r0,#14             ;2117
00003e  d502              BPL      |L23.70|
000040  f44f5000          MOV      r0,#0x2000            ;2119
000044  bd08              POP      {r3,pc}
                  |L23.70|
000046  f44f5040          MOV      r0,#0x3000            ;2123
00004a  bd08              POP      {r3,pc}
;;;2130   
                          ENDP


                          AREA ||i.USB_OTG_GetMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetMode PROC
;;;578    */
;;;579    uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;580    {
;;;581      return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
000002  6940              LDR      r0,[r0,#0x14]
000004  f0000001          AND      r0,r0,#1
;;;582    }
000008  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.USB_OTG_HC_DoPing||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_DoPing PROC
;;;1157   */
;;;1158   USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1159   {
000002  4603              MOV      r3,r0
;;;1160     USB_OTG_STS               status = USB_OTG_OK;
;;;1161     USB_OTG_HCCHAR_TypeDef    hcchar;
;;;1162     USB_OTG_HCTSIZn_TypeDef   hctsiz;  
;;;1163     
;;;1164     hctsiz.d32 = 0;
000004  2000              MOVS     r0,#0
;;;1165     hctsiz.b.dopng = 1;
000006  f04f4200          MOV      r2,#0x80000000
;;;1166     hctsiz.b.pktcnt = 1;
00000a  2401              MOVS     r4,#1
00000c  f36442dc          BFI      r2,r4,#19,#10
;;;1167     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
000010  eb030181          ADD      r1,r3,r1,LSL #2
000014  f8513f90          LDR      r3,[r1,#0x90]!
000018  611a              STR      r2,[r3,#0x10]
;;;1168     
;;;1169     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
00001a  6809              LDR      r1,[r1,#0]
00001c  680a              LDR      r2,[r1,#0]
;;;1170     hcchar.b.chen = 1;
00001e  f0424200          ORR      r2,r2,#0x80000000
;;;1171     hcchar.b.chdis = 0;
000022  f0224280          BIC      r2,r2,#0x40000000
;;;1172     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000026  600a              STR      r2,[r1,#0]
;;;1173     return status;  
;;;1174   }
000028  bd10              POP      {r4,pc}
;;;1175   
                          ENDP


                          AREA ||i.USB_OTG_HC_Halt||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Halt PROC
;;;1115   */
;;;1116   USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b530              PUSH     {r4,r5,lr}
;;;1117   {
000002  b086              SUB      sp,sp,#0x18
;;;1118     USB_OTG_STS status = USB_OTG_OK;
000004  2400              MOVS     r4,#0
;;;1119     USB_OTG_HNPTXSTS_TypeDef            nptxsts;
;;;1120     USB_OTG_HPTXSTS_TypeDef             hptxsts;
;;;1121     USB_OTG_HCCHAR_TypeDef              hcchar;
;;;1122     
;;;1123     nptxsts.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9203              STR      r2,[sp,#0xc]
;;;1124     hptxsts.d32 = 0;
00000a  9201              STR      r2,[sp,#4]
;;;1125     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
00000c  eb000381          ADD      r3,r0,r1,LSL #2
000010  f8d32090          LDR      r2,[r3,#0x90]
000014  6811              LDR      r1,[r2,#0]
;;;1126     
;;;1127     hcchar.b.chdis = 1;
000016  f0414180          ORR      r1,r1,#0x40000000
00001a  9100              STR      r1,[sp,#0]
;;;1128     
;;;1129     /* Check for space in the request queue to issue the halt. */
;;;1130     if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
00001c  f4112f40          TST      r1,#0xc0000
000020  d00b              BEQ      |L26.58|
000022  f3c14581          UBFX     r5,r1,#18,#2
000026  2d02              CMP      r5,#2
000028  d007              BEQ      |L26.58|
;;;1131     {
;;;1132       nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
;;;1133       if (nptxsts.b.nptxqspcavail == 0)
;;;1134       {
;;;1135         hcchar.b.chen = 0;
;;;1136         USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
;;;1137       }
;;;1138     }
;;;1139     else
;;;1140     {
;;;1141       hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
00002a  6940              LDR      r0,[r0,#0x14]
00002c  6900              LDR      r0,[r0,#0x10]
00002e  9001              STR      r0,[sp,#4]
;;;1142       if (hptxsts.b.ptxqspcavail == 0)
000030  9801              LDR      r0,[sp,#4]
000032  f4100f7f          TST      r0,#0xff0000
000036  d00c              BEQ      |L26.82|
000038  e00f              B        |L26.90|
                  |L26.58|
00003a  68c0              LDR      r0,[r0,#0xc]          ;1132
00003c  6ac0              LDR      r0,[r0,#0x2c]         ;1132
00003e  9003              STR      r0,[sp,#0xc]          ;1132
000040  9803              LDR      r0,[sp,#0xc]          ;1133
000042  f4100f7f          TST      r0,#0xff0000          ;1133
000046  d108              BNE      |L26.90|
000048  f0214000          BIC      r0,r1,#0x80000000     ;1135
00004c  9000              STR      r0,[sp,#0]            ;1135
00004e  6010              STR      r0,[r2,#0]            ;1136
000050  e003              B        |L26.90|
                  |L26.82|
;;;1143       {
;;;1144         hcchar.b.chen = 0;
000052  f0214000          BIC      r0,r1,#0x80000000
000056  9000              STR      r0,[sp,#0]
;;;1145         USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000058  6010              STR      r0,[r2,#0]
                  |L26.90|
;;;1146       }
;;;1147     }
;;;1148     hcchar.b.chen = 1;
00005a  9800              LDR      r0,[sp,#0]
00005c  f0404000          ORR      r0,r0,#0x80000000
;;;1149     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000060  f8d31090          LDR      r1,[r3,#0x90]
000064  6008              STR      r0,[r1,#0]
;;;1150     return status;
;;;1151   }
000066  b006              ADD      sp,sp,#0x18
000068  4620              MOV      r0,r4                 ;1150
00006a  bd30              POP      {r4,r5,pc}
;;;1152   
                          ENDP


                          AREA ||i.USB_OTG_HC_Init||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Init PROC
;;;888    */
;;;889    USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b5ff              PUSH     {r0-r7,lr}
;;;890    {
;;;891      USB_OTG_STS status = USB_OTG_OK;
000002  2600              MOVS     r6,#0
;;;892      uint32_t intr_enable = 0;
;;;893      USB_OTG_HCINTMSK_TypeDef  hcintmsk;
;;;894      USB_OTG_GINTMSK_TypeDef    gintmsk;
;;;895      USB_OTG_HCCHAR_TypeDef     hcchar;
;;;896      USB_OTG_HCINTn_TypeDef     hcint;
;;;897      
;;;898      
;;;899      gintmsk.d32 = 0;
000004  2500              MOVS     r5,#0
000006  9502              STR      r5,[sp,#8]
;;;900      hcintmsk.d32 = 0;
000008  9503              STR      r5,[sp,#0xc]
;;;901      hcchar.d32 = 0;
00000a  9501              STR      r5,[sp,#4]
;;;902      
;;;903      /* Clear old interrupt conditions for this host channel. */
;;;904      hcint.d32 = 0xFFFFFFFF;
00000c  1e6a              SUBS     r2,r5,#1
00000e  9200              STR      r2,[sp,#0]
;;;905      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
000010  eb000481          ADD      r4,r0,r1,LSL #2
000014  f8d43090          LDR      r3,[r4,#0x90]
000018  609a              STR      r2,[r3,#8]
;;;906      
;;;907      /* Enable channel interrupts required for this transfer. */
;;;908      hcintmsk.d32 = 0;
;;;909      
;;;910      if (pdev->cfg.dma_enable == 1)
00001a  78c2              LDRB     r2,[r0,#3]
00001c  2a01              CMP      r2,#1
00001e  d101              BNE      |L27.36|
;;;911      {
;;;912        hcintmsk.b.ahberr = 1;
000020  2204              MOVS     r2,#4
000022  9203              STR      r2,[sp,#0xc]
                  |L27.36|
;;;913      }
;;;914      
;;;915      switch (pdev->host.hc[hc_num].ep_type) 
000024  eb001241          ADD      r2,r0,r1,LSL #5
000028  f8923899          LDRB     r3,[r2,#0x899]
00002c  b133              CBZ      r3,|L27.60|
00002e  2b01              CMP      r3,#1
000030  d036              BEQ      |L27.160|
000032  2b02              CMP      r3,#2
000034  d002              BEQ      |L27.60|
000036  2b03              CMP      r3,#3
000038  d142              BNE      |L27.192|
00003a  e01c              B        |L27.118|
                  |L27.60|
;;;916      {
;;;917      case EP_TYPE_CTRL:
;;;918      case EP_TYPE_BULK:
;;;919        hcintmsk.b.xfercompl = 1;
00003c  9b03              LDR      r3,[sp,#0xc]
00003e  f0430301          ORR      r3,r3,#1
;;;920        hcintmsk.b.stall = 1;
000042  f0430308          ORR      r3,r3,#8
;;;921        hcintmsk.b.xacterr = 1;
000046  f0430380          ORR      r3,r3,#0x80
;;;922        hcintmsk.b.datatglerr = 1;
00004a  f4436380          ORR      r3,r3,#0x400
;;;923        hcintmsk.b.nak = 1;  
00004e  f0430310          ORR      r3,r3,#0x10
000052  9303              STR      r3,[sp,#0xc]
;;;924        if (pdev->host.hc[hc_num].ep_is_in) 
000054  f8927896          LDRB     r7,[r2,#0x896]
000058  b11f              CBZ      r7,|L27.98|
;;;925        {
;;;926          hcintmsk.b.bblerr = 1;
00005a  f4437380          ORR      r3,r3,#0x100
00005e  9303              STR      r3,[sp,#0xc]
000060  e02e              B        |L27.192|
                  |L27.98|
;;;927        } 
;;;928        else 
;;;929        {
;;;930          hcintmsk.b.nyet = 1;
000062  f0430340          ORR      r3,r3,#0x40
000066  9303              STR      r3,[sp,#0xc]
;;;931          if (pdev->host.hc[hc_num].do_ping) 
000068  f8927898          LDRB     r7,[r2,#0x898]
00006c  b347              CBZ      r7,|L27.192|
;;;932          {
;;;933            hcintmsk.b.ack = 1;
00006e  f0430320          ORR      r3,r3,#0x20
000072  9303              STR      r3,[sp,#0xc]
000074  e024              B        |L27.192|
                  |L27.118|
;;;934          }
;;;935        }
;;;936        break;
;;;937      case EP_TYPE_INTR:
;;;938        hcintmsk.b.xfercompl = 1;
000076  9b03              LDR      r3,[sp,#0xc]
000078  f0430301          ORR      r3,r3,#1
;;;939        hcintmsk.b.nak = 1;
00007c  f0430310          ORR      r3,r3,#0x10
;;;940        hcintmsk.b.stall = 1;
000080  f0430308          ORR      r3,r3,#8
;;;941        hcintmsk.b.xacterr = 1;
000084  f0430380          ORR      r3,r3,#0x80
;;;942        hcintmsk.b.datatglerr = 1;
000088  f4436380          ORR      r3,r3,#0x400
;;;943        hcintmsk.b.frmovrun = 1;
00008c  f4437300          ORR      r3,r3,#0x200
000090  9303              STR      r3,[sp,#0xc]
;;;944        
;;;945        if (pdev->host.hc[hc_num].ep_is_in) 
000092  f8927896          LDRB     r7,[r2,#0x896]
000096  b19f              CBZ      r7,|L27.192|
;;;946        {
;;;947          hcintmsk.b.bblerr = 1;
000098  f4437380          ORR      r3,r3,#0x100
00009c  9303              STR      r3,[sp,#0xc]
00009e  e00f              B        |L27.192|
                  |L27.160|
;;;948        }
;;;949        
;;;950        break;
;;;951      case EP_TYPE_ISOC:
;;;952        hcintmsk.b.xfercompl = 1;
0000a0  9b03              LDR      r3,[sp,#0xc]
0000a2  f0430301          ORR      r3,r3,#1
;;;953        hcintmsk.b.frmovrun = 1;
0000a6  f4437300          ORR      r3,r3,#0x200
;;;954        hcintmsk.b.ack = 1;
0000aa  f0430320          ORR      r3,r3,#0x20
0000ae  9303              STR      r3,[sp,#0xc]
;;;955        
;;;956        if (pdev->host.hc[hc_num].ep_is_in) 
0000b0  f8927896          LDRB     r7,[r2,#0x896]
0000b4  b127              CBZ      r7,|L27.192|
;;;957        {
;;;958          hcintmsk.b.xacterr = 1;
0000b6  f0430380          ORR      r3,r3,#0x80
;;;959          hcintmsk.b.bblerr = 1;
0000ba  f4437380          ORR      r3,r3,#0x100
0000be  9303              STR      r3,[sp,#0xc]
                  |L27.192|
;;;960        }
;;;961        break;
;;;962      }
;;;963      
;;;964      
;;;965      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
0000c0  f8d47090          LDR      r7,[r4,#0x90]
0000c4  9b03              LDR      r3,[sp,#0xc]
0000c6  60fb              STR      r3,[r7,#0xc]
;;;966      
;;;967      
;;;968      /* Enable the top level host channel interrupt. */
;;;969      intr_enable = (1 << hc_num);
0000c8  2301              MOVS     r3,#1
0000ca  408b              LSLS     r3,r3,r1
;;;970      USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
0000cc  6941              LDR      r1,[r0,#0x14]
0000ce  698f              LDR      r7,[r1,#0x18]
0000d0  431f              ORRS     r7,r7,r3
0000d2  618f              STR      r7,[r1,#0x18]
;;;971      
;;;972      /* Make sure host channel interrupts are enabled. */
;;;973      gintmsk.b.hcintr = 1;
0000d4  f04f7100          MOV      r1,#0x2000000
0000d8  9102              STR      r1,[sp,#8]
;;;974      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
0000da  68c0              LDR      r0,[r0,#0xc]
0000dc  6981              LDR      r1,[r0,#0x18]
0000de  f0417100          ORR      r1,r1,#0x2000000
0000e2  6181              STR      r1,[r0,#0x18]
;;;975      
;;;976      /* Program the HCCHAR register */
;;;977      hcchar.d32 = 0;
;;;978      hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
0000e4  f8920894          LDRB     r0,[r2,#0x894]
0000e8  f360559c          BFI      r5,r0,#22,#7
;;;979      hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
0000ec  f8920895          LDRB     r0,[r2,#0x895]
0000f0  f36025ce          BFI      r5,r0,#11,#4
;;;980      hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
0000f4  f8920896          LDRB     r0,[r2,#0x896]
0000f8  f36035cf          BFI      r5,r0,#15,#1
0000fc  9501              STR      r5,[sp,#4]
;;;981      hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
0000fe  f8920897          LDRB     r0,[r2,#0x897]
000102  2802              CMP      r0,#2
000104  d00d              BEQ      |L27.290|
000106  f4253000          BIC      r0,r5,#0x20000
                  |L27.266|
;;;982      hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
00010a  f8921899          LDRB     r1,[r2,#0x899]
00010e  f3614093          BFI      r0,r1,#18,#2
;;;983      hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
000112  f8b2289a          LDRH     r2,[r2,#0x89a]
000116  f362000a          BFI      r0,r2,#0,#11
00011a  9001              STR      r0,[sp,#4]
;;;984      if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
00011c  2903              CMP      r1,#3
00011e  d003              BEQ      |L27.296|
000120  e005              B        |L27.302|
                  |L27.290|
000122  f4453000          ORR      r0,r5,#0x20000        ;981
000126  e7f0              B        |L27.266|
                  |L27.296|
;;;985      {
;;;986        hcchar.b.oddfrm  = 1;
000128  f0405000          ORR      r0,r0,#0x20000000
00012c  9001              STR      r0,[sp,#4]
                  |L27.302|
;;;987      }
;;;988      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
00012e  f8d41090          LDR      r1,[r4,#0x90]
000132  9801              LDR      r0,[sp,#4]
000134  6008              STR      r0,[r1,#0]
;;;989      return status;
;;;990    }
000136  b004              ADD      sp,sp,#0x10
000138  4630              MOV      r0,r6                 ;989
00013a  bdf0              POP      {r4-r7,pc}
;;;991    
                          ENDP


                          AREA ||i.USB_OTG_HC_StartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_StartXfer PROC
;;;998    */
;;;999    USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1000   {
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
;;;1001     USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;1002     USB_OTG_HCCHAR_TypeDef   hcchar;
;;;1003     USB_OTG_HCTSIZn_TypeDef  hctsiz;
;;;1004     USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
;;;1005     USB_OTG_HPTXSTS_TypeDef  hptxsts; 
;;;1006     USB_OTG_GINTMSK_TypeDef  intmsk;
;;;1007     uint16_t                 len_words = 0;   
;;;1008     
;;;1009     uint16_t num_packets;
;;;1010     uint16_t max_hc_pkt_count;
;;;1011     
;;;1012     max_hc_pkt_count = 256;
000008  f44f7c80          MOV      r12,#0x100
;;;1013     hctsiz.d32 = 0;
00000c  2200              MOVS     r2,#0
00000e  9206              STR      r2,[sp,#0x18]
;;;1014     hcchar.d32 = 0;
000010  9207              STR      r2,[sp,#0x1c]
;;;1015     intmsk.d32 = 0;
000012  9200              STR      r2,[sp,#0]
;;;1016     
;;;1017     /* Compute the expected number of packets associated to the transfer */
;;;1018     if (pdev->host.hc[hc_num].xfer_len > 0)
000014  eb051441          ADD      r4,r5,r1,LSL #5
000018  f8d478a4          LDR      r7,[r4,#0x8a4]
00001c  2f00              CMP      r7,#0
00001e  d00d              BEQ      |L28.60|
;;;1019     {
;;;1020       num_packets = (pdev->host.hc[hc_num].xfer_len + \
000020  f8b4389a          LDRH     r3,[r4,#0x89a]
000024  18f8              ADDS     r0,r7,r3
000026  1e40              SUBS     r0,r0,#1
000028  fbb0f0f3          UDIV     r0,r0,r3
00002c  b280              UXTH     r0,r0
;;;1021         pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
;;;1022       
;;;1023       if (num_packets > max_hc_pkt_count)
00002e  4560              CMP      r0,r12
000030  d905              BLS      |L28.62|
;;;1024       {
;;;1025         num_packets = max_hc_pkt_count;
000032  4660              MOV      r0,r12
;;;1026         pdev->host.hc[hc_num].xfer_len = num_packets * \
000034  021b              LSLS     r3,r3,#8
000036  f8c438a4          STR      r3,[r4,#0x8a4]
00003a  e000              B        |L28.62|
                  |L28.60|
;;;1027           pdev->host.hc[hc_num].max_packet;
;;;1028       }
;;;1029     }
;;;1030     else
;;;1031     {
;;;1032       num_packets = 1;
00003c  2001              MOVS     r0,#1
                  |L28.62|
;;;1033     }
;;;1034     if (pdev->host.hc[hc_num].ep_is_in)
00003e  f8943896          LDRB     r3,[r4,#0x896]
000042  b123              CBZ      r3,|L28.78|
;;;1035     {
;;;1036       pdev->host.hc[hc_num].xfer_len = num_packets * \
000044  f8b4389a          LDRH     r3,[r4,#0x89a]
000048  4343              MULS     r3,r0,r3
00004a  f8c438a4          STR      r3,[r4,#0x8a4]
                  |L28.78|
;;;1037         pdev->host.hc[hc_num].max_packet;
;;;1038     }
;;;1039     /* Initialize the HCTSIZn register */
;;;1040     hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
00004e  f8d438a4          LDR      r3,[r4,#0x8a4]
000052  f3630212          BFI      r2,r3,#0,#19
;;;1041     hctsiz.b.pktcnt = num_packets;
000056  f36042dc          BFI      r2,r0,#19,#10
;;;1042     hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
00005a  f894089c          LDRB     r0,[r4,#0x89c]
00005e  f360725e          BFI      r2,r0,#29,#2
000062  9206              STR      r2,[sp,#0x18]
;;;1043     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
000064  eb050381          ADD      r3,r5,r1,LSL #2
000068  f8d30090          LDR      r0,[r3,#0x90]
00006c  6102              STR      r2,[r0,#0x10]
;;;1044     
;;;1045     if (pdev->cfg.dma_enable == 1)
00006e  78e8              LDRB     r0,[r5,#3]
000070  2801              CMP      r0,#1
000072  d104              BNE      |L28.126|
;;;1046     {
;;;1047       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
000074  f8d32090          LDR      r2,[r3,#0x90]
000078  f8d408a0          LDR      r0,[r4,#0x8a0]
00007c  6150              STR      r0,[r2,#0x14]
                  |L28.126|
;;;1048     }
;;;1049     
;;;1050     
;;;1051     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
00007e  f8530f90          LDR      r0,[r3,#0x90]!
000082  6802              LDR      r2,[r0,#0]
;;;1052     hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       USB_OTG_IsEvenFrame
00008a  f360725d          BFI      r2,r0,#29,#1
;;;1053     
;;;1054     /* Set host channel enable */
;;;1055     hcchar.b.chen = 1;
00008e  f0424000          ORR      r0,r2,#0x80000000
;;;1056     hcchar.b.chdis = 0;
000092  f0204080          BIC      r0,r0,#0x40000000
000096  9007              STR      r0,[sp,#0x1c]
;;;1057     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000098  681a              LDR      r2,[r3,#0]
00009a  6010              STR      r0,[r2,#0]
;;;1058     
;;;1059     if (pdev->cfg.dma_enable == 0) /* Slave mode */
00009c  78e8              LDRB     r0,[r5,#3]
00009e  bbe0              CBNZ     r0,|L28.282|
;;;1060     {  
;;;1061       if((pdev->host.hc[hc_num].ep_is_in == 0) && 
0000a0  f8940896          LDRB     r0,[r4,#0x896]
0000a4  bbc8              CBNZ     r0,|L28.282|
;;;1062          (pdev->host.hc[hc_num].xfer_len > 0))
0000a6  f8d438a4          LDR      r3,[r4,#0x8a4]
0000aa  b3b3              CBZ      r3,|L28.282|
;;;1063       {
;;;1064         switch(pdev->host.hc[hc_num].ep_type) 
0000ac  f8940899          LDRB     r0,[r4,#0x899]
0000b0  b130              CBZ      r0,|L28.192|
0000b2  2801              CMP      r0,#1
0000b4  d015              BEQ      |L28.226|
0000b6  2802              CMP      r0,#2
0000b8  d002              BEQ      |L28.192|
0000ba  2803              CMP      r0,#3
0000bc  d123              BNE      |L28.262|
0000be  e010              B        |L28.226|
                  |L28.192|
;;;1065         {
;;;1066           /* Non periodic transfer */
;;;1067         case EP_TYPE_CTRL:
;;;1068         case EP_TYPE_BULK:
;;;1069           
;;;1070           hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
0000c0  68e8              LDR      r0,[r5,#0xc]
0000c2  6ac2              LDR      r2,[r0,#0x2c]
0000c4  9203              STR      r2,[sp,#0xc]
;;;1071           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
0000c6  1cdb              ADDS     r3,r3,#3
0000c8  f3c3028f          UBFX     r2,r3,#2,#16
;;;1072           
;;;1073           /* check if there is enough space in FIFO space */
;;;1074           if(len_words > hnptxsts.b.nptxfspcavail)
0000cc  9b03              LDR      r3,[sp,#0xc]
0000ce  b29b              UXTH     r3,r3
0000d0  4293              CMP      r3,r2
0000d2  d218              BCS      |L28.262|
;;;1075           {
;;;1076             /* need to process data in nptxfempty interrupt */
;;;1077             intmsk.b.nptxfempty = 1;
0000d4  2220              MOVS     r2,#0x20
0000d6  9200              STR      r2,[sp,#0]
;;;1078             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0000d8  6982              LDR      r2,[r0,#0x18]
0000da  f0420220          ORR      r2,r2,#0x20
0000de  6182              STR      r2,[r0,#0x18]
0000e0  e011              B        |L28.262|
                  |L28.226|
;;;1079           }
;;;1080           
;;;1081           break;
;;;1082           /* Periodic transfer */
;;;1083         case EP_TYPE_INTR:
;;;1084         case EP_TYPE_ISOC:
;;;1085           hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
0000e2  6968              LDR      r0,[r5,#0x14]
0000e4  6900              LDR      r0,[r0,#0x10]
0000e6  9001              STR      r0,[sp,#4]
;;;1086           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
0000e8  1cdb              ADDS     r3,r3,#3
0000ea  f3c3008f          UBFX     r0,r3,#2,#16
;;;1087           /* check if there is enough space in FIFO space */
;;;1088           if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
0000ee  9a01              LDR      r2,[sp,#4]
0000f0  b292              UXTH     r2,r2
0000f2  4282              CMP      r2,r0
0000f4  d207              BCS      |L28.262|
;;;1089           {
;;;1090             /* need to process data in ptxfempty interrupt */
;;;1091             intmsk.b.ptxfempty = 1;
0000f6  f04f6080          MOV      r0,#0x4000000
0000fa  9000              STR      r0,[sp,#0]
;;;1092             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0000fc  68e8              LDR      r0,[r5,#0xc]
0000fe  6982              LDR      r2,[r0,#0x18]
000100  f0426280          ORR      r2,r2,#0x4000000
000104  6182              STR      r2,[r0,#0x18]
                  |L28.262|
;;;1093           }
;;;1094           break;
;;;1095           
;;;1096         default:
;;;1097           break;
;;;1098         }
;;;1099         
;;;1100         /* Write packet into the Tx FIFO. */
;;;1101         USB_OTG_WritePacket(pdev, 
000106  f8b408a4          LDRH     r0,[r4,#0x8a4]
00010a  460a              MOV      r2,r1
00010c  b283              UXTH     r3,r0
00010e  f8d408a0          LDR      r0,[r4,#0x8a0]
000112  4601              MOV      r1,r0
000114  4628              MOV      r0,r5
000116  f7fffffe          BL       USB_OTG_WritePacket
                  |L28.282|
;;;1102                             pdev->host.hc[hc_num].xfer_buff , 
;;;1103                             hc_num, pdev->host.hc[hc_num].xfer_len);
;;;1104       }
;;;1105     }
;;;1106     return status;
;;;1107   }
00011a  b008              ADD      sp,sp,#0x20
00011c  4630              MOV      r0,r6                 ;1106
00011e  bdf0              POP      {r4-r7,pc}
;;;1108   
                          ENDP


                          AREA ||i.USB_OTG_InitDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_OTG_InitDevSpeed PROC
;;;1212   */
;;;1213   void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
000000  6900              LDR      r0,[r0,#0x10]
;;;1214   {
;;;1215     USB_OTG_DCFG_TypeDef   dcfg;
;;;1216     
;;;1217     dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
000002  6802              LDR      r2,[r0,#0]
;;;1218     dcfg.b.devspd = speed;
000004  f3610201          BFI      r2,r1,#0,#2
;;;1219     USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
000008  6002              STR      r2,[r0,#0]
;;;1220   }
00000a  4770              BX       lr
;;;1221   
                          ENDP


                          AREA ||i.USB_OTG_InitFSLSPClkSel||, CODE, READONLY, ALIGN=1

                  USB_OTG_InitFSLSPClkSel PROC
;;;821    */
;;;822    void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
000000  6940              LDR      r0,[r0,#0x14]
;;;823    {
;;;824      USB_OTG_HCFG_TypeDef   hcfg;
;;;825      
;;;826      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
000002  6802              LDR      r2,[r0,#0]
;;;827      hcfg.b.fslspclksel = freq;
000004  f3610201          BFI      r2,r1,#0,#2
;;;828      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
000008  6002              STR      r2,[r0,#0]
;;;829    }
00000a  4770              BX       lr
;;;830    
                          ENDP


                          AREA ||i.USB_OTG_IsDeviceMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsDeviceMode PROC
;;;589    */
;;;590    uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
000000  b500              PUSH     {lr}
;;;591    {
;;;592      return (USB_OTG_GetMode(pdev) != HOST_MODE);
000002  f7fffffe          BL       USB_OTG_GetMode
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L31.14|
00000a  2001              MOVS     r0,#1
;;;593    }
00000c  bd00              POP      {pc}
                  |L31.14|
00000e  2000              MOVS     r0,#0                 ;592
000010  bd00              POP      {pc}
;;;594    
                          ENDP


                          AREA ||i.USB_OTG_IsEvenFrame||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsEvenFrame PROC
;;;740    */
;;;741    uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
000000  6940              LDR      r0,[r0,#0x14]
;;;742    {
;;;743      return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
000002  6880              LDR      r0,[r0,#8]
000004  f3400000          SBFX     r0,r0,#0,#1
000008  1c40              ADDS     r0,r0,#1
;;;744    }
00000a  4770              BX       lr
;;;745    
                          ENDP


                          AREA ||i.USB_OTG_IsHostMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsHostMode PROC
;;;600    */
;;;601    uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
000000  b500              PUSH     {lr}
;;;602    {
;;;603      return (USB_OTG_GetMode(pdev) == HOST_MODE);
000002  f7fffffe          BL       USB_OTG_GetMode
000006  2801              CMP      r0,#1
000008  d000              BEQ      |L33.12|
00000a  2000              MOVS     r0,#0
                  |L33.12|
;;;604    }
00000c  bd00              POP      {pc}
;;;605    
                          ENDP


                          AREA ||i.USB_OTG_ReadCoreItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadCoreItr PROC
;;;611    */
;;;612    uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;613    {
;;;614      uint32_t v = 0;
;;;615      v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
000002  6941              LDR      r1,[r0,#0x14]
;;;616      v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
000004  6980              LDR      r0,[r0,#0x18]
000006  4008              ANDS     r0,r0,r1
;;;617      return v;
;;;618    }
000008  4770              BX       lr
;;;619    
                          ENDP


                          AREA ||i.USB_OTG_ReadDevAllInEPItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevAllInEPItr PROC
;;;1949   */
;;;1950   uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
000000  6900              LDR      r0,[r0,#0x10]
;;;1951   {
;;;1952     uint32_t v;
;;;1953     v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
000002  6981              LDR      r1,[r0,#0x18]
;;;1954     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
000004  69c0              LDR      r0,[r0,#0x1c]
000006  4008              ANDS     r0,r0,r1
;;;1955     return (v & 0xffff);
000008  b280              UXTH     r0,r0
;;;1956   }
00000a  4770              BX       lr
;;;1957   
                          ENDP


                          AREA ||i.USB_OTG_ReadDevAllOutEp_itr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevAllOutEp_itr PROC
;;;1920   */
;;;1921   uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
000000  6900              LDR      r0,[r0,#0x10]
;;;1922   {
;;;1923     uint32_t v;
;;;1924     v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
000002  6981              LDR      r1,[r0,#0x18]
;;;1925     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
000004  69c0              LDR      r0,[r0,#0x1c]
000006  4008              ANDS     r0,r0,r1
;;;1926     return ((v & 0xffff0000) >> 16);
000008  0c00              LSRS     r0,r0,#16
;;;1927   }
00000a  4770              BX       lr
;;;1928   
                          ENDP


                          AREA ||i.USB_OTG_ReadDevOutEP_itr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevOutEP_itr PROC
;;;1935   */
;;;1936   uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
000000  eb000181          ADD      r1,r0,r1,LSL #2
;;;1937   {
;;;1938     uint32_t v;
;;;1939     v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
000004  6d49              LDR      r1,[r1,#0x54]
000006  6889              LDR      r1,[r1,#8]
;;;1940     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
000008  6900              LDR      r0,[r0,#0x10]
00000a  6940              LDR      r0,[r0,#0x14]
00000c  4008              ANDS     r0,r0,r1
;;;1941     return v;
;;;1942   }
00000e  4770              BX       lr
;;;1943   
                          ENDP


                          AREA ||i.USB_OTG_ReadHPRT0||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHPRT0 PROC
;;;836    */
;;;837    uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
000000  f8d000cc          LDR      r0,[r0,#0xcc]
;;;838    {
;;;839      USB_OTG_HPRT0_TypeDef  hprt0;
;;;840      
;;;841      hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
000004  6800              LDR      r0,[r0,#0]
;;;842      hprt0.b.prtena = 0;
000006  f0200004          BIC      r0,r0,#4
;;;843      hprt0.b.prtconndet = 0;
00000a  f0200002          BIC      r0,r0,#2
;;;844      hprt0.b.prtenchng = 0;
00000e  f0200008          BIC      r0,r0,#8
;;;845      hprt0.b.prtovrcurrchng = 0;
000012  f0200020          BIC      r0,r0,#0x20
;;;846      return hprt0.d32;
;;;847    }
000016  4770              BX       lr
;;;848    
                          ENDP


                          AREA ||i.USB_OTG_ReadHostAllChannels_intr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHostAllChannels_intr PROC
;;;854    */
;;;855    uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
000000  6940              LDR      r0,[r0,#0x14]
;;;856    {
;;;857      return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
000002  6940              LDR      r0,[r0,#0x14]
;;;858    }
000004  4770              BX       lr
;;;859    
                          ENDP


                          AREA ||i.USB_OTG_ReadOtgItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadOtgItr PROC
;;;625    */
;;;626    uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;627    {
;;;628      return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
000002  6840              LDR      r0,[r0,#4]
;;;629    }
000004  4770              BX       lr
;;;630    
                          ENDP


                          AREA ||i.USB_OTG_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadPacket PROC
;;;197    */
;;;198    void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;199                             uint8_t *dest, 
;;;200                             uint16_t len)
;;;201    {
000002  4604              MOV      r4,r0
000004  4608              MOV      r0,r1
;;;202      uint32_t i=0;
000006  2100              MOVS     r1,#0
;;;203      uint32_t count32b = (len + 3) / 4;
000008  1cd2              ADDS     r2,r2,#3
00000a  0893              LSRS     r3,r2,#2
;;;204      
;;;205      __IO uint32_t *fifo = pdev->regs.DFIFO[0];
00000c  f8d420d0          LDR      r2,[r4,#0xd0]
000010  e003              B        |L41.26|
                  |L41.18|
;;;206      
;;;207      for( i = 0; i < count32b; i++)
;;;208      {
;;;209        *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
000012  6814              LDR      r4,[r2,#0]
000014  f8404b04          STR      r4,[r0],#4
000018  1c49              ADDS     r1,r1,#1              ;207
                  |L41.26|
00001a  4299              CMP      r1,r3                 ;207
00001c  d3f9              BCC      |L41.18|
;;;210        dest += 4 ;
;;;211      }
;;;212      return ((void *)dest);
;;;213    }
00001e  bd10              POP      {r4,pc}
;;;214    
                          ENDP


                          AREA ||i.USB_OTG_ResetPort||, CODE, READONLY, ALIGN=1

                  USB_OTG_ResetPort PROC
;;;867    */
;;;868    uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;869    {
000002  4605              MOV      r5,r0
;;;870      USB_OTG_HPRT0_TypeDef  hprt0;
;;;871      
;;;872      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       USB_OTG_ReadHPRT0
;;;873      hprt0.b.prtrst = 1;
00000a  f4407480          ORR      r4,r0,#0x100
;;;874      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00000e  f8550fcc          LDR      r0,[r5,#0xcc]!
000012  6004              STR      r4,[r0,#0]
;;;875      USB_OTG_BSP_mDelay (100);                                /* See Note #1 */
000014  2064              MOVS     r0,#0x64
000016  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;876      hprt0.b.prtrst = 0;
00001a  f4247080          BIC      r0,r4,#0x100
;;;877      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00001e  6829              LDR      r1,[r5,#0]
000020  6008              STR      r0,[r1,#0]
;;;878      USB_OTG_BSP_mDelay (20);   
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;879      return 1;
000028  2001              MOVS     r0,#1
;;;880    }
00002a  bd70              POP      {r4-r6,pc}
;;;881    
                          ENDP


                          AREA ||i.USB_OTG_SelectCore||, CODE, READONLY, ALIGN=2

                  USB_OTG_SelectCore PROC
;;;221    */
;;;222    USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;223                                   USB_OTG_CORE_ID_TypeDef coreID)
;;;224    {
;;;225      uint32_t i , baseAddress = 0;
000002  2200              MOVS     r2,#0
;;;226      USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;227      
;;;228      pdev->cfg.dma_enable       = 0;
000006  2400              MOVS     r4,#0
000008  70c4              STRB     r4,[r0,#3]
;;;229      
;;;230      /* at startup the core is in FS mode */
;;;231      pdev->cfg.speed            = USB_OTG_SPEED_FULL;
00000a  2301              MOVS     r3,#1
00000c  7083              STRB     r3,[r0,#2]
;;;232      pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
00000e  2640              MOVS     r6,#0x40
000010  8086              STRH     r6,[r0,#4]
;;;233      
;;;234      /* initialize device cfg following its address */
;;;235      if (coreID == USB_OTG_FS_CORE_ID)
;;;236      {
;;;237        baseAddress                = USB_OTG_FS_BASE_ADDR;
;;;238        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
;;;239        pdev->cfg.host_channels    = 8 ;
;;;240        pdev->cfg.dev_endpoints    = 4 ;
;;;241        pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
;;;242        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
000012  2602              MOVS     r6,#2
000014  2901              CMP      r1,#1                 ;235
000016  d001              BEQ      |L43.28|
;;;243        
;;;244    #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
;;;245        pdev->cfg.Sof_output       = 1;    
;;;246    #endif 
;;;247        
;;;248    #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
;;;249        pdev->cfg.low_power        = 1;    
;;;250    #endif     
;;;251      }
;;;252      else if (coreID == USB_OTG_HS_CORE_ID)
000018  b159              CBZ      r1,|L43.50|
00001a  e015              B        |L43.72|
                  |L43.28|
00001c  f04f42a0          MOV      r2,#0x50000000        ;237
000020  72c3              STRB     r3,[r0,#0xb]          ;238
000022  2108              MOVS     r1,#8                 ;239
000024  7001              STRB     r1,[r0,#0]            ;239
000026  2104              MOVS     r1,#4                 ;240
000028  7041              STRB     r1,[r0,#1]            ;240
00002a  1591              ASRS     r1,r2,#22             ;241
00002c  80c1              STRH     r1,[r0,#6]            ;241
00002e  7206              STRB     r6,[r0,#8]            ;242
000030  e00a              B        |L43.72|
                  |L43.50|
;;;253      {
;;;254        baseAddress                = USB_OTG_HS_BASE_ADDR;
000032  4a23              LDR      r2,|L43.192|
;;;255        pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
000034  72c4              STRB     r4,[r0,#0xb]
;;;256        pdev->cfg.host_channels    = 12 ;
000036  210c              MOVS     r1,#0xc
000038  7001              STRB     r1,[r0,#0]
;;;257        pdev->cfg.dev_endpoints    = 6 ;
00003a  2106              MOVS     r1,#6
00003c  7041              STRB     r1,[r0,#1]
;;;258        pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
00003e  f44f61a0          MOV      r1,#0x500
000042  80c1              STRH     r1,[r0,#6]
;;;259        
;;;260    #ifdef USB_OTG_ULPI_PHY_ENABLED
;;;261        pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
;;;262    #else    
;;;263    #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
;;;264        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
000044  7206              STRB     r6,[r0,#8]
;;;265    #endif  
;;;266    #endif      
;;;267        
;;;268    #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
;;;269        pdev->cfg.dma_enable       = 1;    
000046  70c3              STRB     r3,[r0,#3]
                  |L43.72|
;;;270    #endif
;;;271        
;;;272    #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
;;;273        pdev->cfg.Sof_output       = 1;    
;;;274    #endif 
;;;275        
;;;276    #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
;;;277        pdev->cfg.low_power        = 1;    
;;;278    #endif 
;;;279        
;;;280      }
;;;281      
;;;282      else
;;;283      {
;;;284        /* Do Nothing */
;;;285      }
;;;286      
;;;287      pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
000048  60c2              STR      r2,[r0,#0xc]
;;;288        USB_OTG_CORE_GLOBAL_REGS_OFFSET);
;;;289      pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
00004a  f5026100          ADD      r1,r2,#0x800
00004e  6101              STR      r1,[r0,#0x10]
;;;290        USB_OTG_DEV_GLOBAL_REG_OFFSET);
;;;291      
;;;292      for (i = 0; i < pdev->cfg.dev_endpoints; i++)
000050  2100              MOVS     r1,#0
000052  e00a              B        |L43.106|
                  |L43.84|
;;;293      {
;;;294        pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
000054  eb021341          ADD      r3,r2,r1,LSL #5
000058  eb000481          ADD      r4,r0,r1,LSL #2
00005c  f5036610          ADD      r6,r3,#0x900
000060  61a6              STR      r6,[r4,#0x18]
;;;295          (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
;;;296            (i * USB_OTG_EP_REG_OFFSET));
;;;297        pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
000062  f5036330          ADD      r3,r3,#0xb00
000066  6563              STR      r3,[r4,#0x54]
000068  1c49              ADDS     r1,r1,#1              ;292
                  |L43.106|
00006a  7843              LDRB     r3,[r0,#1]            ;292
00006c  428b              CMP      r3,r1                 ;292
00006e  d8f1              BHI      |L43.84|
;;;298          (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
;;;299            (i * USB_OTG_EP_REG_OFFSET));
;;;300      }
;;;301      pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
000070  f5026180          ADD      r1,r2,#0x400
000074  6141              STR      r1,[r0,#0x14]
;;;302        USB_OTG_HOST_GLOBAL_REG_OFFSET);
;;;303      pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
000076  3140              ADDS     r1,r1,#0x40
000078  f8c010cc          STR      r1,[r0,#0xcc]
;;;304      
;;;305      for (i = 0; i < pdev->cfg.host_channels; i++)
00007c  2100              MOVS     r1,#0
00007e  e008              B        |L43.146|
                  |L43.128|
;;;306      {
;;;307        pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
000080  eb021341          ADD      r3,r2,r1,LSL #5
000084  eb000481          ADD      r4,r0,r1,LSL #2
000088  f50363a0          ADD      r3,r3,#0x500
00008c  f8c43090          STR      r3,[r4,#0x90]
000090  1c49              ADDS     r1,r1,#1              ;305
                  |L43.146|
000092  7803              LDRB     r3,[r0,#0]            ;305
000094  428b              CMP      r3,r1                 ;305
000096  d8f3              BHI      |L43.128|
;;;308          USB_OTG_HOST_CHAN_REGS_OFFSET + \
;;;309            (i * USB_OTG_CHAN_REGS_OFFSET));
;;;310      }
;;;311      for (i = 0; i < pdev->cfg.host_channels; i++)
000098  2100              MOVS     r1,#0
00009a  e008              B        |L43.174|
                  |L43.156|
;;;312      {
;;;313        pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
00009c  eb023301          ADD      r3,r2,r1,LSL #12
0000a0  eb000481          ADD      r4,r0,r1,LSL #2
0000a4  f5035380          ADD      r3,r3,#0x1000
0000a8  f8c430d0          STR      r3,[r4,#0xd0]
0000ac  1c49              ADDS     r1,r1,#1              ;311
                  |L43.174|
0000ae  7803              LDRB     r3,[r0,#0]            ;311
0000b0  428b              CMP      r3,r1                 ;311
0000b2  d8f3              BHI      |L43.156|
;;;314          (i * USB_OTG_DATA_FIFO_SIZE));
;;;315      }
;;;316      pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
0000b4  f5026260          ADD      r2,r2,#0xe00
0000b8  f8c0210c          STR      r2,[r0,#0x10c]
;;;317      
;;;318      return status;
0000bc  4628              MOV      r0,r5
;;;319    }
0000be  bd70              POP      {r4-r6,pc}
;;;320    
                          ENDP

                  |L43.192|
                          DCD      0x40040000

                          AREA ||i.USB_OTG_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetCurrentMode PROC
;;;543    */
;;;544    USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
000000  b538              PUSH     {r3-r5,lr}
;;;545    {
;;;546      USB_OTG_STS status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
;;;547      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;548      
;;;549      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
000004  68c3              LDR      r3,[r0,#0xc]
000006  68d8              LDR      r0,[r3,#0xc]
;;;550      
;;;551      usbcfg.b.force_host = 0;
000008  f0205000          BIC      r0,r0,#0x20000000
;;;552      usbcfg.b.force_dev = 0;
00000c  f0204280          BIC      r2,r0,#0x40000000
000010  9200              STR      r2,[sp,#0]
;;;553      
;;;554      if ( mode == HOST_MODE)
000012  2901              CMP      r1,#1
000014  d001              BEQ      |L44.26|
;;;555      {
;;;556        usbcfg.b.force_host = 1;
;;;557      }
;;;558      else if ( mode == DEVICE_MODE)
000016  b121              CBZ      r1,|L44.34|
000018  e006              B        |L44.40|
                  |L44.26|
00001a  f0425000          ORR      r0,r2,#0x20000000     ;556
00001e  9000              STR      r0,[sp,#0]            ;556
000020  e002              B        |L44.40|
                  |L44.34|
;;;559      {
;;;560        usbcfg.b.force_dev = 1;
000022  f0424080          ORR      r0,r2,#0x40000000
000026  9000              STR      r0,[sp,#0]
                  |L44.40|
;;;561      }
;;;562      
;;;563      else
;;;564      {
;;;565        /* Do Nothing */
;;;566      }
;;;567      
;;;568      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
000028  9800              LDR      r0,[sp,#0]
00002a  60d8              STR      r0,[r3,#0xc]
;;;569      USB_OTG_BSP_mDelay(50);
00002c  2032              MOVS     r0,#0x32
00002e  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;570      return status;
000032  4620              MOV      r0,r4
;;;571    }
000034  bd38              POP      {r3-r5,pc}
;;;572    
                          ENDP


                          AREA ||i.USB_OTG_SetEPStatus||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetEPStatus PROC
;;;2137   */
;;;2138   void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
000000  b438              PUSH     {r3-r5}
;;;2139   {
;;;2140     USB_OTG_DEPCTL_TypeDef  depctl;
;;;2141     __IO uint32_t *depctl_addr;
;;;2142     
;;;2143     depctl.d32 = 0;
000002  2500              MOVS     r5,#0
000004  9500              STR      r5,[sp,#0]
;;;2144     
;;;2145     /* Process for IN endpoint */
;;;2146     if (ep->is_in == 1)
000006  784c              LDRB     r4,[r1,#1]
;;;2147     {
;;;2148       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000008  780b              LDRB     r3,[r1,#0]
00000a  2c01              CMP      r4,#1                 ;2146
00000c  eb000383          ADD      r3,r0,r3,LSL #2
000010  d00d              BEQ      |L45.46|
;;;2149       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
;;;2150       
;;;2151       if (Status == USB_OTG_EP_TX_STALL)  
;;;2152       {
;;;2153         USB_OTG_EPSetStall(pdev, ep); return;
;;;2154       }
;;;2155       else if (Status == USB_OTG_EP_TX_NAK)
;;;2156       {
;;;2157         depctl.b.snak = 1;
;;;2158       }
;;;2159       else if (Status == USB_OTG_EP_TX_VALID)
;;;2160       {
;;;2161         if (depctl.b.stall == 1)
;;;2162         {  
;;;2163           ep->even_odd_frame = 0;
;;;2164           USB_OTG_EPClearStall(pdev, ep);
;;;2165           return;
;;;2166         }      
;;;2167         depctl.b.cnak = 1;
;;;2168         depctl.b.usbactep = 1; 
;;;2169         depctl.b.epena = 1;
;;;2170       }
;;;2171       else if (Status == USB_OTG_EP_TX_DIS)
;;;2172       {
;;;2173         depctl.b.usbactep = 0;
;;;2174       }
;;;2175       
;;;2176       else
;;;2177       {
;;;2178         /* Do Nothing */
;;;2179       }
;;;2180     } 
;;;2181     else /* Process for OUT endpoint */
;;;2182     {
;;;2183       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
000012  6d5c              LDR      r4,[r3,#0x54]
;;;2184       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
000014  6823              LDR      r3,[r4,#0]
000016  9300              STR      r3,[sp,#0]
;;;2185       
;;;2186       if (Status == USB_OTG_EP_RX_STALL)  {
000018  f5b25f80          CMP      r2,#0x1000
00001c  d02b              BEQ      |L45.118|
;;;2187         depctl.b.stall = 1;
;;;2188       }
;;;2189       else if (Status == USB_OTG_EP_RX_NAK)
00001e  f5b25f00          CMP      r2,#0x2000
000022  d02c              BEQ      |L45.126|
;;;2190       {
;;;2191         depctl.b.snak = 1;
;;;2192       }
;;;2193       else if (Status == USB_OTG_EP_RX_VALID)
000024  f5b25f40          CMP      r2,#0x3000
000028  d02d              BEQ      |L45.134|
;;;2194       {
;;;2195         if (depctl.b.stall == 1)
;;;2196         {  
;;;2197           ep->even_odd_frame = 0;
;;;2198           USB_OTG_EPClearStall(pdev, ep);
;;;2199           return;
;;;2200         }  
;;;2201         depctl.b.cnak = 1;
;;;2202         depctl.b.usbactep = 1;    
;;;2203         depctl.b.epena = 1;
;;;2204       }
;;;2205       else if (Status == USB_OTG_EP_RX_DIS)
00002a  b3d2              CBZ      r2,|L45.162|
00002c  e03d              B        |L45.170|
                  |L45.46|
00002e  699c              LDR      r4,[r3,#0x18]         ;2148
000030  6823              LDR      r3,[r4,#0]            ;2149
000032  9300              STR      r3,[sp,#0]            ;2149
000034  2a10              CMP      r2,#0x10              ;2151
000036  d005              BEQ      |L45.68|
000038  2a20              CMP      r2,#0x20              ;2155
00003a  d006              BEQ      |L45.74|
00003c  2a30              CMP      r2,#0x30              ;2159
00003e  d008              BEQ      |L45.82|
000040  b1aa              CBZ      r2,|L45.110|
000042  e032              B        |L45.170|
                  |L45.68|
000044  bc38              POP      {r3-r5}               ;2153
000046  f7ffbffe          B.W      USB_OTG_EPSetStall
                  |L45.74|
00004a  f0436000          ORR      r0,r3,#0x8000000      ;2157
00004e  9000              STR      r0,[sp,#0]            ;2157
000050  e02b              B        |L45.170|
                  |L45.82|
000052  029a              LSLS     r2,r3,#10             ;2161
000054  d503              BPL      |L45.94|
000056  714d              STRB     r5,[r1,#5]            ;2163
000058  bc38              POP      {r3-r5}               ;2164
00005a  f7ffbffe          B.W      USB_OTG_EPClearStall
                  |L45.94|
00005e  f0436080          ORR      r0,r3,#0x4000000      ;2167
000062  f4404000          ORR      r0,r0,#0x8000         ;2168
000066  f0404000          ORR      r0,r0,#0x80000000     ;2169
00006a  9000              STR      r0,[sp,#0]            ;2169
00006c  e01d              B        |L45.170|
                  |L45.110|
00006e  f4234000          BIC      r0,r3,#0x8000         ;2173
000072  9000              STR      r0,[sp,#0]            ;2173
000074  e019              B        |L45.170|
                  |L45.118|
000076  f4431000          ORR      r0,r3,#0x200000       ;2187
00007a  9000              STR      r0,[sp,#0]            ;2187
00007c  e015              B        |L45.170|
                  |L45.126|
00007e  f0436000          ORR      r0,r3,#0x8000000      ;2191
000082  9000              STR      r0,[sp,#0]            ;2191
000084  e011              B        |L45.170|
                  |L45.134|
000086  029a              LSLS     r2,r3,#10             ;2195
000088  d503              BPL      |L45.146|
00008a  714d              STRB     r5,[r1,#5]            ;2197
00008c  bc38              POP      {r3-r5}               ;2198
00008e  f7ffbffe          B.W      USB_OTG_EPClearStall
                  |L45.146|
000092  f0436080          ORR      r0,r3,#0x4000000      ;2201
000096  f4404000          ORR      r0,r0,#0x8000         ;2202
00009a  f0404000          ORR      r0,r0,#0x80000000     ;2203
00009e  9000              STR      r0,[sp,#0]            ;2203
0000a0  e003              B        |L45.170|
                  |L45.162|
0000a2  e7ff              B        |L45.164|
                  |L45.164|
;;;2206       {
;;;2207         depctl.b.usbactep = 0;    
0000a4  f4234000          BIC      r0,r3,#0x8000
0000a8  9000              STR      r0,[sp,#0]
                  |L45.170|
;;;2208       }
;;;2209       
;;;2210       else
;;;2211       {
;;;2212         /* Do Nothing */
;;;2213       }
;;;2214     }
;;;2215     
;;;2216     USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
0000aa  9800              LDR      r0,[sp,#0]
0000ac  6020              STR      r0,[r4,#0]
;;;2217   }
0000ae  bc38              POP      {r3-r5}
0000b0  4770              BX       lr
;;;2218   
                          ENDP


                          AREA ||i.USB_OTG_StopDevice||, CODE, READONLY, ALIGN=1

                  USB_OTG_StopDevice PROC
;;;2054   */
;;;2055   void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
000000  b510              PUSH     {r4,lr}
;;;2056   {
000002  4604              MOV      r4,r0
;;;2057     uint32_t i;
;;;2058     
;;;2059     pdev->dev.device_status = 1;
000004  2001              MOVS     r0,#1
000006  f8840112          STRB     r0,[r4,#0x112]
;;;2060     
;;;2061     for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
00000a  2000              MOVS     r0,#0
;;;2062     {
;;;2063       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
00000c  22ff              MOVS     r2,#0xff
00000e  e006              B        |L46.30|
                  |L46.16|
000010  eb040180          ADD      r1,r4,r0,LSL #2
000014  698b              LDR      r3,[r1,#0x18]
000016  609a              STR      r2,[r3,#8]
;;;2064       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
000018  6d49              LDR      r1,[r1,#0x54]
00001a  608a              STR      r2,[r1,#8]
00001c  1c40              ADDS     r0,r0,#1              ;2061
                  |L46.30|
00001e  7861              LDRB     r1,[r4,#1]            ;2061
000020  4281              CMP      r1,r0                 ;2061
000022  d8f5              BHI      |L46.16|
;;;2065     }
;;;2066     
;;;2067     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
000024  6921              LDR      r1,[r4,#0x10]
000026  2000              MOVS     r0,#0
000028  6108              STR      r0,[r1,#0x10]
;;;2068     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
00002a  6921              LDR      r1,[r4,#0x10]
00002c  6148              STR      r0,[r1,#0x14]
;;;2069     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
00002e  6921              LDR      r1,[r4,#0x10]
000030  61c8              STR      r0,[r1,#0x1c]
;;;2070     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
000032  6921              LDR      r1,[r4,#0x10]
000034  1e40              SUBS     r0,r0,#1
000036  6188              STR      r0,[r1,#0x18]
;;;2071     
;;;2072     /* Flush the FIFO */
;;;2073     USB_OTG_FlushRxFifo(pdev);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;2074     USB_OTG_FlushTxFifo(pdev ,  0x10 );  
00003e  4620              MOV      r0,r4
000040  e8bd4010          POP      {r4,lr}
000044  2110              MOVS     r1,#0x10
000046  f7ffbffe          B.W      USB_OTG_FlushTxFifo
;;;2075   }
;;;2076   
                          ENDP


                          AREA ||i.USB_OTG_StopHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_StopHost PROC
;;;1180   */
;;;1181   void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;1182   {
000002  4604              MOV      r4,r0
;;;1183     USB_OTG_HCCHAR_TypeDef  hcchar;
;;;1184     uint32_t                i;
;;;1185     
;;;1186     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
000004  2000              MOVS     r0,#0
000006  6961              LDR      r1,[r4,#0x14]
000008  6188              STR      r0,[r1,#0x18]
;;;1187     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
00000a  6961              LDR      r1,[r4,#0x14]
00000c  1e40              SUBS     r0,r0,#1
00000e  6148              STR      r0,[r1,#0x14]
;;;1188     /* Flush out any leftover queued requests. */
;;;1189     
;;;1190     for (i = 0; i < pdev->cfg.host_channels; i++)
000010  2100              MOVS     r1,#0
000012  e00d              B        |L47.48|
                  |L47.20|
;;;1191     {
;;;1192       hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
000014  eb040081          ADD      r0,r4,r1,LSL #2
000018  f8d02090          LDR      r2,[r0,#0x90]
00001c  6810              LDR      r0,[r2,#0]
;;;1193       hcchar.b.chen = 0;
00001e  f0204000          BIC      r0,r0,#0x80000000
;;;1194       hcchar.b.chdis = 1;
000022  f0404080          ORR      r0,r0,#0x40000000
;;;1195       hcchar.b.epdir = 0;
000026  f4204000          BIC      r0,r0,#0x8000
00002a  9000              STR      r0,[sp,#0]
;;;1196       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
00002c  6010              STR      r0,[r2,#0]
00002e  1c49              ADDS     r1,r1,#1              ;1190
                  |L47.48|
000030  7820              LDRB     r0,[r4,#0]            ;1190
000032  4288              CMP      r0,r1                 ;1190
000034  d8ee              BHI      |L47.20|
;;;1197     }
;;;1198     
;;;1199     /* Flush the FIFO */
;;;1200     USB_OTG_FlushRxFifo(pdev);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;1201     USB_OTG_FlushTxFifo(pdev ,  0x10 );  
00003c  4620              MOV      r0,r4
00003e  e8bd4038          POP      {r3-r5,lr}
000042  2110              MOVS     r1,#0x10
000044  f7ffbffe          B.W      USB_OTG_FlushTxFifo
;;;1202   }
;;;1203   #endif
                          ENDP


                          AREA ||i.USB_OTG_UngateClock||, CODE, READONLY, ALIGN=1

                  USB_OTG_UngateClock PROC
;;;2027   */
;;;2028   void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
000000  b50c              PUSH     {r2,r3,lr}
;;;2029   {
;;;2030     if(pdev->cfg.low_power)
000002  7a81              LDRB     r1,[r0,#0xa]
000004  2900              CMP      r1,#0
000006  d00d              BEQ      |L48.36|
;;;2031     {
;;;2032       
;;;2033       USB_OTG_DSTS_TypeDef     dsts;
;;;2034       USB_OTG_PCGCCTL_TypeDef  power; 
;;;2035       
;;;2036       dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
000008  6901              LDR      r1,[r0,#0x10]
00000a  6889              LDR      r1,[r1,#8]
00000c  9101              STR      r1,[sp,#4]
;;;2037       
;;;2038       if(dsts.b.suspsts == 1)
00000e  07c9              LSLS     r1,r1,#31
000010  d008              BEQ      |L48.36|
;;;2039       {
;;;2040         /* un-gate USB Core clock */
;;;2041         power.d32 = USB_OTG_READ_REG32(pdev->regs.PCGCCTL);
000012  f8d0110c          LDR      r1,[r0,#0x10c]
000016  6808              LDR      r0,[r1,#0]
;;;2042         power.b.gatehclk = 0;
000018  f0200002          BIC      r0,r0,#2
;;;2043         power.b.stoppclk = 0;
00001c  f0200001          BIC      r0,r0,#1
000020  9000              STR      r0,[sp,#0]
;;;2044         USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
000022  6008              STR      r0,[r1,#0]
                  |L48.36|
;;;2045         
;;;2046       }
;;;2047     }
;;;2048   }
000024  bd0c              POP      {r2,r3,pc}
;;;2049   
                          ENDP


                          AREA ||i.USB_OTG_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_WritePacket PROC
;;;167    */
;;;168    USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b530              PUSH     {r4,r5,lr}
;;;169                                    uint8_t             *src, 
;;;170                                    uint8_t             ch_ep_num, 
;;;171                                    uint16_t            len)
;;;172    {
000002  4605              MOV      r5,r0
;;;173      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;174      if (pdev->cfg.dma_enable == 0)
000006  78ec              LDRB     r4,[r5,#3]
000008  2c00              CMP      r4,#0
00000a  d10c              BNE      |L49.38|
;;;175      {
;;;176        uint32_t count32b= 0 , i= 0;
;;;177        __IO uint32_t *fifo;
;;;178        
;;;179        count32b =  (len + 3) / 4;
00000c  1cdb              ADDS     r3,r3,#3
00000e  089b              LSRS     r3,r3,#2
;;;180        fifo = pdev->regs.DFIFO[ch_ep_num];
000010  eb050282          ADD      r2,r5,r2,LSL #2
000014  f8d220d0          LDR      r2,[r2,#0xd0]
;;;181        for (i = 0; i < count32b; i++)
000018  e003              B        |L49.34|
                  |L49.26|
;;;182        {
;;;183          USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
00001a  f8515b04          LDR      r5,[r1],#4
00001e  6015              STR      r5,[r2,#0]
000020  1c64              ADDS     r4,r4,#1              ;181
                  |L49.34|
000022  429c              CMP      r4,r3                 ;181
000024  d3f9              BCC      |L49.26|
                  |L49.38|
;;;184          src+=4;
;;;185        }
;;;186      }
;;;187      return status;
;;;188    }
000026  bd30              POP      {r4,r5,pc}
;;;189    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32_USB_OTG_Driver\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_core_c_0d2ec05c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REVSH|
#line 144
|__asm___10_usb_core_c_0d2ec05c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
